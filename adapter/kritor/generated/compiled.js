// temepory fix from https://github.com/protobufjs/protobuf.js/issues/1929
import $protobuf from "protobufjs/minimal.js"; // added .js

// Common aliases
const $Reader = $protobuf.Reader, // replaced $protobuf with $protobuf.default
  $Writer = $protobuf.Writer,
  $util = $protobuf.util

// Exported root namespace
const $root = $protobuf.roots || ($protobuf.roots = {}) // replaced $protobuf.roots["default"] with $protobuf.default.roots

export const kritor = $root.kritor = (() => {

    /**
     * Namespace kritor.
     * @exports kritor
     * @namespace
     */
    const kritor = {};

    kritor.Authentication = (function() {

        /**
         * Constructs a new Authentication service.
         * @memberof kritor
         * @classdesc Represents an Authentication
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Authentication(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Authentication.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Authentication;

        /**
         * Creates new Authentication service using the specified rpc implementation.
         * @function create
         * @memberof kritor.Authentication
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Authentication} RPC service. Useful where requests and/or responses are streamed.
         */
        Authentication.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link kritor.Authentication#auth}.
         * @memberof kritor.Authentication
         * @typedef AuthCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.AuthRsp} [response] AuthRsp
         */

        /**
         * Calls Auth.
         * @function auth
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IAuthReq} request AuthReq message or plain object
         * @param {kritor.Authentication.AuthCallback} callback Node-style callback called with the error, if any, and AuthRsp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Authentication.prototype.auth = function auth(request, callback) {
            return this.rpcCall(auth, $root.kritor.AuthReq, $root.kritor.AuthRsp, request, callback);
        }, "name", { value: "Auth" });

        /**
         * Calls Auth.
         * @function auth
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IAuthReq} request AuthReq message or plain object
         * @returns {Promise<kritor.AuthRsp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link kritor.Authentication#getAuthState}.
         * @memberof kritor.Authentication
         * @typedef GetAuthStateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.GetAuthStateRsp} [response] GetAuthStateRsp
         */

        /**
         * Calls GetAuthState.
         * @function getAuthState
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IGetAuthStateReq} request GetAuthStateReq message or plain object
         * @param {kritor.Authentication.GetAuthStateCallback} callback Node-style callback called with the error, if any, and GetAuthStateRsp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Authentication.prototype.getAuthState = function getAuthState(request, callback) {
            return this.rpcCall(getAuthState, $root.kritor.GetAuthStateReq, $root.kritor.GetAuthStateRsp, request, callback);
        }, "name", { value: "GetAuthState" });

        /**
         * Calls GetAuthState.
         * @function getAuthState
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IGetAuthStateReq} request GetAuthStateReq message or plain object
         * @returns {Promise<kritor.GetAuthStateRsp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link kritor.Authentication#getTicket}.
         * @memberof kritor.Authentication
         * @typedef GetTicketCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.GetTicketRsp} [response] GetTicketRsp
         */

        /**
         * Calls GetTicket.
         * @function getTicket
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IGetTicketReq} request GetTicketReq message or plain object
         * @param {kritor.Authentication.GetTicketCallback} callback Node-style callback called with the error, if any, and GetTicketRsp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Authentication.prototype.getTicket = function getTicket(request, callback) {
            return this.rpcCall(getTicket, $root.kritor.GetTicketReq, $root.kritor.GetTicketRsp, request, callback);
        }, "name", { value: "GetTicket" });

        /**
         * Calls GetTicket.
         * @function getTicket
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IGetTicketReq} request GetTicketReq message or plain object
         * @returns {Promise<kritor.GetTicketRsp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link kritor.Authentication#deleteTicket}.
         * @memberof kritor.Authentication
         * @typedef DeleteTicketCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.DeleteTicketRsp} [response] DeleteTicketRsp
         */

        /**
         * Calls DeleteTicket.
         * @function deleteTicket
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IDeleteTicketReq} request DeleteTicketReq message or plain object
         * @param {kritor.Authentication.DeleteTicketCallback} callback Node-style callback called with the error, if any, and DeleteTicketRsp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Authentication.prototype.deleteTicket = function deleteTicket(request, callback) {
            return this.rpcCall(deleteTicket, $root.kritor.DeleteTicketReq, $root.kritor.DeleteTicketRsp, request, callback);
        }, "name", { value: "DeleteTicket" });

        /**
         * Calls DeleteTicket.
         * @function deleteTicket
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IDeleteTicketReq} request DeleteTicketReq message or plain object
         * @returns {Promise<kritor.DeleteTicketRsp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link kritor.Authentication#addTicket}.
         * @memberof kritor.Authentication
         * @typedef AddTicketCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.AddTicketRsp} [response] AddTicketRsp
         */

        /**
         * Calls AddTicket.
         * @function addTicket
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IAddTicketReq} request AddTicketReq message or plain object
         * @param {kritor.Authentication.AddTicketCallback} callback Node-style callback called with the error, if any, and AddTicketRsp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Authentication.prototype.addTicket = function addTicket(request, callback) {
            return this.rpcCall(addTicket, $root.kritor.AddTicketReq, $root.kritor.AddTicketRsp, request, callback);
        }, "name", { value: "AddTicket" });

        /**
         * Calls AddTicket.
         * @function addTicket
         * @memberof kritor.Authentication
         * @instance
         * @param {kritor.IAddTicketReq} request AddTicketReq message or plain object
         * @returns {Promise<kritor.AddTicketRsp>} Promise
         * @variation 2
         */

        return Authentication;
    })();

    /**
     * AuthCode enum.
     * @name kritor.AuthCode
     * @enum {number}
     * @property {number} OK=0 OK value
     * @property {number} NO_ACCOUNT=1 NO_ACCOUNT value
     * @property {number} NO_TICKET=2 NO_TICKET value
     * @property {number} LOGIC_ERROR=3 LOGIC_ERROR value
     */
    kritor.AuthCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[1] = "NO_ACCOUNT"] = 1;
        values[valuesById[2] = "NO_TICKET"] = 2;
        values[valuesById[3] = "LOGIC_ERROR"] = 3;
        return values;
    })();

    kritor.AuthReq = (function() {

        /**
         * Properties of an AuthReq.
         * @memberof kritor
         * @interface IAuthReq
         * @property {string|null} [ticket] AuthReq ticket
         * @property {string|null} [account] AuthReq account
         */

        /**
         * Constructs a new AuthReq.
         * @memberof kritor
         * @classdesc Represents an AuthReq.
         * @implements IAuthReq
         * @constructor
         * @param {kritor.IAuthReq=} [properties] Properties to set
         */
        function AuthReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthReq ticket.
         * @member {string} ticket
         * @memberof kritor.AuthReq
         * @instance
         */
        AuthReq.prototype.ticket = "";

        /**
         * AuthReq account.
         * @member {string} account
         * @memberof kritor.AuthReq
         * @instance
         */
        AuthReq.prototype.account = "";

        /**
         * Creates a new AuthReq instance using the specified properties.
         * @function create
         * @memberof kritor.AuthReq
         * @static
         * @param {kritor.IAuthReq=} [properties] Properties to set
         * @returns {kritor.AuthReq} AuthReq instance
         */
        AuthReq.create = function create(properties) {
            return new AuthReq(properties);
        };

        /**
         * Encodes the specified AuthReq message. Does not implicitly {@link kritor.AuthReq.verify|verify} messages.
         * @function encode
         * @memberof kritor.AuthReq
         * @static
         * @param {kritor.IAuthReq} message AuthReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ticket);
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.account);
            return writer;
        };

        /**
         * Encodes the specified AuthReq message, length delimited. Does not implicitly {@link kritor.AuthReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.AuthReq
         * @static
         * @param {kritor.IAuthReq} message AuthReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthReq message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.AuthReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.AuthReq} AuthReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.AuthReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ticket = reader.string();
                        break;
                    }
                case 2: {
                        message.account = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.AuthReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.AuthReq} AuthReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthReq message.
         * @function verify
         * @memberof kritor.AuthReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                if (!$util.isString(message.ticket))
                    return "ticket: string expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            return null;
        };

        /**
         * Creates an AuthReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.AuthReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.AuthReq} AuthReq
         */
        AuthReq.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.AuthReq)
                return object;
            let message = new $root.kritor.AuthReq();
            if (object.ticket != null)
                message.ticket = String(object.ticket);
            if (object.account != null)
                message.account = String(object.account);
            return message;
        };

        /**
         * Creates a plain object from an AuthReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.AuthReq
         * @static
         * @param {kritor.AuthReq} message AuthReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ticket = "";
                object.account = "";
            }
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                object.ticket = message.ticket;
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            return object;
        };

        /**
         * Converts this AuthReq to JSON.
         * @function toJSON
         * @memberof kritor.AuthReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AuthReq
         * @function getTypeUrl
         * @memberof kritor.AuthReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AuthReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.AuthReq";
        };

        return AuthReq;
    })();

    kritor.AuthRsp = (function() {

        /**
         * Properties of an AuthRsp.
         * @memberof kritor
         * @interface IAuthRsp
         * @property {kritor.AuthCode|null} [code] AuthRsp code
         * @property {string|null} [msg] AuthRsp msg
         */

        /**
         * Constructs a new AuthRsp.
         * @memberof kritor
         * @classdesc Represents an AuthRsp.
         * @implements IAuthRsp
         * @constructor
         * @param {kritor.IAuthRsp=} [properties] Properties to set
         */
        function AuthRsp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthRsp code.
         * @member {kritor.AuthCode} code
         * @memberof kritor.AuthRsp
         * @instance
         */
        AuthRsp.prototype.code = 0;

        /**
         * AuthRsp msg.
         * @member {string} msg
         * @memberof kritor.AuthRsp
         * @instance
         */
        AuthRsp.prototype.msg = "";

        /**
         * Creates a new AuthRsp instance using the specified properties.
         * @function create
         * @memberof kritor.AuthRsp
         * @static
         * @param {kritor.IAuthRsp=} [properties] Properties to set
         * @returns {kritor.AuthRsp} AuthRsp instance
         */
        AuthRsp.create = function create(properties) {
            return new AuthRsp(properties);
        };

        /**
         * Encodes the specified AuthRsp message. Does not implicitly {@link kritor.AuthRsp.verify|verify} messages.
         * @function encode
         * @memberof kritor.AuthRsp
         * @static
         * @param {kritor.IAuthRsp} message AuthRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
            return writer;
        };

        /**
         * Encodes the specified AuthRsp message, length delimited. Does not implicitly {@link kritor.AuthRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.AuthRsp
         * @static
         * @param {kritor.IAuthRsp} message AuthRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthRsp message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.AuthRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.AuthRsp} AuthRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.AuthRsp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.code = reader.int32();
                        break;
                    }
                case 2: {
                        message.msg = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.AuthRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.AuthRsp} AuthRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthRsp message.
         * @function verify
         * @memberof kritor.AuthRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                switch (message.code) {
                default:
                    return "code: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            return null;
        };

        /**
         * Creates an AuthRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.AuthRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.AuthRsp} AuthRsp
         */
        AuthRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.AuthRsp)
                return object;
            let message = new $root.kritor.AuthRsp();
            switch (object.code) {
            default:
                if (typeof object.code === "number") {
                    message.code = object.code;
                    break;
                }
                break;
            case "OK":
            case 0:
                message.code = 0;
                break;
            case "NO_ACCOUNT":
            case 1:
                message.code = 1;
                break;
            case "NO_TICKET":
            case 2:
                message.code = 2;
                break;
            case "LOGIC_ERROR":
            case 3:
                message.code = 3;
                break;
            }
            if (object.msg != null)
                message.msg = String(object.msg);
            return message;
        };

        /**
         * Creates a plain object from an AuthRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.AuthRsp
         * @static
         * @param {kritor.AuthRsp} message AuthRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.code = options.enums === String ? "OK" : 0;
                object.msg = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.enums === String ? $root.kritor.AuthCode[message.code] === undefined ? message.code : $root.kritor.AuthCode[message.code] : message.code;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            return object;
        };

        /**
         * Converts this AuthRsp to JSON.
         * @function toJSON
         * @memberof kritor.AuthRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AuthRsp
         * @function getTypeUrl
         * @memberof kritor.AuthRsp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AuthRsp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.AuthRsp";
        };

        return AuthRsp;
    })();

    kritor.GetAuthStateReq = (function() {

        /**
         * Properties of a GetAuthStateReq.
         * @memberof kritor
         * @interface IGetAuthStateReq
         * @property {string|null} [account] GetAuthStateReq account
         */

        /**
         * Constructs a new GetAuthStateReq.
         * @memberof kritor
         * @classdesc Represents a GetAuthStateReq.
         * @implements IGetAuthStateReq
         * @constructor
         * @param {kritor.IGetAuthStateReq=} [properties] Properties to set
         */
        function GetAuthStateReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAuthStateReq account.
         * @member {string} account
         * @memberof kritor.GetAuthStateReq
         * @instance
         */
        GetAuthStateReq.prototype.account = "";

        /**
         * Creates a new GetAuthStateReq instance using the specified properties.
         * @function create
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {kritor.IGetAuthStateReq=} [properties] Properties to set
         * @returns {kritor.GetAuthStateReq} GetAuthStateReq instance
         */
        GetAuthStateReq.create = function create(properties) {
            return new GetAuthStateReq(properties);
        };

        /**
         * Encodes the specified GetAuthStateReq message. Does not implicitly {@link kritor.GetAuthStateReq.verify|verify} messages.
         * @function encode
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {kritor.IGetAuthStateReq} message GetAuthStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAuthStateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            return writer;
        };

        /**
         * Encodes the specified GetAuthStateReq message, length delimited. Does not implicitly {@link kritor.GetAuthStateReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {kritor.IGetAuthStateReq} message GetAuthStateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAuthStateReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAuthStateReq message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.GetAuthStateReq} GetAuthStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAuthStateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.GetAuthStateReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.account = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAuthStateReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.GetAuthStateReq} GetAuthStateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAuthStateReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAuthStateReq message.
         * @function verify
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAuthStateReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            return null;
        };

        /**
         * Creates a GetAuthStateReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.GetAuthStateReq} GetAuthStateReq
         */
        GetAuthStateReq.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.GetAuthStateReq)
                return object;
            let message = new $root.kritor.GetAuthStateReq();
            if (object.account != null)
                message.account = String(object.account);
            return message;
        };

        /**
         * Creates a plain object from a GetAuthStateReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {kritor.GetAuthStateReq} message GetAuthStateReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAuthStateReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.account = "";
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            return object;
        };

        /**
         * Converts this GetAuthStateReq to JSON.
         * @function toJSON
         * @memberof kritor.GetAuthStateReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAuthStateReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetAuthStateReq
         * @function getTypeUrl
         * @memberof kritor.GetAuthStateReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetAuthStateReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.GetAuthStateReq";
        };

        return GetAuthStateReq;
    })();

    kritor.GetAuthStateRsp = (function() {

        /**
         * Properties of a GetAuthStateRsp.
         * @memberof kritor
         * @interface IGetAuthStateRsp
         * @property {boolean|null} [isRequiredAuth] GetAuthStateRsp isRequiredAuth
         */

        /**
         * Constructs a new GetAuthStateRsp.
         * @memberof kritor
         * @classdesc Represents a GetAuthStateRsp.
         * @implements IGetAuthStateRsp
         * @constructor
         * @param {kritor.IGetAuthStateRsp=} [properties] Properties to set
         */
        function GetAuthStateRsp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAuthStateRsp isRequiredAuth.
         * @member {boolean} isRequiredAuth
         * @memberof kritor.GetAuthStateRsp
         * @instance
         */
        GetAuthStateRsp.prototype.isRequiredAuth = false;

        /**
         * Creates a new GetAuthStateRsp instance using the specified properties.
         * @function create
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {kritor.IGetAuthStateRsp=} [properties] Properties to set
         * @returns {kritor.GetAuthStateRsp} GetAuthStateRsp instance
         */
        GetAuthStateRsp.create = function create(properties) {
            return new GetAuthStateRsp(properties);
        };

        /**
         * Encodes the specified GetAuthStateRsp message. Does not implicitly {@link kritor.GetAuthStateRsp.verify|verify} messages.
         * @function encode
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {kritor.IGetAuthStateRsp} message GetAuthStateRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAuthStateRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isRequiredAuth != null && Object.hasOwnProperty.call(message, "isRequiredAuth"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isRequiredAuth);
            return writer;
        };

        /**
         * Encodes the specified GetAuthStateRsp message, length delimited. Does not implicitly {@link kritor.GetAuthStateRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {kritor.IGetAuthStateRsp} message GetAuthStateRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAuthStateRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAuthStateRsp message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.GetAuthStateRsp} GetAuthStateRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAuthStateRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.GetAuthStateRsp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isRequiredAuth = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAuthStateRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.GetAuthStateRsp} GetAuthStateRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAuthStateRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAuthStateRsp message.
         * @function verify
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAuthStateRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isRequiredAuth != null && message.hasOwnProperty("isRequiredAuth"))
                if (typeof message.isRequiredAuth !== "boolean")
                    return "isRequiredAuth: boolean expected";
            return null;
        };

        /**
         * Creates a GetAuthStateRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.GetAuthStateRsp} GetAuthStateRsp
         */
        GetAuthStateRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.GetAuthStateRsp)
                return object;
            let message = new $root.kritor.GetAuthStateRsp();
            if (object.isRequiredAuth != null)
                message.isRequiredAuth = Boolean(object.isRequiredAuth);
            return message;
        };

        /**
         * Creates a plain object from a GetAuthStateRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {kritor.GetAuthStateRsp} message GetAuthStateRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAuthStateRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.isRequiredAuth = false;
            if (message.isRequiredAuth != null && message.hasOwnProperty("isRequiredAuth"))
                object.isRequiredAuth = message.isRequiredAuth;
            return object;
        };

        /**
         * Converts this GetAuthStateRsp to JSON.
         * @function toJSON
         * @memberof kritor.GetAuthStateRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAuthStateRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetAuthStateRsp
         * @function getTypeUrl
         * @memberof kritor.GetAuthStateRsp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetAuthStateRsp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.GetAuthStateRsp";
        };

        return GetAuthStateRsp;
    })();

    kritor.GetTicketReq = (function() {

        /**
         * Properties of a GetTicketReq.
         * @memberof kritor
         * @interface IGetTicketReq
         * @property {string|null} [account] GetTicketReq account
         * @property {string|null} [ticket] GetTicketReq ticket
         */

        /**
         * Constructs a new GetTicketReq.
         * @memberof kritor
         * @classdesc Represents a GetTicketReq.
         * @implements IGetTicketReq
         * @constructor
         * @param {kritor.IGetTicketReq=} [properties] Properties to set
         */
        function GetTicketReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTicketReq account.
         * @member {string} account
         * @memberof kritor.GetTicketReq
         * @instance
         */
        GetTicketReq.prototype.account = "";

        /**
         * GetTicketReq ticket.
         * @member {string} ticket
         * @memberof kritor.GetTicketReq
         * @instance
         */
        GetTicketReq.prototype.ticket = "";

        /**
         * Creates a new GetTicketReq instance using the specified properties.
         * @function create
         * @memberof kritor.GetTicketReq
         * @static
         * @param {kritor.IGetTicketReq=} [properties] Properties to set
         * @returns {kritor.GetTicketReq} GetTicketReq instance
         */
        GetTicketReq.create = function create(properties) {
            return new GetTicketReq(properties);
        };

        /**
         * Encodes the specified GetTicketReq message. Does not implicitly {@link kritor.GetTicketReq.verify|verify} messages.
         * @function encode
         * @memberof kritor.GetTicketReq
         * @static
         * @param {kritor.IGetTicketReq} message GetTicketReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTicketReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticket);
            return writer;
        };

        /**
         * Encodes the specified GetTicketReq message, length delimited. Does not implicitly {@link kritor.GetTicketReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.GetTicketReq
         * @static
         * @param {kritor.IGetTicketReq} message GetTicketReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTicketReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTicketReq message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.GetTicketReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.GetTicketReq} GetTicketReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTicketReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.GetTicketReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.account = reader.string();
                        break;
                    }
                case 2: {
                        message.ticket = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTicketReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.GetTicketReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.GetTicketReq} GetTicketReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTicketReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTicketReq message.
         * @function verify
         * @memberof kritor.GetTicketReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTicketReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                if (!$util.isString(message.ticket))
                    return "ticket: string expected";
            return null;
        };

        /**
         * Creates a GetTicketReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.GetTicketReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.GetTicketReq} GetTicketReq
         */
        GetTicketReq.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.GetTicketReq)
                return object;
            let message = new $root.kritor.GetTicketReq();
            if (object.account != null)
                message.account = String(object.account);
            if (object.ticket != null)
                message.ticket = String(object.ticket);
            return message;
        };

        /**
         * Creates a plain object from a GetTicketReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.GetTicketReq
         * @static
         * @param {kritor.GetTicketReq} message GetTicketReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTicketReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.account = "";
                object.ticket = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                object.ticket = message.ticket;
            return object;
        };

        /**
         * Converts this GetTicketReq to JSON.
         * @function toJSON
         * @memberof kritor.GetTicketReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTicketReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTicketReq
         * @function getTypeUrl
         * @memberof kritor.GetTicketReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTicketReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.GetTicketReq";
        };

        return GetTicketReq;
    })();

    kritor.GetTicketRsp = (function() {

        /**
         * Properties of a GetTicketRsp.
         * @memberof kritor
         * @interface IGetTicketRsp
         * @property {number|null} [code] GetTicketRsp code
         * @property {string|null} [msg] GetTicketRsp msg
         * @property {Array.<string>|null} [ticket] GetTicketRsp ticket
         */

        /**
         * Constructs a new GetTicketRsp.
         * @memberof kritor
         * @classdesc Represents a GetTicketRsp.
         * @implements IGetTicketRsp
         * @constructor
         * @param {kritor.IGetTicketRsp=} [properties] Properties to set
         */
        function GetTicketRsp(properties) {
            this.ticket = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTicketRsp code.
         * @member {number} code
         * @memberof kritor.GetTicketRsp
         * @instance
         */
        GetTicketRsp.prototype.code = 0;

        /**
         * GetTicketRsp msg.
         * @member {string} msg
         * @memberof kritor.GetTicketRsp
         * @instance
         */
        GetTicketRsp.prototype.msg = "";

        /**
         * GetTicketRsp ticket.
         * @member {Array.<string>} ticket
         * @memberof kritor.GetTicketRsp
         * @instance
         */
        GetTicketRsp.prototype.ticket = $util.emptyArray;

        /**
         * Creates a new GetTicketRsp instance using the specified properties.
         * @function create
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {kritor.IGetTicketRsp=} [properties] Properties to set
         * @returns {kritor.GetTicketRsp} GetTicketRsp instance
         */
        GetTicketRsp.create = function create(properties) {
            return new GetTicketRsp(properties);
        };

        /**
         * Encodes the specified GetTicketRsp message. Does not implicitly {@link kritor.GetTicketRsp.verify|verify} messages.
         * @function encode
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {kritor.IGetTicketRsp} message GetTicketRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTicketRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
            if (message.ticket != null && message.ticket.length)
                for (let i = 0; i < message.ticket.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticket[i]);
            return writer;
        };

        /**
         * Encodes the specified GetTicketRsp message, length delimited. Does not implicitly {@link kritor.GetTicketRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {kritor.IGetTicketRsp} message GetTicketRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTicketRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTicketRsp message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.GetTicketRsp} GetTicketRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTicketRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.GetTicketRsp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.code = reader.int32();
                        break;
                    }
                case 2: {
                        message.msg = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.ticket && message.ticket.length))
                            message.ticket = [];
                        message.ticket.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTicketRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.GetTicketRsp} GetTicketRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTicketRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTicketRsp message.
         * @function verify
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTicketRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            if (message.ticket != null && message.hasOwnProperty("ticket")) {
                if (!Array.isArray(message.ticket))
                    return "ticket: array expected";
                for (let i = 0; i < message.ticket.length; ++i)
                    if (!$util.isString(message.ticket[i]))
                        return "ticket: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetTicketRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.GetTicketRsp} GetTicketRsp
         */
        GetTicketRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.GetTicketRsp)
                return object;
            let message = new $root.kritor.GetTicketRsp();
            if (object.code != null)
                message.code = object.code | 0;
            if (object.msg != null)
                message.msg = String(object.msg);
            if (object.ticket) {
                if (!Array.isArray(object.ticket))
                    throw TypeError(".kritor.GetTicketRsp.ticket: array expected");
                message.ticket = [];
                for (let i = 0; i < object.ticket.length; ++i)
                    message.ticket[i] = String(object.ticket[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTicketRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {kritor.GetTicketRsp} message GetTicketRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTicketRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ticket = [];
            if (options.defaults) {
                object.code = 0;
                object.msg = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            if (message.ticket && message.ticket.length) {
                object.ticket = [];
                for (let j = 0; j < message.ticket.length; ++j)
                    object.ticket[j] = message.ticket[j];
            }
            return object;
        };

        /**
         * Converts this GetTicketRsp to JSON.
         * @function toJSON
         * @memberof kritor.GetTicketRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTicketRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetTicketRsp
         * @function getTypeUrl
         * @memberof kritor.GetTicketRsp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetTicketRsp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.GetTicketRsp";
        };

        return GetTicketRsp;
    })();

    kritor.AddTicketReq = (function() {

        /**
         * Properties of an AddTicketReq.
         * @memberof kritor
         * @interface IAddTicketReq
         * @property {string|null} [account] AddTicketReq account
         * @property {string|null} [ticket] AddTicketReq ticket
         * @property {string|null} [newTicket] AddTicketReq newTicket
         */

        /**
         * Constructs a new AddTicketReq.
         * @memberof kritor
         * @classdesc Represents an AddTicketReq.
         * @implements IAddTicketReq
         * @constructor
         * @param {kritor.IAddTicketReq=} [properties] Properties to set
         */
        function AddTicketReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddTicketReq account.
         * @member {string} account
         * @memberof kritor.AddTicketReq
         * @instance
         */
        AddTicketReq.prototype.account = "";

        /**
         * AddTicketReq ticket.
         * @member {string} ticket
         * @memberof kritor.AddTicketReq
         * @instance
         */
        AddTicketReq.prototype.ticket = "";

        /**
         * AddTicketReq newTicket.
         * @member {string} newTicket
         * @memberof kritor.AddTicketReq
         * @instance
         */
        AddTicketReq.prototype.newTicket = "";

        /**
         * Creates a new AddTicketReq instance using the specified properties.
         * @function create
         * @memberof kritor.AddTicketReq
         * @static
         * @param {kritor.IAddTicketReq=} [properties] Properties to set
         * @returns {kritor.AddTicketReq} AddTicketReq instance
         */
        AddTicketReq.create = function create(properties) {
            return new AddTicketReq(properties);
        };

        /**
         * Encodes the specified AddTicketReq message. Does not implicitly {@link kritor.AddTicketReq.verify|verify} messages.
         * @function encode
         * @memberof kritor.AddTicketReq
         * @static
         * @param {kritor.IAddTicketReq} message AddTicketReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddTicketReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticket);
            if (message.newTicket != null && Object.hasOwnProperty.call(message, "newTicket"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.newTicket);
            return writer;
        };

        /**
         * Encodes the specified AddTicketReq message, length delimited. Does not implicitly {@link kritor.AddTicketReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.AddTicketReq
         * @static
         * @param {kritor.IAddTicketReq} message AddTicketReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddTicketReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddTicketReq message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.AddTicketReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.AddTicketReq} AddTicketReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddTicketReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.AddTicketReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.account = reader.string();
                        break;
                    }
                case 2: {
                        message.ticket = reader.string();
                        break;
                    }
                case 3: {
                        message.newTicket = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddTicketReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.AddTicketReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.AddTicketReq} AddTicketReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddTicketReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddTicketReq message.
         * @function verify
         * @memberof kritor.AddTicketReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddTicketReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                if (!$util.isString(message.ticket))
                    return "ticket: string expected";
            if (message.newTicket != null && message.hasOwnProperty("newTicket"))
                if (!$util.isString(message.newTicket))
                    return "newTicket: string expected";
            return null;
        };

        /**
         * Creates an AddTicketReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.AddTicketReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.AddTicketReq} AddTicketReq
         */
        AddTicketReq.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.AddTicketReq)
                return object;
            let message = new $root.kritor.AddTicketReq();
            if (object.account != null)
                message.account = String(object.account);
            if (object.ticket != null)
                message.ticket = String(object.ticket);
            if (object.newTicket != null)
                message.newTicket = String(object.newTicket);
            return message;
        };

        /**
         * Creates a plain object from an AddTicketReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.AddTicketReq
         * @static
         * @param {kritor.AddTicketReq} message AddTicketReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddTicketReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.account = "";
                object.ticket = "";
                object.newTicket = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                object.ticket = message.ticket;
            if (message.newTicket != null && message.hasOwnProperty("newTicket"))
                object.newTicket = message.newTicket;
            return object;
        };

        /**
         * Converts this AddTicketReq to JSON.
         * @function toJSON
         * @memberof kritor.AddTicketReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddTicketReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddTicketReq
         * @function getTypeUrl
         * @memberof kritor.AddTicketReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddTicketReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.AddTicketReq";
        };

        return AddTicketReq;
    })();

    kritor.AddTicketRsp = (function() {

        /**
         * Properties of an AddTicketRsp.
         * @memberof kritor
         * @interface IAddTicketRsp
         * @property {number|null} [code] AddTicketRsp code
         * @property {string|null} [msg] AddTicketRsp msg
         */

        /**
         * Constructs a new AddTicketRsp.
         * @memberof kritor
         * @classdesc Represents an AddTicketRsp.
         * @implements IAddTicketRsp
         * @constructor
         * @param {kritor.IAddTicketRsp=} [properties] Properties to set
         */
        function AddTicketRsp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddTicketRsp code.
         * @member {number} code
         * @memberof kritor.AddTicketRsp
         * @instance
         */
        AddTicketRsp.prototype.code = 0;

        /**
         * AddTicketRsp msg.
         * @member {string} msg
         * @memberof kritor.AddTicketRsp
         * @instance
         */
        AddTicketRsp.prototype.msg = "";

        /**
         * Creates a new AddTicketRsp instance using the specified properties.
         * @function create
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {kritor.IAddTicketRsp=} [properties] Properties to set
         * @returns {kritor.AddTicketRsp} AddTicketRsp instance
         */
        AddTicketRsp.create = function create(properties) {
            return new AddTicketRsp(properties);
        };

        /**
         * Encodes the specified AddTicketRsp message. Does not implicitly {@link kritor.AddTicketRsp.verify|verify} messages.
         * @function encode
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {kritor.IAddTicketRsp} message AddTicketRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddTicketRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
            return writer;
        };

        /**
         * Encodes the specified AddTicketRsp message, length delimited. Does not implicitly {@link kritor.AddTicketRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {kritor.IAddTicketRsp} message AddTicketRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddTicketRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddTicketRsp message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.AddTicketRsp} AddTicketRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddTicketRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.AddTicketRsp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.code = reader.int32();
                        break;
                    }
                case 2: {
                        message.msg = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddTicketRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.AddTicketRsp} AddTicketRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddTicketRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddTicketRsp message.
         * @function verify
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddTicketRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            return null;
        };

        /**
         * Creates an AddTicketRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.AddTicketRsp} AddTicketRsp
         */
        AddTicketRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.AddTicketRsp)
                return object;
            let message = new $root.kritor.AddTicketRsp();
            if (object.code != null)
                message.code = object.code | 0;
            if (object.msg != null)
                message.msg = String(object.msg);
            return message;
        };

        /**
         * Creates a plain object from an AddTicketRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {kritor.AddTicketRsp} message AddTicketRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddTicketRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.code = 0;
                object.msg = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            return object;
        };

        /**
         * Converts this AddTicketRsp to JSON.
         * @function toJSON
         * @memberof kritor.AddTicketRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddTicketRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddTicketRsp
         * @function getTypeUrl
         * @memberof kritor.AddTicketRsp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddTicketRsp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.AddTicketRsp";
        };

        return AddTicketRsp;
    })();

    kritor.DeleteTicketReq = (function() {

        /**
         * Properties of a DeleteTicketReq.
         * @memberof kritor
         * @interface IDeleteTicketReq
         * @property {string|null} [account] DeleteTicketReq account
         * @property {string|null} [ticket] DeleteTicketReq ticket
         * @property {string|null} [deletedTicket] DeleteTicketReq deletedTicket
         */

        /**
         * Constructs a new DeleteTicketReq.
         * @memberof kritor
         * @classdesc Represents a DeleteTicketReq.
         * @implements IDeleteTicketReq
         * @constructor
         * @param {kritor.IDeleteTicketReq=} [properties] Properties to set
         */
        function DeleteTicketReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteTicketReq account.
         * @member {string} account
         * @memberof kritor.DeleteTicketReq
         * @instance
         */
        DeleteTicketReq.prototype.account = "";

        /**
         * DeleteTicketReq ticket.
         * @member {string} ticket
         * @memberof kritor.DeleteTicketReq
         * @instance
         */
        DeleteTicketReq.prototype.ticket = "";

        /**
         * DeleteTicketReq deletedTicket.
         * @member {string} deletedTicket
         * @memberof kritor.DeleteTicketReq
         * @instance
         */
        DeleteTicketReq.prototype.deletedTicket = "";

        /**
         * Creates a new DeleteTicketReq instance using the specified properties.
         * @function create
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {kritor.IDeleteTicketReq=} [properties] Properties to set
         * @returns {kritor.DeleteTicketReq} DeleteTicketReq instance
         */
        DeleteTicketReq.create = function create(properties) {
            return new DeleteTicketReq(properties);
        };

        /**
         * Encodes the specified DeleteTicketReq message. Does not implicitly {@link kritor.DeleteTicketReq.verify|verify} messages.
         * @function encode
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {kritor.IDeleteTicketReq} message DeleteTicketReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTicketReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticket);
            if (message.deletedTicket != null && Object.hasOwnProperty.call(message, "deletedTicket"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deletedTicket);
            return writer;
        };

        /**
         * Encodes the specified DeleteTicketReq message, length delimited. Does not implicitly {@link kritor.DeleteTicketReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {kritor.IDeleteTicketReq} message DeleteTicketReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTicketReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteTicketReq message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.DeleteTicketReq} DeleteTicketReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTicketReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.DeleteTicketReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.account = reader.string();
                        break;
                    }
                case 2: {
                        message.ticket = reader.string();
                        break;
                    }
                case 3: {
                        message.deletedTicket = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteTicketReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.DeleteTicketReq} DeleteTicketReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTicketReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteTicketReq message.
         * @function verify
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteTicketReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                if (!$util.isString(message.ticket))
                    return "ticket: string expected";
            if (message.deletedTicket != null && message.hasOwnProperty("deletedTicket"))
                if (!$util.isString(message.deletedTicket))
                    return "deletedTicket: string expected";
            return null;
        };

        /**
         * Creates a DeleteTicketReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.DeleteTicketReq} DeleteTicketReq
         */
        DeleteTicketReq.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.DeleteTicketReq)
                return object;
            let message = new $root.kritor.DeleteTicketReq();
            if (object.account != null)
                message.account = String(object.account);
            if (object.ticket != null)
                message.ticket = String(object.ticket);
            if (object.deletedTicket != null)
                message.deletedTicket = String(object.deletedTicket);
            return message;
        };

        /**
         * Creates a plain object from a DeleteTicketReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {kritor.DeleteTicketReq} message DeleteTicketReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteTicketReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.account = "";
                object.ticket = "";
                object.deletedTicket = "";
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = message.account;
            if (message.ticket != null && message.hasOwnProperty("ticket"))
                object.ticket = message.ticket;
            if (message.deletedTicket != null && message.hasOwnProperty("deletedTicket"))
                object.deletedTicket = message.deletedTicket;
            return object;
        };

        /**
         * Converts this DeleteTicketReq to JSON.
         * @function toJSON
         * @memberof kritor.DeleteTicketReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteTicketReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeleteTicketReq
         * @function getTypeUrl
         * @memberof kritor.DeleteTicketReq
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeleteTicketReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.DeleteTicketReq";
        };

        return DeleteTicketReq;
    })();

    kritor.DeleteTicketRsp = (function() {

        /**
         * Properties of a DeleteTicketRsp.
         * @memberof kritor
         * @interface IDeleteTicketRsp
         * @property {number|null} [code] DeleteTicketRsp code
         * @property {string|null} [msg] DeleteTicketRsp msg
         */

        /**
         * Constructs a new DeleteTicketRsp.
         * @memberof kritor
         * @classdesc Represents a DeleteTicketRsp.
         * @implements IDeleteTicketRsp
         * @constructor
         * @param {kritor.IDeleteTicketRsp=} [properties] Properties to set
         */
        function DeleteTicketRsp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteTicketRsp code.
         * @member {number} code
         * @memberof kritor.DeleteTicketRsp
         * @instance
         */
        DeleteTicketRsp.prototype.code = 0;

        /**
         * DeleteTicketRsp msg.
         * @member {string} msg
         * @memberof kritor.DeleteTicketRsp
         * @instance
         */
        DeleteTicketRsp.prototype.msg = "";

        /**
         * Creates a new DeleteTicketRsp instance using the specified properties.
         * @function create
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {kritor.IDeleteTicketRsp=} [properties] Properties to set
         * @returns {kritor.DeleteTicketRsp} DeleteTicketRsp instance
         */
        DeleteTicketRsp.create = function create(properties) {
            return new DeleteTicketRsp(properties);
        };

        /**
         * Encodes the specified DeleteTicketRsp message. Does not implicitly {@link kritor.DeleteTicketRsp.verify|verify} messages.
         * @function encode
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {kritor.IDeleteTicketRsp} message DeleteTicketRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTicketRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
            return writer;
        };

        /**
         * Encodes the specified DeleteTicketRsp message, length delimited. Does not implicitly {@link kritor.DeleteTicketRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {kritor.IDeleteTicketRsp} message DeleteTicketRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTicketRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteTicketRsp message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.DeleteTicketRsp} DeleteTicketRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTicketRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.DeleteTicketRsp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.code = reader.int32();
                        break;
                    }
                case 2: {
                        message.msg = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteTicketRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.DeleteTicketRsp} DeleteTicketRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTicketRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteTicketRsp message.
         * @function verify
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteTicketRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            return null;
        };

        /**
         * Creates a DeleteTicketRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.DeleteTicketRsp} DeleteTicketRsp
         */
        DeleteTicketRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.DeleteTicketRsp)
                return object;
            let message = new $root.kritor.DeleteTicketRsp();
            if (object.code != null)
                message.code = object.code | 0;
            if (object.msg != null)
                message.msg = String(object.msg);
            return message;
        };

        /**
         * Creates a plain object from a DeleteTicketRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {kritor.DeleteTicketRsp} message DeleteTicketRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteTicketRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.code = 0;
                object.msg = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            return object;
        };

        /**
         * Converts this DeleteTicketRsp to JSON.
         * @function toJSON
         * @memberof kritor.DeleteTicketRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteTicketRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeleteTicketRsp
         * @function getTypeUrl
         * @memberof kritor.DeleteTicketRsp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeleteTicketRsp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.DeleteTicketRsp";
        };

        return DeleteTicketRsp;
    })();

    kritor.CommonRequest = (function() {

        /**
         * Constructs a new CommonRequest service.
         * @memberof kritor
         * @classdesc Represents a CommonRequest
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function CommonRequest(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (CommonRequest.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CommonRequest;

        /**
         * Creates new CommonRequest service using the specified rpc implementation.
         * @function create
         * @memberof kritor.CommonRequest
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {CommonRequest} RPC service. Useful where requests and/or responses are streamed.
         */
        CommonRequest.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link kritor.CommonRequest#req}.
         * @memberof kritor.CommonRequest
         * @typedef ReqCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.Response} [response] Response
         */

        /**
         * Calls Req.
         * @function req
         * @memberof kritor.CommonRequest
         * @instance
         * @param {kritor.IRequest} request Request message or plain object
         * @param {kritor.CommonRequest.ReqCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CommonRequest.prototype.req = function req(request, callback) {
            return this.rpcCall(req, $root.kritor.Request, $root.kritor.Response, request, callback);
        }, "name", { value: "Req" });

        /**
         * Calls Req.
         * @function req
         * @memberof kritor.CommonRequest
         * @instance
         * @param {kritor.IRequest} request Request message or plain object
         * @returns {Promise<kritor.Response>} Promise
         * @variation 2
         */

        return CommonRequest;
    })();

    kritor.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof kritor
         * @interface IRequest
         * @property {string|null} [cmd] Request cmd
         * @property {Uint8Array|null} [buf] Request buf
         * @property {number|null} [seq] Request seq
         * @property {boolean|null} [noRsp] Request noRsp
         */

        /**
         * Constructs a new Request.
         * @memberof kritor
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {kritor.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request cmd.
         * @member {string} cmd
         * @memberof kritor.Request
         * @instance
         */
        Request.prototype.cmd = "";

        /**
         * Request buf.
         * @member {Uint8Array} buf
         * @memberof kritor.Request
         * @instance
         */
        Request.prototype.buf = $util.newBuffer([]);

        /**
         * Request seq.
         * @member {number} seq
         * @memberof kritor.Request
         * @instance
         */
        Request.prototype.seq = 0;

        /**
         * Request noRsp.
         * @member {boolean} noRsp
         * @memberof kritor.Request
         * @instance
         */
        Request.prototype.noRsp = false;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof kritor.Request
         * @static
         * @param {kritor.IRequest=} [properties] Properties to set
         * @returns {kritor.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link kritor.Request.verify|verify} messages.
         * @function encode
         * @memberof kritor.Request
         * @static
         * @param {kritor.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.buf);
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.seq);
            if (message.noRsp != null && Object.hasOwnProperty.call(message, "noRsp"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.noRsp);
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link kritor.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.Request
         * @static
         * @param {kritor.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.Request();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmd = reader.string();
                        break;
                    }
                case 2: {
                        message.buf = reader.bytes();
                        break;
                    }
                case 3: {
                        message.seq = reader.uint32();
                        break;
                    }
                case 4: {
                        message.noRsp = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof kritor.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isString(message.cmd))
                    return "cmd: string expected";
            if (message.buf != null && message.hasOwnProperty("buf"))
                if (!(message.buf && typeof message.buf.length === "number" || $util.isString(message.buf)))
                    return "buf: buffer expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.noRsp != null && message.hasOwnProperty("noRsp"))
                if (typeof message.noRsp !== "boolean")
                    return "noRsp: boolean expected";
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.Request)
                return object;
            let message = new $root.kritor.Request();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            if (object.buf != null)
                if (typeof object.buf === "string")
                    $util.base64.decode(object.buf, message.buf = $util.newBuffer($util.base64.length(object.buf)), 0);
                else if (object.buf.length >= 0)
                    message.buf = object.buf;
            if (object.seq != null)
                message.seq = object.seq >>> 0;
            if (object.noRsp != null)
                message.noRsp = Boolean(object.noRsp);
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.Request
         * @static
         * @param {kritor.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cmd = "";
                if (options.bytes === String)
                    object.buf = "";
                else {
                    object.buf = [];
                    if (options.bytes !== Array)
                        object.buf = $util.newBuffer(object.buf);
                }
                object.seq = 0;
                object.noRsp = false;
            }
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            if (message.buf != null && message.hasOwnProperty("buf"))
                object.buf = options.bytes === String ? $util.base64.encode(message.buf, 0, message.buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.buf) : message.buf;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.noRsp != null && message.hasOwnProperty("noRsp"))
                object.noRsp = message.noRsp;
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof kritor.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Request
         * @function getTypeUrl
         * @memberof kritor.Request
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.Request";
        };

        return Request;
    })();

    /**
     * ReqCode enum.
     * @name kritor.ReqCode
     * @enum {number}
     * @property {number} SUCCESS=0 SUCCESS value
     * @property {number} INVALID_ARGUMENT=1 INVALID_ARGUMENT value
     * @property {number} INTERNAL=2 INTERNAL value
     * @property {number} UNAUTHENTICATED=3 UNAUTHENTICATED value
     * @property {number} PERMISSION_DENIED=4 PERMISSION_DENIED value
     */
    kritor.ReqCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SUCCESS"] = 0;
        values[valuesById[1] = "INVALID_ARGUMENT"] = 1;
        values[valuesById[2] = "INTERNAL"] = 2;
        values[valuesById[3] = "UNAUTHENTICATED"] = 3;
        values[valuesById[4] = "PERMISSION_DENIED"] = 4;
        return values;
    })();

    kritor.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof kritor
         * @interface IResponse
         * @property {string|null} [cmd] Response cmd
         * @property {kritor.ReqCode|null} [code] Response code
         * @property {string|null} [msg] Response msg
         * @property {Uint8Array|null} [buf] Response buf
         * @property {number|null} [seq] Response seq
         */

        /**
         * Constructs a new Response.
         * @memberof kritor
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {kritor.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response cmd.
         * @member {string} cmd
         * @memberof kritor.Response
         * @instance
         */
        Response.prototype.cmd = "";

        /**
         * Response code.
         * @member {kritor.ReqCode} code
         * @memberof kritor.Response
         * @instance
         */
        Response.prototype.code = 0;

        /**
         * Response msg.
         * @member {string|null|undefined} msg
         * @memberof kritor.Response
         * @instance
         */
        Response.prototype.msg = null;

        /**
         * Response buf.
         * @member {Uint8Array} buf
         * @memberof kritor.Response
         * @instance
         */
        Response.prototype.buf = $util.newBuffer([]);

        /**
         * Response seq.
         * @member {number} seq
         * @memberof kritor.Response
         * @instance
         */
        Response.prototype.seq = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Response _msg.
         * @member {"msg"|undefined} _msg
         * @memberof kritor.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "_msg", {
            get: $util.oneOfGetter($oneOfFields = ["msg"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof kritor.Response
         * @static
         * @param {kritor.IResponse=} [properties] Properties to set
         * @returns {kritor.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link kritor.Response.verify|verify} messages.
         * @function encode
         * @memberof kritor.Response
         * @static
         * @param {kritor.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msg);
            if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.buf);
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.seq);
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link kritor.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof kritor.Response
         * @static
         * @param {kritor.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof kritor.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {kritor.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.Response();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmd = reader.string();
                        break;
                    }
                case 2: {
                        message.code = reader.int32();
                        break;
                    }
                case 3: {
                        message.msg = reader.string();
                        break;
                    }
                case 4: {
                        message.buf = reader.bytes();
                        break;
                    }
                case 5: {
                        message.seq = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof kritor.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {kritor.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof kritor.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isString(message.cmd))
                    return "cmd: string expected";
            if (message.code != null && message.hasOwnProperty("code"))
                switch (message.code) {
                default:
                    return "code: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.msg != null && message.hasOwnProperty("msg")) {
                properties._msg = 1;
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            }
            if (message.buf != null && message.hasOwnProperty("buf"))
                if (!(message.buf && typeof message.buf.length === "number" || $util.isString(message.buf)))
                    return "buf: buffer expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof kritor.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {kritor.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.kritor.Response)
                return object;
            let message = new $root.kritor.Response();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            switch (object.code) {
            default:
                if (typeof object.code === "number") {
                    message.code = object.code;
                    break;
                }
                break;
            case "SUCCESS":
            case 0:
                message.code = 0;
                break;
            case "INVALID_ARGUMENT":
            case 1:
                message.code = 1;
                break;
            case "INTERNAL":
            case 2:
                message.code = 2;
                break;
            case "UNAUTHENTICATED":
            case 3:
                message.code = 3;
                break;
            case "PERMISSION_DENIED":
            case 4:
                message.code = 4;
                break;
            }
            if (object.msg != null)
                message.msg = String(object.msg);
            if (object.buf != null)
                if (typeof object.buf === "string")
                    $util.base64.decode(object.buf, message.buf = $util.newBuffer($util.base64.length(object.buf)), 0);
                else if (object.buf.length >= 0)
                    message.buf = object.buf;
            if (object.seq != null)
                message.seq = object.seq >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof kritor.Response
         * @static
         * @param {kritor.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cmd = "";
                object.code = options.enums === String ? "SUCCESS" : 0;
                if (options.bytes === String)
                    object.buf = "";
                else {
                    object.buf = [];
                    if (options.bytes !== Array)
                        object.buf = $util.newBuffer(object.buf);
                }
                object.seq = 0;
            }
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.enums === String ? $root.kritor.ReqCode[message.code] === undefined ? message.code : $root.kritor.ReqCode[message.code] : message.code;
            if (message.msg != null && message.hasOwnProperty("msg")) {
                object.msg = message.msg;
                if (options.oneofs)
                    object._msg = "msg";
            }
            if (message.buf != null && message.hasOwnProperty("buf"))
                object.buf = options.bytes === String ? $util.base64.encode(message.buf, 0, message.buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.buf) : message.buf;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof kritor.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Response
         * @function getTypeUrl
         * @memberof kritor.Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/kritor.Response";
        };

        return Response;
    })();

    kritor.ReverseService = (function() {

        /**
         * Constructs a new ReverseService service.
         * @memberof kritor
         * @classdesc Represents a ReverseService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ReverseService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ReverseService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ReverseService;

        /**
         * Creates new ReverseService service using the specified rpc implementation.
         * @function create
         * @memberof kritor.ReverseService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ReverseService} RPC service. Useful where requests and/or responses are streamed.
         */
        ReverseService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link kritor.ReverseService#reverseStream}.
         * @memberof kritor.ReverseService
         * @typedef ReverseStreamCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {kritor.Request} [response] Request
         */

        /**
         * Calls ReverseStream.
         * @function reverseStream
         * @memberof kritor.ReverseService
         * @instance
         * @param {kritor.IResponse} request Response message or plain object
         * @param {kritor.ReverseService.ReverseStreamCallback} callback Node-style callback called with the error, if any, and Request
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ReverseService.prototype.reverseStream = function reverseStream(request, callback) {
            return this.rpcCall(reverseStream, $root.kritor.Response, $root.kritor.Request, request, callback);
        }, "name", { value: "ReverseStream" });

        /**
         * Calls ReverseStream.
         * @function reverseStream
         * @memberof kritor.ReverseService
         * @instance
         * @param {kritor.IResponse} request Response message or plain object
         * @returns {Promise<kritor.Request>} Promise
         * @variation 2
         */

        return ReverseService;
    })();

    kritor.contact = (function() {

        /**
         * Namespace contact.
         * @memberof kritor
         * @namespace
         */
        const contact = {};

        contact.ProfileCard = (function() {

            /**
             * Properties of a ProfileCard.
             * @memberof kritor.contact
             * @interface IProfileCard
             * @property {string|null} [uid] ProfileCard uid
             * @property {number|Long|null} [uin] ProfileCard uin
             * @property {string|null} [name] ProfileCard name
             * @property {string|null} [remark] ProfileCard remark
             * @property {number|null} [level] ProfileCard level
             * @property {number|Long|null} [birthday] ProfileCard birthday
             * @property {number|null} [loginDay] ProfileCard loginDay
             * @property {number|null} [voteCnt] ProfileCard voteCnt
             * @property {string|null} [qid] ProfileCard qid
             * @property {boolean|null} [isSchoolVerified] ProfileCard isSchoolVerified
             */

            /**
             * Constructs a new ProfileCard.
             * @memberof kritor.contact
             * @classdesc Represents a ProfileCard.
             * @implements IProfileCard
             * @constructor
             * @param {kritor.contact.IProfileCard=} [properties] Properties to set
             */
            function ProfileCard(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProfileCard uid.
             * @member {string} uid
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.uid = "";

            /**
             * ProfileCard uin.
             * @member {number|Long} uin
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProfileCard name.
             * @member {string} name
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.name = "";

            /**
             * ProfileCard remark.
             * @member {string} remark
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.remark = "";

            /**
             * ProfileCard level.
             * @member {number} level
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.level = 0;

            /**
             * ProfileCard birthday.
             * @member {number|Long} birthday
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.birthday = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProfileCard loginDay.
             * @member {number} loginDay
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.loginDay = 0;

            /**
             * ProfileCard voteCnt.
             * @member {number} voteCnt
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.voteCnt = 0;

            /**
             * ProfileCard qid.
             * @member {string|null|undefined} qid
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.qid = null;

            /**
             * ProfileCard isSchoolVerified.
             * @member {boolean|null|undefined} isSchoolVerified
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            ProfileCard.prototype.isSchoolVerified = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ProfileCard _qid.
             * @member {"qid"|undefined} _qid
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_qid", {
                get: $util.oneOfGetter($oneOfFields = ["qid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _isSchoolVerified.
             * @member {"isSchoolVerified"|undefined} _isSchoolVerified
             * @memberof kritor.contact.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_isSchoolVerified", {
                get: $util.oneOfGetter($oneOfFields = ["isSchoolVerified"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ProfileCard instance using the specified properties.
             * @function create
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {kritor.contact.IProfileCard=} [properties] Properties to set
             * @returns {kritor.contact.ProfileCard} ProfileCard instance
             */
            ProfileCard.create = function create(properties) {
                return new ProfileCard(properties);
            };

            /**
             * Encodes the specified ProfileCard message. Does not implicitly {@link kritor.contact.ProfileCard.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {kritor.contact.IProfileCard} message ProfileCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.remark);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.level);
                if (message.birthday != null && Object.hasOwnProperty.call(message, "birthday"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.birthday);
                if (message.loginDay != null && Object.hasOwnProperty.call(message, "loginDay"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.loginDay);
                if (message.voteCnt != null && Object.hasOwnProperty.call(message, "voteCnt"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.voteCnt);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 50, wireType 2 =*/402).string(message.qid);
                if (message.isSchoolVerified != null && Object.hasOwnProperty.call(message, "isSchoolVerified"))
                    writer.uint32(/* id 51, wireType 0 =*/408).bool(message.isSchoolVerified);
                return writer;
            };

            /**
             * Encodes the specified ProfileCard message, length delimited. Does not implicitly {@link kritor.contact.ProfileCard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {kritor.contact.IProfileCard} message ProfileCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCard.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProfileCard message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.ProfileCard} ProfileCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.ProfileCard();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.remark = reader.string();
                            break;
                        }
                    case 5: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.birthday = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.loginDay = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.voteCnt = reader.uint32();
                            break;
                        }
                    case 50: {
                            message.qid = reader.string();
                            break;
                        }
                    case 51: {
                            message.isSchoolVerified = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProfileCard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.ProfileCard} ProfileCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCard.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProfileCard message.
             * @function verify
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProfileCard.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.birthday != null && message.hasOwnProperty("birthday"))
                    if (!$util.isInteger(message.birthday) && !(message.birthday && $util.isInteger(message.birthday.low) && $util.isInteger(message.birthday.high)))
                        return "birthday: integer|Long expected";
                if (message.loginDay != null && message.hasOwnProperty("loginDay"))
                    if (!$util.isInteger(message.loginDay))
                        return "loginDay: integer expected";
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    if (!$util.isInteger(message.voteCnt))
                        return "voteCnt: integer expected";
                if (message.qid != null && message.hasOwnProperty("qid")) {
                    properties._qid = 1;
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                }
                if (message.isSchoolVerified != null && message.hasOwnProperty("isSchoolVerified")) {
                    properties._isSchoolVerified = 1;
                    if (typeof message.isSchoolVerified !== "boolean")
                        return "isSchoolVerified: boolean expected";
                }
                return null;
            };

            /**
             * Creates a ProfileCard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.ProfileCard} ProfileCard
             */
            ProfileCard.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.ProfileCard)
                    return object;
                let message = new $root.kritor.contact.ProfileCard();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.remark != null)
                    message.remark = String(object.remark);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.birthday != null)
                    if ($util.Long)
                        (message.birthday = $util.Long.fromValue(object.birthday)).unsigned = true;
                    else if (typeof object.birthday === "string")
                        message.birthday = parseInt(object.birthday, 10);
                    else if (typeof object.birthday === "number")
                        message.birthday = object.birthday;
                    else if (typeof object.birthday === "object")
                        message.birthday = new $util.LongBits(object.birthday.low >>> 0, object.birthday.high >>> 0).toNumber(true);
                if (object.loginDay != null)
                    message.loginDay = object.loginDay >>> 0;
                if (object.voteCnt != null)
                    message.voteCnt = object.voteCnt >>> 0;
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.isSchoolVerified != null)
                    message.isSchoolVerified = Boolean(object.isSchoolVerified);
                return message;
            };

            /**
             * Creates a plain object from a ProfileCard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {kritor.contact.ProfileCard} message ProfileCard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProfileCard.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.remark = "";
                    object.level = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.birthday = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.birthday = options.longs === String ? "0" : 0;
                    object.loginDay = 0;
                    object.voteCnt = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.birthday != null && message.hasOwnProperty("birthday"))
                    if (typeof message.birthday === "number")
                        object.birthday = options.longs === String ? String(message.birthday) : message.birthday;
                    else
                        object.birthday = options.longs === String ? $util.Long.prototype.toString.call(message.birthday) : options.longs === Number ? new $util.LongBits(message.birthday.low >>> 0, message.birthday.high >>> 0).toNumber(true) : message.birthday;
                if (message.loginDay != null && message.hasOwnProperty("loginDay"))
                    object.loginDay = message.loginDay;
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    object.voteCnt = message.voteCnt;
                if (message.qid != null && message.hasOwnProperty("qid")) {
                    object.qid = message.qid;
                    if (options.oneofs)
                        object._qid = "qid";
                }
                if (message.isSchoolVerified != null && message.hasOwnProperty("isSchoolVerified")) {
                    object.isSchoolVerified = message.isSchoolVerified;
                    if (options.oneofs)
                        object._isSchoolVerified = "isSchoolVerified";
                }
                return object;
            };

            /**
             * Converts this ProfileCard to JSON.
             * @function toJSON
             * @memberof kritor.contact.ProfileCard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProfileCard.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProfileCard
             * @function getTypeUrl
             * @memberof kritor.contact.ProfileCard
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProfileCard.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.ProfileCard";
            };

            return ProfileCard;
        })();

        contact.StrangerInfo = (function() {

            /**
             * Properties of a StrangerInfo.
             * @memberof kritor.contact
             * @interface IStrangerInfo
             * @property {string|null} [uid] StrangerInfo uid
             * @property {number|Long|null} [uin] StrangerInfo uin
             * @property {string|null} [name] StrangerInfo name
             * @property {number|null} [level] StrangerInfo level
             * @property {number|null} [loginDay] StrangerInfo loginDay
             * @property {number|null} [voteCnt] StrangerInfo voteCnt
             * @property {string|null} [qid] StrangerInfo qid
             * @property {boolean|null} [isSchoolVerified] StrangerInfo isSchoolVerified
             * @property {Uint8Array|null} [ext] StrangerInfo ext
             */

            /**
             * Constructs a new StrangerInfo.
             * @memberof kritor.contact
             * @classdesc Represents a StrangerInfo.
             * @implements IStrangerInfo
             * @constructor
             * @param {kritor.contact.IStrangerInfo=} [properties] Properties to set
             */
            function StrangerInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StrangerInfo uid.
             * @member {string} uid
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.uid = "";

            /**
             * StrangerInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * StrangerInfo name.
             * @member {string} name
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.name = "";

            /**
             * StrangerInfo level.
             * @member {number} level
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.level = 0;

            /**
             * StrangerInfo loginDay.
             * @member {number} loginDay
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.loginDay = 0;

            /**
             * StrangerInfo voteCnt.
             * @member {number} voteCnt
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.voteCnt = 0;

            /**
             * StrangerInfo qid.
             * @member {string|null|undefined} qid
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.qid = null;

            /**
             * StrangerInfo isSchoolVerified.
             * @member {boolean|null|undefined} isSchoolVerified
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.isSchoolVerified = null;

            /**
             * StrangerInfo ext.
             * @member {Uint8Array|null|undefined} ext
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            StrangerInfo.prototype.ext = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * StrangerInfo _qid.
             * @member {"qid"|undefined} _qid
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            Object.defineProperty(StrangerInfo.prototype, "_qid", {
                get: $util.oneOfGetter($oneOfFields = ["qid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * StrangerInfo _isSchoolVerified.
             * @member {"isSchoolVerified"|undefined} _isSchoolVerified
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            Object.defineProperty(StrangerInfo.prototype, "_isSchoolVerified", {
                get: $util.oneOfGetter($oneOfFields = ["isSchoolVerified"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * StrangerInfo _ext.
             * @member {"ext"|undefined} _ext
             * @memberof kritor.contact.StrangerInfo
             * @instance
             */
            Object.defineProperty(StrangerInfo.prototype, "_ext", {
                get: $util.oneOfGetter($oneOfFields = ["ext"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new StrangerInfo instance using the specified properties.
             * @function create
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {kritor.contact.IStrangerInfo=} [properties] Properties to set
             * @returns {kritor.contact.StrangerInfo} StrangerInfo instance
             */
            StrangerInfo.create = function create(properties) {
                return new StrangerInfo(properties);
            };

            /**
             * Encodes the specified StrangerInfo message. Does not implicitly {@link kritor.contact.StrangerInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {kritor.contact.IStrangerInfo} message StrangerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StrangerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.level);
                if (message.loginDay != null && Object.hasOwnProperty.call(message, "loginDay"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.loginDay);
                if (message.voteCnt != null && Object.hasOwnProperty.call(message, "voteCnt"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.voteCnt);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 50, wireType 2 =*/402).string(message.qid);
                if (message.isSchoolVerified != null && Object.hasOwnProperty.call(message, "isSchoolVerified"))
                    writer.uint32(/* id 51, wireType 0 =*/408).bool(message.isSchoolVerified);
                if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                    writer.uint32(/* id 99, wireType 2 =*/794).bytes(message.ext);
                return writer;
            };

            /**
             * Encodes the specified StrangerInfo message, length delimited. Does not implicitly {@link kritor.contact.StrangerInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {kritor.contact.IStrangerInfo} message StrangerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StrangerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StrangerInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.StrangerInfo} StrangerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StrangerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.StrangerInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.loginDay = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.voteCnt = reader.uint32();
                            break;
                        }
                    case 50: {
                            message.qid = reader.string();
                            break;
                        }
                    case 51: {
                            message.isSchoolVerified = reader.bool();
                            break;
                        }
                    case 99: {
                            message.ext = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StrangerInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.StrangerInfo} StrangerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StrangerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StrangerInfo message.
             * @function verify
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StrangerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.loginDay != null && message.hasOwnProperty("loginDay"))
                    if (!$util.isInteger(message.loginDay))
                        return "loginDay: integer expected";
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    if (!$util.isInteger(message.voteCnt))
                        return "voteCnt: integer expected";
                if (message.qid != null && message.hasOwnProperty("qid")) {
                    properties._qid = 1;
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                }
                if (message.isSchoolVerified != null && message.hasOwnProperty("isSchoolVerified")) {
                    properties._isSchoolVerified = 1;
                    if (typeof message.isSchoolVerified !== "boolean")
                        return "isSchoolVerified: boolean expected";
                }
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    properties._ext = 1;
                    if (!(message.ext && typeof message.ext.length === "number" || $util.isString(message.ext)))
                        return "ext: buffer expected";
                }
                return null;
            };

            /**
             * Creates a StrangerInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.StrangerInfo} StrangerInfo
             */
            StrangerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.StrangerInfo)
                    return object;
                let message = new $root.kritor.contact.StrangerInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.loginDay != null)
                    message.loginDay = object.loginDay >>> 0;
                if (object.voteCnt != null)
                    message.voteCnt = object.voteCnt >>> 0;
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.isSchoolVerified != null)
                    message.isSchoolVerified = Boolean(object.isSchoolVerified);
                if (object.ext != null)
                    if (typeof object.ext === "string")
                        $util.base64.decode(object.ext, message.ext = $util.newBuffer($util.base64.length(object.ext)), 0);
                    else if (object.ext.length >= 0)
                        message.ext = object.ext;
                return message;
            };

            /**
             * Creates a plain object from a StrangerInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {kritor.contact.StrangerInfo} message StrangerInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StrangerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.level = 0;
                    object.loginDay = 0;
                    object.voteCnt = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.loginDay != null && message.hasOwnProperty("loginDay"))
                    object.loginDay = message.loginDay;
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    object.voteCnt = message.voteCnt;
                if (message.qid != null && message.hasOwnProperty("qid")) {
                    object.qid = message.qid;
                    if (options.oneofs)
                        object._qid = "qid";
                }
                if (message.isSchoolVerified != null && message.hasOwnProperty("isSchoolVerified")) {
                    object.isSchoolVerified = message.isSchoolVerified;
                    if (options.oneofs)
                        object._isSchoolVerified = "isSchoolVerified";
                }
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    object.ext = options.bytes === String ? $util.base64.encode(message.ext, 0, message.ext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ext) : message.ext;
                    if (options.oneofs)
                        object._ext = "ext";
                }
                return object;
            };

            /**
             * Converts this StrangerInfo to JSON.
             * @function toJSON
             * @memberof kritor.contact.StrangerInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StrangerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StrangerInfo
             * @function getTypeUrl
             * @memberof kritor.contact.StrangerInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StrangerInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.StrangerInfo";
            };

            return StrangerInfo;
        })();

        contact.StrangerExt = (function() {

            /**
             * Properties of a StrangerExt.
             * @memberof kritor.contact
             * @interface IStrangerExt
             * @property {boolean|null} [bigVip] StrangerExt bigVip
             * @property {boolean|null} [hollywoodVip] StrangerExt hollywoodVip
             * @property {boolean|null} [qqVip] StrangerExt qqVip
             * @property {boolean|null} [superVip] StrangerExt superVip
             * @property {boolean|null} [voted] StrangerExt voted
             */

            /**
             * Constructs a new StrangerExt.
             * @memberof kritor.contact
             * @classdesc Represents a StrangerExt.
             * @implements IStrangerExt
             * @constructor
             * @param {kritor.contact.IStrangerExt=} [properties] Properties to set
             */
            function StrangerExt(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StrangerExt bigVip.
             * @member {boolean|null|undefined} bigVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            StrangerExt.prototype.bigVip = null;

            /**
             * StrangerExt hollywoodVip.
             * @member {boolean|null|undefined} hollywoodVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            StrangerExt.prototype.hollywoodVip = null;

            /**
             * StrangerExt qqVip.
             * @member {boolean|null|undefined} qqVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            StrangerExt.prototype.qqVip = null;

            /**
             * StrangerExt superVip.
             * @member {boolean|null|undefined} superVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            StrangerExt.prototype.superVip = null;

            /**
             * StrangerExt voted.
             * @member {boolean|null|undefined} voted
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            StrangerExt.prototype.voted = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * StrangerExt _bigVip.
             * @member {"bigVip"|undefined} _bigVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            Object.defineProperty(StrangerExt.prototype, "_bigVip", {
                get: $util.oneOfGetter($oneOfFields = ["bigVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * StrangerExt _hollywoodVip.
             * @member {"hollywoodVip"|undefined} _hollywoodVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            Object.defineProperty(StrangerExt.prototype, "_hollywoodVip", {
                get: $util.oneOfGetter($oneOfFields = ["hollywoodVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * StrangerExt _qqVip.
             * @member {"qqVip"|undefined} _qqVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            Object.defineProperty(StrangerExt.prototype, "_qqVip", {
                get: $util.oneOfGetter($oneOfFields = ["qqVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * StrangerExt _superVip.
             * @member {"superVip"|undefined} _superVip
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            Object.defineProperty(StrangerExt.prototype, "_superVip", {
                get: $util.oneOfGetter($oneOfFields = ["superVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * StrangerExt _voted.
             * @member {"voted"|undefined} _voted
             * @memberof kritor.contact.StrangerExt
             * @instance
             */
            Object.defineProperty(StrangerExt.prototype, "_voted", {
                get: $util.oneOfGetter($oneOfFields = ["voted"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new StrangerExt instance using the specified properties.
             * @function create
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {kritor.contact.IStrangerExt=} [properties] Properties to set
             * @returns {kritor.contact.StrangerExt} StrangerExt instance
             */
            StrangerExt.create = function create(properties) {
                return new StrangerExt(properties);
            };

            /**
             * Encodes the specified StrangerExt message. Does not implicitly {@link kritor.contact.StrangerExt.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {kritor.contact.IStrangerExt} message StrangerExt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StrangerExt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bigVip != null && Object.hasOwnProperty.call(message, "bigVip"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bigVip);
                if (message.hollywoodVip != null && Object.hasOwnProperty.call(message, "hollywoodVip"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hollywoodVip);
                if (message.qqVip != null && Object.hasOwnProperty.call(message, "qqVip"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.qqVip);
                if (message.superVip != null && Object.hasOwnProperty.call(message, "superVip"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.superVip);
                if (message.voted != null && Object.hasOwnProperty.call(message, "voted"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.voted);
                return writer;
            };

            /**
             * Encodes the specified StrangerExt message, length delimited. Does not implicitly {@link kritor.contact.StrangerExt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {kritor.contact.IStrangerExt} message StrangerExt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StrangerExt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StrangerExt message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.StrangerExt} StrangerExt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StrangerExt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.StrangerExt();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bigVip = reader.bool();
                            break;
                        }
                    case 2: {
                            message.hollywoodVip = reader.bool();
                            break;
                        }
                    case 3: {
                            message.qqVip = reader.bool();
                            break;
                        }
                    case 4: {
                            message.superVip = reader.bool();
                            break;
                        }
                    case 5: {
                            message.voted = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StrangerExt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.StrangerExt} StrangerExt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StrangerExt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StrangerExt message.
             * @function verify
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StrangerExt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.bigVip != null && message.hasOwnProperty("bigVip")) {
                    properties._bigVip = 1;
                    if (typeof message.bigVip !== "boolean")
                        return "bigVip: boolean expected";
                }
                if (message.hollywoodVip != null && message.hasOwnProperty("hollywoodVip")) {
                    properties._hollywoodVip = 1;
                    if (typeof message.hollywoodVip !== "boolean")
                        return "hollywoodVip: boolean expected";
                }
                if (message.qqVip != null && message.hasOwnProperty("qqVip")) {
                    properties._qqVip = 1;
                    if (typeof message.qqVip !== "boolean")
                        return "qqVip: boolean expected";
                }
                if (message.superVip != null && message.hasOwnProperty("superVip")) {
                    properties._superVip = 1;
                    if (typeof message.superVip !== "boolean")
                        return "superVip: boolean expected";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    properties._voted = 1;
                    if (typeof message.voted !== "boolean")
                        return "voted: boolean expected";
                }
                return null;
            };

            /**
             * Creates a StrangerExt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.StrangerExt} StrangerExt
             */
            StrangerExt.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.StrangerExt)
                    return object;
                let message = new $root.kritor.contact.StrangerExt();
                if (object.bigVip != null)
                    message.bigVip = Boolean(object.bigVip);
                if (object.hollywoodVip != null)
                    message.hollywoodVip = Boolean(object.hollywoodVip);
                if (object.qqVip != null)
                    message.qqVip = Boolean(object.qqVip);
                if (object.superVip != null)
                    message.superVip = Boolean(object.superVip);
                if (object.voted != null)
                    message.voted = Boolean(object.voted);
                return message;
            };

            /**
             * Creates a plain object from a StrangerExt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {kritor.contact.StrangerExt} message StrangerExt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StrangerExt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.bigVip != null && message.hasOwnProperty("bigVip")) {
                    object.bigVip = message.bigVip;
                    if (options.oneofs)
                        object._bigVip = "bigVip";
                }
                if (message.hollywoodVip != null && message.hasOwnProperty("hollywoodVip")) {
                    object.hollywoodVip = message.hollywoodVip;
                    if (options.oneofs)
                        object._hollywoodVip = "hollywoodVip";
                }
                if (message.qqVip != null && message.hasOwnProperty("qqVip")) {
                    object.qqVip = message.qqVip;
                    if (options.oneofs)
                        object._qqVip = "qqVip";
                }
                if (message.superVip != null && message.hasOwnProperty("superVip")) {
                    object.superVip = message.superVip;
                    if (options.oneofs)
                        object._superVip = "superVip";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    object.voted = message.voted;
                    if (options.oneofs)
                        object._voted = "voted";
                }
                return object;
            };

            /**
             * Converts this StrangerExt to JSON.
             * @function toJSON
             * @memberof kritor.contact.StrangerExt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StrangerExt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StrangerExt
             * @function getTypeUrl
             * @memberof kritor.contact.StrangerExt
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StrangerExt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.StrangerExt";
            };

            return StrangerExt;
        })();

        contact.ContactService = (function() {

            /**
             * Constructs a new ContactService service.
             * @memberof kritor.contact
             * @classdesc Represents a ContactService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ContactService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ContactService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ContactService;

            /**
             * Creates new ContactService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.contact.ContactService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ContactService} RPC service. Useful where requests and/or responses are streamed.
             */
            ContactService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.contact.ContactService#getProfileCard}.
             * @memberof kritor.contact.ContactService
             * @typedef GetProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.ProfileCard} [response] ProfileCard
             */

            /**
             * Calls GetProfileCard.
             * @function getProfileCard
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IProfileCardRequest} request ProfileCardRequest message or plain object
             * @param {kritor.contact.ContactService.GetProfileCardCallback} callback Node-style callback called with the error, if any, and ProfileCard
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.getProfileCard = function getProfileCard(request, callback) {
                return this.rpcCall(getProfileCard, $root.kritor.contact.ProfileCardRequest, $root.kritor.contact.ProfileCard, request, callback);
            }, "name", { value: "GetProfileCard" });

            /**
             * Calls GetProfileCard.
             * @function getProfileCard
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IProfileCardRequest} request ProfileCardRequest message or plain object
             * @returns {Promise<kritor.contact.ProfileCard>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.contact.ContactService#getStrangerInfo}.
             * @memberof kritor.contact.ContactService
             * @typedef GetStrangerInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.StrangerInfo} [response] StrangerInfo
             */

            /**
             * Calls GetStrangerInfo.
             * @function getStrangerInfo
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IStrangerInfoRequest} request StrangerInfoRequest message or plain object
             * @param {kritor.contact.ContactService.GetStrangerInfoCallback} callback Node-style callback called with the error, if any, and StrangerInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.getStrangerInfo = function getStrangerInfo(request, callback) {
                return this.rpcCall(getStrangerInfo, $root.kritor.contact.StrangerInfoRequest, $root.kritor.contact.StrangerInfo, request, callback);
            }, "name", { value: "GetStrangerInfo" });

            /**
             * Calls GetStrangerInfo.
             * @function getStrangerInfo
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IStrangerInfoRequest} request StrangerInfoRequest message or plain object
             * @returns {Promise<kritor.contact.StrangerInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.contact.ContactService#getUid}.
             * @memberof kritor.contact.ContactService
             * @typedef GetUidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.GetUidResponse} [response] GetUidResponse
             */

            /**
             * Calls GetUid.
             * @function getUid
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IGetUidRequest} request GetUidRequest message or plain object
             * @param {kritor.contact.ContactService.GetUidCallback} callback Node-style callback called with the error, if any, and GetUidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.getUid = function getUid(request, callback) {
                return this.rpcCall(getUid, $root.kritor.contact.GetUidRequest, $root.kritor.contact.GetUidResponse, request, callback);
            }, "name", { value: "GetUid" });

            /**
             * Calls GetUid.
             * @function getUid
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IGetUidRequest} request GetUidRequest message or plain object
             * @returns {Promise<kritor.contact.GetUidResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.contact.ContactService#getUinByUid}.
             * @memberof kritor.contact.ContactService
             * @typedef GetUinByUidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.GetUinByUidResponse} [response] GetUinByUidResponse
             */

            /**
             * Calls GetUinByUid.
             * @function getUinByUid
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IGetUinByUidRequest} request GetUinByUidRequest message or plain object
             * @param {kritor.contact.ContactService.GetUinByUidCallback} callback Node-style callback called with the error, if any, and GetUinByUidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.getUinByUid = function getUinByUid(request, callback) {
                return this.rpcCall(getUinByUid, $root.kritor.contact.GetUinByUidRequest, $root.kritor.contact.GetUinByUidResponse, request, callback);
            }, "name", { value: "GetUinByUid" });

            /**
             * Calls GetUinByUid.
             * @function getUinByUid
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IGetUinByUidRequest} request GetUinByUidRequest message or plain object
             * @returns {Promise<kritor.contact.GetUinByUidResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.contact.ContactService#setProfileCard}.
             * @memberof kritor.contact.ContactService
             * @typedef SetProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.SetProfileCardResponse} [response] SetProfileCardResponse
             */

            /**
             * Calls SetProfileCard.
             * @function setProfileCard
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.ISetProfileCardRequest} request SetProfileCardRequest message or plain object
             * @param {kritor.contact.ContactService.SetProfileCardCallback} callback Node-style callback called with the error, if any, and SetProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.setProfileCard = function setProfileCard(request, callback) {
                return this.rpcCall(setProfileCard, $root.kritor.contact.SetProfileCardRequest, $root.kritor.contact.SetProfileCardResponse, request, callback);
            }, "name", { value: "SetProfileCard" });

            /**
             * Calls SetProfileCard.
             * @function setProfileCard
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.ISetProfileCardRequest} request SetProfileCardRequest message or plain object
             * @returns {Promise<kritor.contact.SetProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.contact.ContactService#isBlackListUser}.
             * @memberof kritor.contact.ContactService
             * @typedef IsBlackListUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.IsBlackListUserResponse} [response] IsBlackListUserResponse
             */

            /**
             * Calls IsBlackListUser.
             * @function isBlackListUser
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IIsBlackListUserRequest} request IsBlackListUserRequest message or plain object
             * @param {kritor.contact.ContactService.IsBlackListUserCallback} callback Node-style callback called with the error, if any, and IsBlackListUserResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.isBlackListUser = function isBlackListUser(request, callback) {
                return this.rpcCall(isBlackListUser, $root.kritor.contact.IsBlackListUserRequest, $root.kritor.contact.IsBlackListUserResponse, request, callback);
            }, "name", { value: "IsBlackListUser" });

            /**
             * Calls IsBlackListUser.
             * @function isBlackListUser
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IIsBlackListUserRequest} request IsBlackListUserRequest message or plain object
             * @returns {Promise<kritor.contact.IsBlackListUserResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.contact.ContactService#voteUser}.
             * @memberof kritor.contact.ContactService
             * @typedef VoteUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.contact.VoteUserResponse} [response] VoteUserResponse
             */

            /**
             * Calls VoteUser.
             * @function voteUser
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IVoteUserRequest} request VoteUserRequest message or plain object
             * @param {kritor.contact.ContactService.VoteUserCallback} callback Node-style callback called with the error, if any, and VoteUserResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ContactService.prototype.voteUser = function voteUser(request, callback) {
                return this.rpcCall(voteUser, $root.kritor.contact.VoteUserRequest, $root.kritor.contact.VoteUserResponse, request, callback);
            }, "name", { value: "VoteUser" });

            /**
             * Calls VoteUser.
             * @function voteUser
             * @memberof kritor.contact.ContactService
             * @instance
             * @param {kritor.contact.IVoteUserRequest} request VoteUserRequest message or plain object
             * @returns {Promise<kritor.contact.VoteUserResponse>} Promise
             * @variation 2
             */

            return ContactService;
        })();

        contact.ProfileCardRequest = (function() {

            /**
             * Properties of a ProfileCardRequest.
             * @memberof kritor.contact
             * @interface IProfileCardRequest
             * @property {number|Long|null} [accountUin] ProfileCardRequest accountUin
             * @property {string|null} [accountUid] ProfileCardRequest accountUid
             */

            /**
             * Constructs a new ProfileCardRequest.
             * @memberof kritor.contact
             * @classdesc Represents a ProfileCardRequest.
             * @implements IProfileCardRequest
             * @constructor
             * @param {kritor.contact.IProfileCardRequest=} [properties] Properties to set
             */
            function ProfileCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProfileCardRequest accountUin.
             * @member {number|Long|null|undefined} accountUin
             * @memberof kritor.contact.ProfileCardRequest
             * @instance
             */
            ProfileCardRequest.prototype.accountUin = null;

            /**
             * ProfileCardRequest accountUid.
             * @member {string|null|undefined} accountUid
             * @memberof kritor.contact.ProfileCardRequest
             * @instance
             */
            ProfileCardRequest.prototype.accountUid = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ProfileCardRequest account.
             * @member {"accountUin"|"accountUid"|undefined} account
             * @memberof kritor.contact.ProfileCardRequest
             * @instance
             */
            Object.defineProperty(ProfileCardRequest.prototype, "account", {
                get: $util.oneOfGetter($oneOfFields = ["accountUin", "accountUid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {kritor.contact.IProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.contact.ProfileCardRequest} ProfileCardRequest instance
             */
            ProfileCardRequest.create = function create(properties) {
                return new ProfileCardRequest(properties);
            };

            /**
             * Encodes the specified ProfileCardRequest message. Does not implicitly {@link kritor.contact.ProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {kritor.contact.IProfileCardRequest} message ProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountUin != null && Object.hasOwnProperty.call(message, "accountUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accountUin);
                if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountUid);
                return writer;
            };

            /**
             * Encodes the specified ProfileCardRequest message, length delimited. Does not implicitly {@link kritor.contact.ProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {kritor.contact.IProfileCardRequest} message ProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.ProfileCardRequest} ProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.ProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountUin = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.accountUid = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.ProfileCardRequest} ProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProfileCardRequest message.
             * @function verify
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    properties.account = 1;
                    if (!$util.isInteger(message.accountUin) && !(message.accountUin && $util.isInteger(message.accountUin.low) && $util.isInteger(message.accountUin.high)))
                        return "accountUin: integer|Long expected";
                }
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    if (properties.account === 1)
                        return "account: multiple values";
                    properties.account = 1;
                    if (!$util.isString(message.accountUid))
                        return "accountUid: string expected";
                }
                return null;
            };

            /**
             * Creates a ProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.ProfileCardRequest} ProfileCardRequest
             */
            ProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.ProfileCardRequest)
                    return object;
                let message = new $root.kritor.contact.ProfileCardRequest();
                if (object.accountUin != null)
                    if ($util.Long)
                        (message.accountUin = $util.Long.fromValue(object.accountUin)).unsigned = true;
                    else if (typeof object.accountUin === "string")
                        message.accountUin = parseInt(object.accountUin, 10);
                    else if (typeof object.accountUin === "number")
                        message.accountUin = object.accountUin;
                    else if (typeof object.accountUin === "object")
                        message.accountUin = new $util.LongBits(object.accountUin.low >>> 0, object.accountUin.high >>> 0).toNumber(true);
                if (object.accountUid != null)
                    message.accountUid = String(object.accountUid);
                return message;
            };

            /**
             * Creates a plain object from a ProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {kritor.contact.ProfileCardRequest} message ProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    if (typeof message.accountUin === "number")
                        object.accountUin = options.longs === String ? String(message.accountUin) : message.accountUin;
                    else
                        object.accountUin = options.longs === String ? $util.Long.prototype.toString.call(message.accountUin) : options.longs === Number ? new $util.LongBits(message.accountUin.low >>> 0, message.accountUin.high >>> 0).toNumber(true) : message.accountUin;
                    if (options.oneofs)
                        object.account = "accountUin";
                }
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    object.accountUid = message.accountUid;
                    if (options.oneofs)
                        object.account = "accountUid";
                }
                return object;
            };

            /**
             * Converts this ProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.ProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.contact.ProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.ProfileCardRequest";
            };

            return ProfileCardRequest;
        })();

        contact.StrangerInfoRequest = (function() {

            /**
             * Properties of a StrangerInfoRequest.
             * @memberof kritor.contact
             * @interface IStrangerInfoRequest
             * @property {number|Long|null} [uin] StrangerInfoRequest uin
             */

            /**
             * Constructs a new StrangerInfoRequest.
             * @memberof kritor.contact
             * @classdesc Represents a StrangerInfoRequest.
             * @implements IStrangerInfoRequest
             * @constructor
             * @param {kritor.contact.IStrangerInfoRequest=} [properties] Properties to set
             */
            function StrangerInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StrangerInfoRequest uin.
             * @member {number|Long} uin
             * @memberof kritor.contact.StrangerInfoRequest
             * @instance
             */
            StrangerInfoRequest.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new StrangerInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {kritor.contact.IStrangerInfoRequest=} [properties] Properties to set
             * @returns {kritor.contact.StrangerInfoRequest} StrangerInfoRequest instance
             */
            StrangerInfoRequest.create = function create(properties) {
                return new StrangerInfoRequest(properties);
            };

            /**
             * Encodes the specified StrangerInfoRequest message. Does not implicitly {@link kritor.contact.StrangerInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {kritor.contact.IStrangerInfoRequest} message StrangerInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StrangerInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified StrangerInfoRequest message, length delimited. Does not implicitly {@link kritor.contact.StrangerInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {kritor.contact.IStrangerInfoRequest} message StrangerInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StrangerInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StrangerInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.StrangerInfoRequest} StrangerInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StrangerInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.StrangerInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StrangerInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.StrangerInfoRequest} StrangerInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StrangerInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StrangerInfoRequest message.
             * @function verify
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StrangerInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                return null;
            };

            /**
             * Creates a StrangerInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.StrangerInfoRequest} StrangerInfoRequest
             */
            StrangerInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.StrangerInfoRequest)
                    return object;
                let message = new $root.kritor.contact.StrangerInfoRequest();
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a StrangerInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {kritor.contact.StrangerInfoRequest} message StrangerInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StrangerInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                return object;
            };

            /**
             * Converts this StrangerInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.StrangerInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StrangerInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StrangerInfoRequest
             * @function getTypeUrl
             * @memberof kritor.contact.StrangerInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StrangerInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.StrangerInfoRequest";
            };

            return StrangerInfoRequest;
        })();

        contact.GetUidRequest = (function() {

            /**
             * Properties of a GetUidRequest.
             * @memberof kritor.contact
             * @interface IGetUidRequest
             * @property {Array.<number|Long>|null} [uin] GetUidRequest uin
             */

            /**
             * Constructs a new GetUidRequest.
             * @memberof kritor.contact
             * @classdesc Represents a GetUidRequest.
             * @implements IGetUidRequest
             * @constructor
             * @param {kritor.contact.IGetUidRequest=} [properties] Properties to set
             */
            function GetUidRequest(properties) {
                this.uin = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUidRequest uin.
             * @member {Array.<number|Long>} uin
             * @memberof kritor.contact.GetUidRequest
             * @instance
             */
            GetUidRequest.prototype.uin = $util.emptyArray;

            /**
             * Creates a new GetUidRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {kritor.contact.IGetUidRequest=} [properties] Properties to set
             * @returns {kritor.contact.GetUidRequest} GetUidRequest instance
             */
            GetUidRequest.create = function create(properties) {
                return new GetUidRequest(properties);
            };

            /**
             * Encodes the specified GetUidRequest message. Does not implicitly {@link kritor.contact.GetUidRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {kritor.contact.IGetUidRequest} message GetUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && message.uin.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (let i = 0; i < message.uin.length; ++i)
                        writer.uint64(message.uin[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetUidRequest message, length delimited. Does not implicitly {@link kritor.contact.GetUidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {kritor.contact.IGetUidRequest} message GetUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.GetUidRequest} GetUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.GetUidRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.uin && message.uin.length))
                                message.uin = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.uin.push(reader.uint64());
                            } else
                                message.uin.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.GetUidRequest} GetUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUidRequest message.
             * @function verify
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (!Array.isArray(message.uin))
                        return "uin: array expected";
                    for (let i = 0; i < message.uin.length; ++i)
                        if (!$util.isInteger(message.uin[i]) && !(message.uin[i] && $util.isInteger(message.uin[i].low) && $util.isInteger(message.uin[i].high)))
                            return "uin: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.GetUidRequest} GetUidRequest
             */
            GetUidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.GetUidRequest)
                    return object;
                let message = new $root.kritor.contact.GetUidRequest();
                if (object.uin) {
                    if (!Array.isArray(object.uin))
                        throw TypeError(".kritor.contact.GetUidRequest.uin: array expected");
                    message.uin = [];
                    for (let i = 0; i < object.uin.length; ++i)
                        if ($util.Long)
                            (message.uin[i] = $util.Long.fromValue(object.uin[i])).unsigned = true;
                        else if (typeof object.uin[i] === "string")
                            message.uin[i] = parseInt(object.uin[i], 10);
                        else if (typeof object.uin[i] === "number")
                            message.uin[i] = object.uin[i];
                        else if (typeof object.uin[i] === "object")
                            message.uin[i] = new $util.LongBits(object.uin[i].low >>> 0, object.uin[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {kritor.contact.GetUidRequest} message GetUidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUidRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uin = [];
                if (message.uin && message.uin.length) {
                    object.uin = [];
                    for (let j = 0; j < message.uin.length; ++j)
                        if (typeof message.uin[j] === "number")
                            object.uin[j] = options.longs === String ? String(message.uin[j]) : message.uin[j];
                        else
                            object.uin[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uin[j]) : options.longs === Number ? new $util.LongBits(message.uin[j].low >>> 0, message.uin[j].high >>> 0).toNumber(true) : message.uin[j];
                }
                return object;
            };

            /**
             * Converts this GetUidRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.GetUidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUidRequest
             * @function getTypeUrl
             * @memberof kritor.contact.GetUidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.GetUidRequest";
            };

            return GetUidRequest;
        })();

        contact.GetUidResponse = (function() {

            /**
             * Properties of a GetUidResponse.
             * @memberof kritor.contact
             * @interface IGetUidResponse
             * @property {Object.<string,string>|null} [uid] GetUidResponse uid
             */

            /**
             * Constructs a new GetUidResponse.
             * @memberof kritor.contact
             * @classdesc Represents a GetUidResponse.
             * @implements IGetUidResponse
             * @constructor
             * @param {kritor.contact.IGetUidResponse=} [properties] Properties to set
             */
            function GetUidResponse(properties) {
                this.uid = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUidResponse uid.
             * @member {Object.<string,string>} uid
             * @memberof kritor.contact.GetUidResponse
             * @instance
             */
            GetUidResponse.prototype.uid = $util.emptyObject;

            /**
             * Creates a new GetUidResponse instance using the specified properties.
             * @function create
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {kritor.contact.IGetUidResponse=} [properties] Properties to set
             * @returns {kritor.contact.GetUidResponse} GetUidResponse instance
             */
            GetUidResponse.create = function create(properties) {
                return new GetUidResponse(properties);
            };

            /**
             * Encodes the specified GetUidResponse message. Does not implicitly {@link kritor.contact.GetUidResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {kritor.contact.IGetUidResponse} message GetUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    for (let keys = Object.keys(message.uid), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.uid[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetUidResponse message, length delimited. Does not implicitly {@link kritor.contact.GetUidResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {kritor.contact.IGetUidResponse} message GetUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUidResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.GetUidResponse} GetUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.GetUidResponse(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.uid === $util.emptyObject)
                                message.uid = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint64();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.uid[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUidResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.GetUidResponse} GetUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUidResponse message.
             * @function verify
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUidResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) {
                    if (!$util.isObject(message.uid))
                        return "uid: object expected";
                    let key = Object.keys(message.uid);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key64Re.test(key[i]))
                            return "uid: integer|Long key{k:uint64} expected";
                        if (!$util.isString(message.uid[key[i]]))
                            return "uid: string{k:uint64} expected";
                    }
                }
                return null;
            };

            /**
             * Creates a GetUidResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.GetUidResponse} GetUidResponse
             */
            GetUidResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.GetUidResponse)
                    return object;
                let message = new $root.kritor.contact.GetUidResponse();
                if (object.uid) {
                    if (typeof object.uid !== "object")
                        throw TypeError(".kritor.contact.GetUidResponse.uid: object expected");
                    message.uid = {};
                    for (let keys = Object.keys(object.uid), i = 0; i < keys.length; ++i)
                        message.uid[keys[i]] = String(object.uid[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUidResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {kritor.contact.GetUidResponse} message GetUidResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUidResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.uid = {};
                let keys2;
                if (message.uid && (keys2 = Object.keys(message.uid)).length) {
                    object.uid = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.uid[keys2[j]] = message.uid[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GetUidResponse to JSON.
             * @function toJSON
             * @memberof kritor.contact.GetUidResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUidResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUidResponse
             * @function getTypeUrl
             * @memberof kritor.contact.GetUidResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.GetUidResponse";
            };

            return GetUidResponse;
        })();

        contact.GetUinByUidRequest = (function() {

            /**
             * Properties of a GetUinByUidRequest.
             * @memberof kritor.contact
             * @interface IGetUinByUidRequest
             * @property {Array.<string>|null} [uid] GetUinByUidRequest uid
             */

            /**
             * Constructs a new GetUinByUidRequest.
             * @memberof kritor.contact
             * @classdesc Represents a GetUinByUidRequest.
             * @implements IGetUinByUidRequest
             * @constructor
             * @param {kritor.contact.IGetUinByUidRequest=} [properties] Properties to set
             */
            function GetUinByUidRequest(properties) {
                this.uid = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUinByUidRequest uid.
             * @member {Array.<string>} uid
             * @memberof kritor.contact.GetUinByUidRequest
             * @instance
             */
            GetUinByUidRequest.prototype.uid = $util.emptyArray;

            /**
             * Creates a new GetUinByUidRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {kritor.contact.IGetUinByUidRequest=} [properties] Properties to set
             * @returns {kritor.contact.GetUinByUidRequest} GetUinByUidRequest instance
             */
            GetUinByUidRequest.create = function create(properties) {
                return new GetUinByUidRequest(properties);
            };

            /**
             * Encodes the specified GetUinByUidRequest message. Does not implicitly {@link kritor.contact.GetUinByUidRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {kritor.contact.IGetUinByUidRequest} message GetUinByUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && message.uid.length)
                    for (let i = 0; i < message.uid.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid[i]);
                return writer;
            };

            /**
             * Encodes the specified GetUinByUidRequest message, length delimited. Does not implicitly {@link kritor.contact.GetUinByUidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {kritor.contact.IGetUinByUidRequest} message GetUinByUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUinByUidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.GetUinByUidRequest} GetUinByUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.GetUinByUidRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.uid && message.uid.length))
                                message.uid = [];
                            message.uid.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUinByUidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.GetUinByUidRequest} GetUinByUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUinByUidRequest message.
             * @function verify
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUinByUidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid")) {
                    if (!Array.isArray(message.uid))
                        return "uid: array expected";
                    for (let i = 0; i < message.uid.length; ++i)
                        if (!$util.isString(message.uid[i]))
                            return "uid: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUinByUidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.GetUinByUidRequest} GetUinByUidRequest
             */
            GetUinByUidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.GetUinByUidRequest)
                    return object;
                let message = new $root.kritor.contact.GetUinByUidRequest();
                if (object.uid) {
                    if (!Array.isArray(object.uid))
                        throw TypeError(".kritor.contact.GetUinByUidRequest.uid: array expected");
                    message.uid = [];
                    for (let i = 0; i < object.uid.length; ++i)
                        message.uid[i] = String(object.uid[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUinByUidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {kritor.contact.GetUinByUidRequest} message GetUinByUidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUinByUidRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uid = [];
                if (message.uid && message.uid.length) {
                    object.uid = [];
                    for (let j = 0; j < message.uid.length; ++j)
                        object.uid[j] = message.uid[j];
                }
                return object;
            };

            /**
             * Converts this GetUinByUidRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.GetUinByUidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUinByUidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUinByUidRequest
             * @function getTypeUrl
             * @memberof kritor.contact.GetUinByUidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUinByUidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.GetUinByUidRequest";
            };

            return GetUinByUidRequest;
        })();

        contact.GetUinByUidResponse = (function() {

            /**
             * Properties of a GetUinByUidResponse.
             * @memberof kritor.contact
             * @interface IGetUinByUidResponse
             * @property {Object.<string,number|Long>|null} [uin] GetUinByUidResponse uin
             */

            /**
             * Constructs a new GetUinByUidResponse.
             * @memberof kritor.contact
             * @classdesc Represents a GetUinByUidResponse.
             * @implements IGetUinByUidResponse
             * @constructor
             * @param {kritor.contact.IGetUinByUidResponse=} [properties] Properties to set
             */
            function GetUinByUidResponse(properties) {
                this.uin = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUinByUidResponse uin.
             * @member {Object.<string,number|Long>} uin
             * @memberof kritor.contact.GetUinByUidResponse
             * @instance
             */
            GetUinByUidResponse.prototype.uin = $util.emptyObject;

            /**
             * Creates a new GetUinByUidResponse instance using the specified properties.
             * @function create
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {kritor.contact.IGetUinByUidResponse=} [properties] Properties to set
             * @returns {kritor.contact.GetUinByUidResponse} GetUinByUidResponse instance
             */
            GetUinByUidResponse.create = function create(properties) {
                return new GetUinByUidResponse(properties);
            };

            /**
             * Encodes the specified GetUinByUidResponse message. Does not implicitly {@link kritor.contact.GetUinByUidResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {kritor.contact.IGetUinByUidResponse} message GetUinByUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    for (let keys = Object.keys(message.uin), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.uin[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetUinByUidResponse message, length delimited. Does not implicitly {@link kritor.contact.GetUinByUidResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {kritor.contact.IGetUinByUidResponse} message GetUinByUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUinByUidResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.GetUinByUidResponse} GetUinByUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.GetUinByUidResponse(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.uin === $util.emptyObject)
                                message.uin = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = 0;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.uin[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUinByUidResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.GetUinByUidResponse} GetUinByUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUinByUidResponse message.
             * @function verify
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUinByUidResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (!$util.isObject(message.uin))
                        return "uin: object expected";
                    let key = Object.keys(message.uin);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isInteger(message.uin[key[i]]) && !(message.uin[key[i]] && $util.isInteger(message.uin[key[i]].low) && $util.isInteger(message.uin[key[i]].high)))
                            return "uin: integer|Long{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a GetUinByUidResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.GetUinByUidResponse} GetUinByUidResponse
             */
            GetUinByUidResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.GetUinByUidResponse)
                    return object;
                let message = new $root.kritor.contact.GetUinByUidResponse();
                if (object.uin) {
                    if (typeof object.uin !== "object")
                        throw TypeError(".kritor.contact.GetUinByUidResponse.uin: object expected");
                    message.uin = {};
                    for (let keys = Object.keys(object.uin), i = 0; i < keys.length; ++i)
                        if ($util.Long)
                            (message.uin[keys[i]] = $util.Long.fromValue(object.uin[keys[i]])).unsigned = true;
                        else if (typeof object.uin[keys[i]] === "string")
                            message.uin[keys[i]] = parseInt(object.uin[keys[i]], 10);
                        else if (typeof object.uin[keys[i]] === "number")
                            message.uin[keys[i]] = object.uin[keys[i]];
                        else if (typeof object.uin[keys[i]] === "object")
                            message.uin[keys[i]] = new $util.LongBits(object.uin[keys[i]].low >>> 0, object.uin[keys[i]].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUinByUidResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {kritor.contact.GetUinByUidResponse} message GetUinByUidResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUinByUidResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.uin = {};
                let keys2;
                if (message.uin && (keys2 = Object.keys(message.uin)).length) {
                    object.uin = {};
                    for (let j = 0; j < keys2.length; ++j)
                        if (typeof message.uin[keys2[j]] === "number")
                            object.uin[keys2[j]] = options.longs === String ? String(message.uin[keys2[j]]) : message.uin[keys2[j]];
                        else
                            object.uin[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.uin[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.uin[keys2[j]].low >>> 0, message.uin[keys2[j]].high >>> 0).toNumber(true) : message.uin[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GetUinByUidResponse to JSON.
             * @function toJSON
             * @memberof kritor.contact.GetUinByUidResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUinByUidResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUinByUidResponse
             * @function getTypeUrl
             * @memberof kritor.contact.GetUinByUidResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUinByUidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.GetUinByUidResponse";
            };

            return GetUinByUidResponse;
        })();

        contact.SetProfileCardRequest = (function() {

            /**
             * Properties of a SetProfileCardRequest.
             * @memberof kritor.contact
             * @interface ISetProfileCardRequest
             * @property {string|null} [nickName] SetProfileCardRequest nickName
             * @property {string|null} [company] SetProfileCardRequest company
             * @property {string|null} [email] SetProfileCardRequest email
             * @property {string|null} [college] SetProfileCardRequest college
             * @property {string|null} [personalNote] SetProfileCardRequest personalNote
             * @property {number|null} [birthday] SetProfileCardRequest birthday
             * @property {number|null} [age] SetProfileCardRequest age
             */

            /**
             * Constructs a new SetProfileCardRequest.
             * @memberof kritor.contact
             * @classdesc Represents a SetProfileCardRequest.
             * @implements ISetProfileCardRequest
             * @constructor
             * @param {kritor.contact.ISetProfileCardRequest=} [properties] Properties to set
             */
            function SetProfileCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetProfileCardRequest nickName.
             * @member {string|null|undefined} nickName
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.nickName = null;

            /**
             * SetProfileCardRequest company.
             * @member {string|null|undefined} company
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.company = null;

            /**
             * SetProfileCardRequest email.
             * @member {string|null|undefined} email
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.email = null;

            /**
             * SetProfileCardRequest college.
             * @member {string|null|undefined} college
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.college = null;

            /**
             * SetProfileCardRequest personalNote.
             * @member {string|null|undefined} personalNote
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.personalNote = null;

            /**
             * SetProfileCardRequest birthday.
             * @member {number|null|undefined} birthday
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.birthday = null;

            /**
             * SetProfileCardRequest age.
             * @member {number|null|undefined} age
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.age = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetProfileCardRequest _nickName.
             * @member {"nickName"|undefined} _nickName
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_nickName", {
                get: $util.oneOfGetter($oneOfFields = ["nickName"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _company.
             * @member {"company"|undefined} _company
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_company", {
                get: $util.oneOfGetter($oneOfFields = ["company"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _email.
             * @member {"email"|undefined} _email
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_email", {
                get: $util.oneOfGetter($oneOfFields = ["email"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _college.
             * @member {"college"|undefined} _college
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_college", {
                get: $util.oneOfGetter($oneOfFields = ["college"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _personalNote.
             * @member {"personalNote"|undefined} _personalNote
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_personalNote", {
                get: $util.oneOfGetter($oneOfFields = ["personalNote"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _birthday.
             * @member {"birthday"|undefined} _birthday
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_birthday", {
                get: $util.oneOfGetter($oneOfFields = ["birthday"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _age.
             * @member {"age"|undefined} _age
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_age", {
                get: $util.oneOfGetter($oneOfFields = ["age"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {kritor.contact.ISetProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.contact.SetProfileCardRequest} SetProfileCardRequest instance
             */
            SetProfileCardRequest.create = function create(properties) {
                return new SetProfileCardRequest(properties);
            };

            /**
             * Encodes the specified SetProfileCardRequest message. Does not implicitly {@link kritor.contact.SetProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {kritor.contact.ISetProfileCardRequest} message SetProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nickName != null && Object.hasOwnProperty.call(message, "nickName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickName);
                if (message.company != null && Object.hasOwnProperty.call(message, "company"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.company);
                if (message.email != null && Object.hasOwnProperty.call(message, "email"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
                if (message.college != null && Object.hasOwnProperty.call(message, "college"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.college);
                if (message.personalNote != null && Object.hasOwnProperty.call(message, "personalNote"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.personalNote);
                if (message.birthday != null && Object.hasOwnProperty.call(message, "birthday"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.birthday);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.age);
                return writer;
            };

            /**
             * Encodes the specified SetProfileCardRequest message, length delimited. Does not implicitly {@link kritor.contact.SetProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {kritor.contact.ISetProfileCardRequest} message SetProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.SetProfileCardRequest} SetProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.SetProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nickName = reader.string();
                            break;
                        }
                    case 2: {
                            message.company = reader.string();
                            break;
                        }
                    case 3: {
                            message.email = reader.string();
                            break;
                        }
                    case 4: {
                            message.college = reader.string();
                            break;
                        }
                    case 5: {
                            message.personalNote = reader.string();
                            break;
                        }
                    case 6: {
                            message.birthday = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.age = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.SetProfileCardRequest} SetProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetProfileCardRequest message.
             * @function verify
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nickName != null && message.hasOwnProperty("nickName")) {
                    properties._nickName = 1;
                    if (!$util.isString(message.nickName))
                        return "nickName: string expected";
                }
                if (message.company != null && message.hasOwnProperty("company")) {
                    properties._company = 1;
                    if (!$util.isString(message.company))
                        return "company: string expected";
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties._email = 1;
                    if (!$util.isString(message.email))
                        return "email: string expected";
                }
                if (message.college != null && message.hasOwnProperty("college")) {
                    properties._college = 1;
                    if (!$util.isString(message.college))
                        return "college: string expected";
                }
                if (message.personalNote != null && message.hasOwnProperty("personalNote")) {
                    properties._personalNote = 1;
                    if (!$util.isString(message.personalNote))
                        return "personalNote: string expected";
                }
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    properties._birthday = 1;
                    if (!$util.isInteger(message.birthday))
                        return "birthday: integer expected";
                }
                if (message.age != null && message.hasOwnProperty("age")) {
                    properties._age = 1;
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                }
                return null;
            };

            /**
             * Creates a SetProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.SetProfileCardRequest} SetProfileCardRequest
             */
            SetProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.SetProfileCardRequest)
                    return object;
                let message = new $root.kritor.contact.SetProfileCardRequest();
                if (object.nickName != null)
                    message.nickName = String(object.nickName);
                if (object.company != null)
                    message.company = String(object.company);
                if (object.email != null)
                    message.email = String(object.email);
                if (object.college != null)
                    message.college = String(object.college);
                if (object.personalNote != null)
                    message.personalNote = String(object.personalNote);
                if (object.birthday != null)
                    message.birthday = object.birthday >>> 0;
                if (object.age != null)
                    message.age = object.age >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {kritor.contact.SetProfileCardRequest} message SetProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.nickName != null && message.hasOwnProperty("nickName")) {
                    object.nickName = message.nickName;
                    if (options.oneofs)
                        object._nickName = "nickName";
                }
                if (message.company != null && message.hasOwnProperty("company")) {
                    object.company = message.company;
                    if (options.oneofs)
                        object._company = "company";
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = message.email;
                    if (options.oneofs)
                        object._email = "email";
                }
                if (message.college != null && message.hasOwnProperty("college")) {
                    object.college = message.college;
                    if (options.oneofs)
                        object._college = "college";
                }
                if (message.personalNote != null && message.hasOwnProperty("personalNote")) {
                    object.personalNote = message.personalNote;
                    if (options.oneofs)
                        object._personalNote = "personalNote";
                }
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    object.birthday = message.birthday;
                    if (options.oneofs)
                        object._birthday = "birthday";
                }
                if (message.age != null && message.hasOwnProperty("age")) {
                    object.age = message.age;
                    if (options.oneofs)
                        object._age = "age";
                }
                return object;
            };

            /**
             * Converts this SetProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.SetProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.contact.SetProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.SetProfileCardRequest";
            };

            return SetProfileCardRequest;
        })();

        contact.SetProfileCardResponse = (function() {

            /**
             * Properties of a SetProfileCardResponse.
             * @memberof kritor.contact
             * @interface ISetProfileCardResponse
             */

            /**
             * Constructs a new SetProfileCardResponse.
             * @memberof kritor.contact
             * @classdesc Represents a SetProfileCardResponse.
             * @implements ISetProfileCardResponse
             * @constructor
             * @param {kritor.contact.ISetProfileCardResponse=} [properties] Properties to set
             */
            function SetProfileCardResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {kritor.contact.ISetProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.contact.SetProfileCardResponse} SetProfileCardResponse instance
             */
            SetProfileCardResponse.create = function create(properties) {
                return new SetProfileCardResponse(properties);
            };

            /**
             * Encodes the specified SetProfileCardResponse message. Does not implicitly {@link kritor.contact.SetProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {kritor.contact.ISetProfileCardResponse} message SetProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetProfileCardResponse message, length delimited. Does not implicitly {@link kritor.contact.SetProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {kritor.contact.ISetProfileCardResponse} message SetProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.SetProfileCardResponse} SetProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.SetProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.SetProfileCardResponse} SetProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetProfileCardResponse message.
             * @function verify
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.SetProfileCardResponse} SetProfileCardResponse
             */
            SetProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.SetProfileCardResponse)
                    return object;
                return new $root.kritor.contact.SetProfileCardResponse();
            };

            /**
             * Creates a plain object from a SetProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {kritor.contact.SetProfileCardResponse} message SetProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetProfileCardResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.contact.SetProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.contact.SetProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.SetProfileCardResponse";
            };

            return SetProfileCardResponse;
        })();

        contact.IsBlackListUserRequest = (function() {

            /**
             * Properties of an IsBlackListUserRequest.
             * @memberof kritor.contact
             * @interface IIsBlackListUserRequest
             * @property {number|Long|null} [uin] IsBlackListUserRequest uin
             */

            /**
             * Constructs a new IsBlackListUserRequest.
             * @memberof kritor.contact
             * @classdesc Represents an IsBlackListUserRequest.
             * @implements IIsBlackListUserRequest
             * @constructor
             * @param {kritor.contact.IIsBlackListUserRequest=} [properties] Properties to set
             */
            function IsBlackListUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsBlackListUserRequest uin.
             * @member {number|Long} uin
             * @memberof kritor.contact.IsBlackListUserRequest
             * @instance
             */
            IsBlackListUserRequest.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new IsBlackListUserRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {kritor.contact.IIsBlackListUserRequest=} [properties] Properties to set
             * @returns {kritor.contact.IsBlackListUserRequest} IsBlackListUserRequest instance
             */
            IsBlackListUserRequest.create = function create(properties) {
                return new IsBlackListUserRequest(properties);
            };

            /**
             * Encodes the specified IsBlackListUserRequest message. Does not implicitly {@link kritor.contact.IsBlackListUserRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {kritor.contact.IIsBlackListUserRequest} message IsBlackListUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified IsBlackListUserRequest message, length delimited. Does not implicitly {@link kritor.contact.IsBlackListUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {kritor.contact.IIsBlackListUserRequest} message IsBlackListUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsBlackListUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.IsBlackListUserRequest} IsBlackListUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.IsBlackListUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsBlackListUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.IsBlackListUserRequest} IsBlackListUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsBlackListUserRequest message.
             * @function verify
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsBlackListUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                return null;
            };

            /**
             * Creates an IsBlackListUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.IsBlackListUserRequest} IsBlackListUserRequest
             */
            IsBlackListUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.IsBlackListUserRequest)
                    return object;
                let message = new $root.kritor.contact.IsBlackListUserRequest();
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an IsBlackListUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {kritor.contact.IsBlackListUserRequest} message IsBlackListUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsBlackListUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                return object;
            };

            /**
             * Converts this IsBlackListUserRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.IsBlackListUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsBlackListUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IsBlackListUserRequest
             * @function getTypeUrl
             * @memberof kritor.contact.IsBlackListUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IsBlackListUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.IsBlackListUserRequest";
            };

            return IsBlackListUserRequest;
        })();

        contact.IsBlackListUserResponse = (function() {

            /**
             * Properties of an IsBlackListUserResponse.
             * @memberof kritor.contact
             * @interface IIsBlackListUserResponse
             * @property {boolean|null} [isBlackListUser] IsBlackListUserResponse isBlackListUser
             */

            /**
             * Constructs a new IsBlackListUserResponse.
             * @memberof kritor.contact
             * @classdesc Represents an IsBlackListUserResponse.
             * @implements IIsBlackListUserResponse
             * @constructor
             * @param {kritor.contact.IIsBlackListUserResponse=} [properties] Properties to set
             */
            function IsBlackListUserResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsBlackListUserResponse isBlackListUser.
             * @member {boolean} isBlackListUser
             * @memberof kritor.contact.IsBlackListUserResponse
             * @instance
             */
            IsBlackListUserResponse.prototype.isBlackListUser = false;

            /**
             * Creates a new IsBlackListUserResponse instance using the specified properties.
             * @function create
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {kritor.contact.IIsBlackListUserResponse=} [properties] Properties to set
             * @returns {kritor.contact.IsBlackListUserResponse} IsBlackListUserResponse instance
             */
            IsBlackListUserResponse.create = function create(properties) {
                return new IsBlackListUserResponse(properties);
            };

            /**
             * Encodes the specified IsBlackListUserResponse message. Does not implicitly {@link kritor.contact.IsBlackListUserResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {kritor.contact.IIsBlackListUserResponse} message IsBlackListUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isBlackListUser != null && Object.hasOwnProperty.call(message, "isBlackListUser"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isBlackListUser);
                return writer;
            };

            /**
             * Encodes the specified IsBlackListUserResponse message, length delimited. Does not implicitly {@link kritor.contact.IsBlackListUserResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {kritor.contact.IIsBlackListUserResponse} message IsBlackListUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsBlackListUserResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.IsBlackListUserResponse} IsBlackListUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.IsBlackListUserResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isBlackListUser = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsBlackListUserResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.IsBlackListUserResponse} IsBlackListUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsBlackListUserResponse message.
             * @function verify
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsBlackListUserResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isBlackListUser != null && message.hasOwnProperty("isBlackListUser"))
                    if (typeof message.isBlackListUser !== "boolean")
                        return "isBlackListUser: boolean expected";
                return null;
            };

            /**
             * Creates an IsBlackListUserResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.IsBlackListUserResponse} IsBlackListUserResponse
             */
            IsBlackListUserResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.IsBlackListUserResponse)
                    return object;
                let message = new $root.kritor.contact.IsBlackListUserResponse();
                if (object.isBlackListUser != null)
                    message.isBlackListUser = Boolean(object.isBlackListUser);
                return message;
            };

            /**
             * Creates a plain object from an IsBlackListUserResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {kritor.contact.IsBlackListUserResponse} message IsBlackListUserResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsBlackListUserResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.isBlackListUser = false;
                if (message.isBlackListUser != null && message.hasOwnProperty("isBlackListUser"))
                    object.isBlackListUser = message.isBlackListUser;
                return object;
            };

            /**
             * Converts this IsBlackListUserResponse to JSON.
             * @function toJSON
             * @memberof kritor.contact.IsBlackListUserResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsBlackListUserResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IsBlackListUserResponse
             * @function getTypeUrl
             * @memberof kritor.contact.IsBlackListUserResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IsBlackListUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.IsBlackListUserResponse";
            };

            return IsBlackListUserResponse;
        })();

        contact.VoteUserRequest = (function() {

            /**
             * Properties of a VoteUserRequest.
             * @memberof kritor.contact
             * @interface IVoteUserRequest
             * @property {number|Long|null} [accountUin] VoteUserRequest accountUin
             * @property {string|null} [accountUid] VoteUserRequest accountUid
             * @property {number|null} [voteCount] VoteUserRequest voteCount
             */

            /**
             * Constructs a new VoteUserRequest.
             * @memberof kritor.contact
             * @classdesc Represents a VoteUserRequest.
             * @implements IVoteUserRequest
             * @constructor
             * @param {kritor.contact.IVoteUserRequest=} [properties] Properties to set
             */
            function VoteUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoteUserRequest accountUin.
             * @member {number|Long|null|undefined} accountUin
             * @memberof kritor.contact.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.accountUin = null;

            /**
             * VoteUserRequest accountUid.
             * @member {string|null|undefined} accountUid
             * @memberof kritor.contact.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.accountUid = null;

            /**
             * VoteUserRequest voteCount.
             * @member {number|null|undefined} voteCount
             * @memberof kritor.contact.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.voteCount = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoteUserRequest account.
             * @member {"accountUin"|"accountUid"|undefined} account
             * @memberof kritor.contact.VoteUserRequest
             * @instance
             */
            Object.defineProperty(VoteUserRequest.prototype, "account", {
                get: $util.oneOfGetter($oneOfFields = ["accountUin", "accountUid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoteUserRequest _voteCount.
             * @member {"voteCount"|undefined} _voteCount
             * @memberof kritor.contact.VoteUserRequest
             * @instance
             */
            Object.defineProperty(VoteUserRequest.prototype, "_voteCount", {
                get: $util.oneOfGetter($oneOfFields = ["voteCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoteUserRequest instance using the specified properties.
             * @function create
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {kritor.contact.IVoteUserRequest=} [properties] Properties to set
             * @returns {kritor.contact.VoteUserRequest} VoteUserRequest instance
             */
            VoteUserRequest.create = function create(properties) {
                return new VoteUserRequest(properties);
            };

            /**
             * Encodes the specified VoteUserRequest message. Does not implicitly {@link kritor.contact.VoteUserRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {kritor.contact.IVoteUserRequest} message VoteUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountUin != null && Object.hasOwnProperty.call(message, "accountUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accountUin);
                if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountUid);
                if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.voteCount);
                return writer;
            };

            /**
             * Encodes the specified VoteUserRequest message, length delimited. Does not implicitly {@link kritor.contact.VoteUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {kritor.contact.IVoteUserRequest} message VoteUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoteUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.VoteUserRequest} VoteUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.VoteUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountUin = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.accountUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.voteCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoteUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.VoteUserRequest} VoteUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoteUserRequest message.
             * @function verify
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoteUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    properties.account = 1;
                    if (!$util.isInteger(message.accountUin) && !(message.accountUin && $util.isInteger(message.accountUin.low) && $util.isInteger(message.accountUin.high)))
                        return "accountUin: integer|Long expected";
                }
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    if (properties.account === 1)
                        return "account: multiple values";
                    properties.account = 1;
                    if (!$util.isString(message.accountUid))
                        return "accountUid: string expected";
                }
                if (message.voteCount != null && message.hasOwnProperty("voteCount")) {
                    properties._voteCount = 1;
                    if (!$util.isInteger(message.voteCount))
                        return "voteCount: integer expected";
                }
                return null;
            };

            /**
             * Creates a VoteUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.VoteUserRequest} VoteUserRequest
             */
            VoteUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.VoteUserRequest)
                    return object;
                let message = new $root.kritor.contact.VoteUserRequest();
                if (object.accountUin != null)
                    if ($util.Long)
                        (message.accountUin = $util.Long.fromValue(object.accountUin)).unsigned = true;
                    else if (typeof object.accountUin === "string")
                        message.accountUin = parseInt(object.accountUin, 10);
                    else if (typeof object.accountUin === "number")
                        message.accountUin = object.accountUin;
                    else if (typeof object.accountUin === "object")
                        message.accountUin = new $util.LongBits(object.accountUin.low >>> 0, object.accountUin.high >>> 0).toNumber(true);
                if (object.accountUid != null)
                    message.accountUid = String(object.accountUid);
                if (object.voteCount != null)
                    message.voteCount = object.voteCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a VoteUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {kritor.contact.VoteUserRequest} message VoteUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoteUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    if (typeof message.accountUin === "number")
                        object.accountUin = options.longs === String ? String(message.accountUin) : message.accountUin;
                    else
                        object.accountUin = options.longs === String ? $util.Long.prototype.toString.call(message.accountUin) : options.longs === Number ? new $util.LongBits(message.accountUin.low >>> 0, message.accountUin.high >>> 0).toNumber(true) : message.accountUin;
                    if (options.oneofs)
                        object.account = "accountUin";
                }
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    object.accountUid = message.accountUid;
                    if (options.oneofs)
                        object.account = "accountUid";
                }
                if (message.voteCount != null && message.hasOwnProperty("voteCount")) {
                    object.voteCount = message.voteCount;
                    if (options.oneofs)
                        object._voteCount = "voteCount";
                }
                return object;
            };

            /**
             * Converts this VoteUserRequest to JSON.
             * @function toJSON
             * @memberof kritor.contact.VoteUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoteUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoteUserRequest
             * @function getTypeUrl
             * @memberof kritor.contact.VoteUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoteUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.VoteUserRequest";
            };

            return VoteUserRequest;
        })();

        contact.VoteUserResponse = (function() {

            /**
             * Properties of a VoteUserResponse.
             * @memberof kritor.contact
             * @interface IVoteUserResponse
             */

            /**
             * Constructs a new VoteUserResponse.
             * @memberof kritor.contact
             * @classdesc Represents a VoteUserResponse.
             * @implements IVoteUserResponse
             * @constructor
             * @param {kritor.contact.IVoteUserResponse=} [properties] Properties to set
             */
            function VoteUserResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new VoteUserResponse instance using the specified properties.
             * @function create
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {kritor.contact.IVoteUserResponse=} [properties] Properties to set
             * @returns {kritor.contact.VoteUserResponse} VoteUserResponse instance
             */
            VoteUserResponse.create = function create(properties) {
                return new VoteUserResponse(properties);
            };

            /**
             * Encodes the specified VoteUserResponse message. Does not implicitly {@link kritor.contact.VoteUserResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {kritor.contact.IVoteUserResponse} message VoteUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified VoteUserResponse message, length delimited. Does not implicitly {@link kritor.contact.VoteUserResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {kritor.contact.IVoteUserResponse} message VoteUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoteUserResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.contact.VoteUserResponse} VoteUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.contact.VoteUserResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoteUserResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.contact.VoteUserResponse} VoteUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoteUserResponse message.
             * @function verify
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoteUserResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a VoteUserResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.contact.VoteUserResponse} VoteUserResponse
             */
            VoteUserResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.contact.VoteUserResponse)
                    return object;
                return new $root.kritor.contact.VoteUserResponse();
            };

            /**
             * Creates a plain object from a VoteUserResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {kritor.contact.VoteUserResponse} message VoteUserResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoteUserResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this VoteUserResponse to JSON.
             * @function toJSON
             * @memberof kritor.contact.VoteUserResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoteUserResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoteUserResponse
             * @function getTypeUrl
             * @memberof kritor.contact.VoteUserResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoteUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.contact.VoteUserResponse";
            };

            return VoteUserResponse;
        })();

        return contact;
    })();

    kritor.core = (function() {

        /**
         * Namespace core.
         * @memberof kritor
         * @namespace
         */
        const core = {};

        core.KritorService = (function() {

            /**
             * Constructs a new KritorService service.
             * @memberof kritor.core
             * @classdesc Represents a KritorService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function KritorService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (KritorService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = KritorService;

            /**
             * Creates new KritorService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.core.KritorService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {KritorService} RPC service. Useful where requests and/or responses are streamed.
             */
            KritorService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.core.KritorService#getVersion}.
             * @memberof kritor.core.KritorService
             * @typedef GetVersionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetVersionResponse} [response] GetVersionResponse
             */

            /**
             * Calls GetVersion.
             * @function getVersion
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IGetVersionRequest} request GetVersionRequest message or plain object
             * @param {kritor.core.KritorService.GetVersionCallback} callback Node-style callback called with the error, if any, and GetVersionResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KritorService.prototype.getVersion = function getVersion(request, callback) {
                return this.rpcCall(getVersion, $root.kritor.core.GetVersionRequest, $root.kritor.core.GetVersionResponse, request, callback);
            }, "name", { value: "GetVersion" });

            /**
             * Calls GetVersion.
             * @function getVersion
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IGetVersionRequest} request GetVersionRequest message or plain object
             * @returns {Promise<kritor.core.GetVersionResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.KritorService#clearCache}.
             * @memberof kritor.core.KritorService
             * @typedef ClearCacheCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.ClearCacheResponse} [response] ClearCacheResponse
             */

            /**
             * Calls ClearCache.
             * @function clearCache
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IClearCacheRequest} request ClearCacheRequest message or plain object
             * @param {kritor.core.KritorService.ClearCacheCallback} callback Node-style callback called with the error, if any, and ClearCacheResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KritorService.prototype.clearCache = function clearCache(request, callback) {
                return this.rpcCall(clearCache, $root.kritor.core.ClearCacheRequest, $root.kritor.core.ClearCacheResponse, request, callback);
            }, "name", { value: "ClearCache" });

            /**
             * Calls ClearCache.
             * @function clearCache
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IClearCacheRequest} request ClearCacheRequest message or plain object
             * @returns {Promise<kritor.core.ClearCacheResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.KritorService#downloadFile}.
             * @memberof kritor.core.KritorService
             * @typedef DownloadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.DownloadFileResponse} [response] DownloadFileResponse
             */

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @param {kritor.core.KritorService.DownloadFileCallback} callback Node-style callback called with the error, if any, and DownloadFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KritorService.prototype.downloadFile = function downloadFile(request, callback) {
                return this.rpcCall(downloadFile, $root.kritor.core.DownloadFileRequest, $root.kritor.core.DownloadFileResponse, request, callback);
            }, "name", { value: "DownloadFile" });

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @returns {Promise<kritor.core.DownloadFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.KritorService#getCurrentAccount}.
             * @memberof kritor.core.KritorService
             * @typedef GetCurrentAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetCurrentAccountResponse} [response] GetCurrentAccountResponse
             */

            /**
             * Calls GetCurrentAccount.
             * @function getCurrentAccount
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IGetCurrentAccountRequest} request GetCurrentAccountRequest message or plain object
             * @param {kritor.core.KritorService.GetCurrentAccountCallback} callback Node-style callback called with the error, if any, and GetCurrentAccountResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KritorService.prototype.getCurrentAccount = function getCurrentAccount(request, callback) {
                return this.rpcCall(getCurrentAccount, $root.kritor.core.GetCurrentAccountRequest, $root.kritor.core.GetCurrentAccountResponse, request, callback);
            }, "name", { value: "GetCurrentAccount" });

            /**
             * Calls GetCurrentAccount.
             * @function getCurrentAccount
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IGetCurrentAccountRequest} request GetCurrentAccountRequest message or plain object
             * @returns {Promise<kritor.core.GetCurrentAccountResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.KritorService#switchAccount}.
             * @memberof kritor.core.KritorService
             * @typedef SwitchAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.SwitchAccountResponse} [response] SwitchAccountResponse
             */

            /**
             * Calls SwitchAccount.
             * @function switchAccount
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.ISwitchAccountRequest} request SwitchAccountRequest message or plain object
             * @param {kritor.core.KritorService.SwitchAccountCallback} callback Node-style callback called with the error, if any, and SwitchAccountResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KritorService.prototype.switchAccount = function switchAccount(request, callback) {
                return this.rpcCall(switchAccount, $root.kritor.core.SwitchAccountRequest, $root.kritor.core.SwitchAccountResponse, request, callback);
            }, "name", { value: "SwitchAccount" });

            /**
             * Calls SwitchAccount.
             * @function switchAccount
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.ISwitchAccountRequest} request SwitchAccountRequest message or plain object
             * @returns {Promise<kritor.core.SwitchAccountResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.KritorService#getDeviceBattery}.
             * @memberof kritor.core.KritorService
             * @typedef GetDeviceBatteryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetDeviceBatteryResponse} [response] GetDeviceBatteryResponse
             */

            /**
             * Calls GetDeviceBattery.
             * @function getDeviceBattery
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IGetDeviceBatteryRequest} request GetDeviceBatteryRequest message or plain object
             * @param {kritor.core.KritorService.GetDeviceBatteryCallback} callback Node-style callback called with the error, if any, and GetDeviceBatteryResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KritorService.prototype.getDeviceBattery = function getDeviceBattery(request, callback) {
                return this.rpcCall(getDeviceBattery, $root.kritor.core.GetDeviceBatteryRequest, $root.kritor.core.GetDeviceBatteryResponse, request, callback);
            }, "name", { value: "GetDeviceBattery" });

            /**
             * Calls GetDeviceBattery.
             * @function getDeviceBattery
             * @memberof kritor.core.KritorService
             * @instance
             * @param {kritor.core.IGetDeviceBatteryRequest} request GetDeviceBatteryRequest message or plain object
             * @returns {Promise<kritor.core.GetDeviceBatteryResponse>} Promise
             * @variation 2
             */

            return KritorService;
        })();

        core.GetVersionRequest = (function() {

            /**
             * Properties of a GetVersionRequest.
             * @memberof kritor.core
             * @interface IGetVersionRequest
             */

            /**
             * Constructs a new GetVersionRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetVersionRequest.
             * @implements IGetVersionRequest
             * @constructor
             * @param {kritor.core.IGetVersionRequest=} [properties] Properties to set
             */
            function GetVersionRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetVersionRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest=} [properties] Properties to set
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest instance
             */
            GetVersionRequest.create = function create(properties) {
                return new GetVersionRequest(properties);
            };

            /**
             * Encodes the specified GetVersionRequest message. Does not implicitly {@link kritor.core.GetVersionRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest} message GetVersionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetVersionRequest message, length delimited. Does not implicitly {@link kritor.core.GetVersionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest} message GetVersionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetVersionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetVersionRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetVersionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetVersionRequest message.
             * @function verify
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetVersionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetVersionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             */
            GetVersionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetVersionRequest)
                    return object;
                return new $root.kritor.core.GetVersionRequest();
            };

            /**
             * Creates a plain object from a GetVersionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.GetVersionRequest} message GetVersionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetVersionRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetVersionRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetVersionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetVersionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetVersionRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetVersionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetVersionRequest";
            };

            return GetVersionRequest;
        })();

        core.GetVersionResponse = (function() {

            /**
             * Properties of a GetVersionResponse.
             * @memberof kritor.core
             * @interface IGetVersionResponse
             * @property {string|null} [version] GetVersionResponse version
             * @property {string|null} [appName] GetVersionResponse appName
             */

            /**
             * Constructs a new GetVersionResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetVersionResponse.
             * @implements IGetVersionResponse
             * @constructor
             * @param {kritor.core.IGetVersionResponse=} [properties] Properties to set
             */
            function GetVersionResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetVersionResponse version.
             * @member {string} version
             * @memberof kritor.core.GetVersionResponse
             * @instance
             */
            GetVersionResponse.prototype.version = "";

            /**
             * GetVersionResponse appName.
             * @member {string} appName
             * @memberof kritor.core.GetVersionResponse
             * @instance
             */
            GetVersionResponse.prototype.appName = "";

            /**
             * Creates a new GetVersionResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse=} [properties] Properties to set
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse instance
             */
            GetVersionResponse.create = function create(properties) {
                return new GetVersionResponse(properties);
            };

            /**
             * Encodes the specified GetVersionResponse message. Does not implicitly {@link kritor.core.GetVersionResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse} message GetVersionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.appName != null && Object.hasOwnProperty.call(message, "appName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.appName);
                return writer;
            };

            /**
             * Encodes the specified GetVersionResponse message, length delimited. Does not implicitly {@link kritor.core.GetVersionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse} message GetVersionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetVersionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetVersionResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.version = reader.string();
                            break;
                        }
                    case 2: {
                            message.appName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetVersionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetVersionResponse message.
             * @function verify
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetVersionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.appName != null && message.hasOwnProperty("appName"))
                    if (!$util.isString(message.appName))
                        return "appName: string expected";
                return null;
            };

            /**
             * Creates a GetVersionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             */
            GetVersionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetVersionResponse)
                    return object;
                let message = new $root.kritor.core.GetVersionResponse();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.appName != null)
                    message.appName = String(object.appName);
                return message;
            };

            /**
             * Creates a plain object from a GetVersionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.GetVersionResponse} message GetVersionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetVersionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.version = "";
                    object.appName = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.appName != null && message.hasOwnProperty("appName"))
                    object.appName = message.appName;
                return object;
            };

            /**
             * Converts this GetVersionResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetVersionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetVersionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetVersionResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetVersionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetVersionResponse";
            };

            return GetVersionResponse;
        })();

        core.ClearCacheRequest = (function() {

            /**
             * Properties of a ClearCacheRequest.
             * @memberof kritor.core
             * @interface IClearCacheRequest
             */

            /**
             * Constructs a new ClearCacheRequest.
             * @memberof kritor.core
             * @classdesc Represents a ClearCacheRequest.
             * @implements IClearCacheRequest
             * @constructor
             * @param {kritor.core.IClearCacheRequest=} [properties] Properties to set
             */
            function ClearCacheRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearCacheRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {kritor.core.IClearCacheRequest=} [properties] Properties to set
             * @returns {kritor.core.ClearCacheRequest} ClearCacheRequest instance
             */
            ClearCacheRequest.create = function create(properties) {
                return new ClearCacheRequest(properties);
            };

            /**
             * Encodes the specified ClearCacheRequest message. Does not implicitly {@link kritor.core.ClearCacheRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {kritor.core.IClearCacheRequest} message ClearCacheRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearCacheRequest message, length delimited. Does not implicitly {@link kritor.core.ClearCacheRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {kritor.core.IClearCacheRequest} message ClearCacheRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearCacheRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.ClearCacheRequest} ClearCacheRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.ClearCacheRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearCacheRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.ClearCacheRequest} ClearCacheRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearCacheRequest message.
             * @function verify
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearCacheRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearCacheRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.ClearCacheRequest} ClearCacheRequest
             */
            ClearCacheRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.ClearCacheRequest)
                    return object;
                return new $root.kritor.core.ClearCacheRequest();
            };

            /**
             * Creates a plain object from a ClearCacheRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {kritor.core.ClearCacheRequest} message ClearCacheRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearCacheRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearCacheRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.ClearCacheRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearCacheRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearCacheRequest
             * @function getTypeUrl
             * @memberof kritor.core.ClearCacheRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearCacheRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.ClearCacheRequest";
            };

            return ClearCacheRequest;
        })();

        core.ClearCacheResponse = (function() {

            /**
             * Properties of a ClearCacheResponse.
             * @memberof kritor.core
             * @interface IClearCacheResponse
             */

            /**
             * Constructs a new ClearCacheResponse.
             * @memberof kritor.core
             * @classdesc Represents a ClearCacheResponse.
             * @implements IClearCacheResponse
             * @constructor
             * @param {kritor.core.IClearCacheResponse=} [properties] Properties to set
             */
            function ClearCacheResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearCacheResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {kritor.core.IClearCacheResponse=} [properties] Properties to set
             * @returns {kritor.core.ClearCacheResponse} ClearCacheResponse instance
             */
            ClearCacheResponse.create = function create(properties) {
                return new ClearCacheResponse(properties);
            };

            /**
             * Encodes the specified ClearCacheResponse message. Does not implicitly {@link kritor.core.ClearCacheResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {kritor.core.IClearCacheResponse} message ClearCacheResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearCacheResponse message, length delimited. Does not implicitly {@link kritor.core.ClearCacheResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {kritor.core.IClearCacheResponse} message ClearCacheResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearCacheResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.ClearCacheResponse} ClearCacheResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.ClearCacheResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearCacheResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.ClearCacheResponse} ClearCacheResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearCacheResponse message.
             * @function verify
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearCacheResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearCacheResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.ClearCacheResponse} ClearCacheResponse
             */
            ClearCacheResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.ClearCacheResponse)
                    return object;
                return new $root.kritor.core.ClearCacheResponse();
            };

            /**
             * Creates a plain object from a ClearCacheResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {kritor.core.ClearCacheResponse} message ClearCacheResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearCacheResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearCacheResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.ClearCacheResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearCacheResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearCacheResponse
             * @function getTypeUrl
             * @memberof kritor.core.ClearCacheResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearCacheResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.ClearCacheResponse";
            };

            return ClearCacheResponse;
        })();

        core.DownloadFileRequest = (function() {

            /**
             * Properties of a DownloadFileRequest.
             * @memberof kritor.core
             * @interface IDownloadFileRequest
             * @property {string|null} [url] DownloadFileRequest url
             * @property {string|null} [base64] DownloadFileRequest base64
             * @property {string|null} [rootPath] DownloadFileRequest rootPath
             * @property {string|null} [fileName] DownloadFileRequest fileName
             * @property {number|null} [threadCnt] DownloadFileRequest threadCnt
             * @property {string|null} [headers] DownloadFileRequest headers
             */

            /**
             * Constructs a new DownloadFileRequest.
             * @memberof kritor.core
             * @classdesc Represents a DownloadFileRequest.
             * @implements IDownloadFileRequest
             * @constructor
             * @param {kritor.core.IDownloadFileRequest=} [properties] Properties to set
             */
            function DownloadFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileRequest url.
             * @member {string|null|undefined} url
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.url = null;

            /**
             * DownloadFileRequest base64.
             * @member {string|null|undefined} base64
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.base64 = null;

            /**
             * DownloadFileRequest rootPath.
             * @member {string|null|undefined} rootPath
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.rootPath = null;

            /**
             * DownloadFileRequest fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.fileName = null;

            /**
             * DownloadFileRequest threadCnt.
             * @member {number|null|undefined} threadCnt
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.threadCnt = null;

            /**
             * DownloadFileRequest headers.
             * @member {string|null|undefined} headers
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.headers = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * DownloadFileRequest _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _base64.
             * @member {"base64"|undefined} _base64
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_base64", {
                get: $util.oneOfGetter($oneOfFields = ["base64"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _rootPath.
             * @member {"rootPath"|undefined} _rootPath
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_rootPath", {
                get: $util.oneOfGetter($oneOfFields = ["rootPath"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _fileName.
             * @member {"fileName"|undefined} _fileName
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_fileName", {
                get: $util.oneOfGetter($oneOfFields = ["fileName"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _threadCnt.
             * @member {"threadCnt"|undefined} _threadCnt
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_threadCnt", {
                get: $util.oneOfGetter($oneOfFields = ["threadCnt"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _headers.
             * @member {"headers"|undefined} _headers
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_headers", {
                get: $util.oneOfGetter($oneOfFields = ["headers"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new DownloadFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest=} [properties] Properties to set
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest instance
             */
            DownloadFileRequest.create = function create(properties) {
                return new DownloadFileRequest(properties);
            };

            /**
             * Encodes the specified DownloadFileRequest message. Does not implicitly {@link kritor.core.DownloadFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.base64 != null && Object.hasOwnProperty.call(message, "base64"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.base64);
                if (message.rootPath != null && Object.hasOwnProperty.call(message, "rootPath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.rootPath);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
                if (message.threadCnt != null && Object.hasOwnProperty.call(message, "threadCnt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.threadCnt);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.headers);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileRequest message, length delimited. Does not implicitly {@link kritor.core.DownloadFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.DownloadFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.base64 = reader.string();
                            break;
                        }
                    case 3: {
                            message.rootPath = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 5: {
                            message.threadCnt = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.headers = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileRequest message.
             * @function verify
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.base64 != null && message.hasOwnProperty("base64")) {
                    properties._base64 = 1;
                    if (!$util.isString(message.base64))
                        return "base64: string expected";
                }
                if (message.rootPath != null && message.hasOwnProperty("rootPath")) {
                    properties._rootPath = 1;
                    if (!$util.isString(message.rootPath))
                        return "rootPath: string expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    properties._fileName = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.threadCnt != null && message.hasOwnProperty("threadCnt")) {
                    properties._threadCnt = 1;
                    if (!$util.isInteger(message.threadCnt))
                        return "threadCnt: integer expected";
                }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    properties._headers = 1;
                    if (!$util.isString(message.headers))
                        return "headers: string expected";
                }
                return null;
            };

            /**
             * Creates a DownloadFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             */
            DownloadFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.DownloadFileRequest)
                    return object;
                let message = new $root.kritor.core.DownloadFileRequest();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.base64 != null)
                    message.base64 = String(object.base64);
                if (object.rootPath != null)
                    message.rootPath = String(object.rootPath);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.threadCnt != null)
                    message.threadCnt = object.threadCnt >>> 0;
                if (object.headers != null)
                    message.headers = String(object.headers);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.DownloadFileRequest} message DownloadFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.base64 != null && message.hasOwnProperty("base64")) {
                    object.base64 = message.base64;
                    if (options.oneofs)
                        object._base64 = "base64";
                }
                if (message.rootPath != null && message.hasOwnProperty("rootPath")) {
                    object.rootPath = message.rootPath;
                    if (options.oneofs)
                        object._rootPath = "rootPath";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object._fileName = "fileName";
                }
                if (message.threadCnt != null && message.hasOwnProperty("threadCnt")) {
                    object.threadCnt = message.threadCnt;
                    if (options.oneofs)
                        object._threadCnt = "threadCnt";
                }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    object.headers = message.headers;
                    if (options.oneofs)
                        object._headers = "headers";
                }
                return object;
            };

            /**
             * Converts this DownloadFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileRequest
             * @function getTypeUrl
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.DownloadFileRequest";
            };

            return DownloadFileRequest;
        })();

        core.DownloadFileResponse = (function() {

            /**
             * Properties of a DownloadFileResponse.
             * @memberof kritor.core
             * @interface IDownloadFileResponse
             * @property {string|null} [fileAbsolutePath] DownloadFileResponse fileAbsolutePath
             * @property {string|null} [fileMd5] DownloadFileResponse fileMd5
             */

            /**
             * Constructs a new DownloadFileResponse.
             * @memberof kritor.core
             * @classdesc Represents a DownloadFileResponse.
             * @implements IDownloadFileResponse
             * @constructor
             * @param {kritor.core.IDownloadFileResponse=} [properties] Properties to set
             */
            function DownloadFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileResponse fileAbsolutePath.
             * @member {string} fileAbsolutePath
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             */
            DownloadFileResponse.prototype.fileAbsolutePath = "";

            /**
             * DownloadFileResponse fileMd5.
             * @member {string} fileMd5
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             */
            DownloadFileResponse.prototype.fileMd5 = "";

            /**
             * Creates a new DownloadFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse=} [properties] Properties to set
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse instance
             */
            DownloadFileResponse.create = function create(properties) {
                return new DownloadFileResponse(properties);
            };

            /**
             * Encodes the specified DownloadFileResponse message. Does not implicitly {@link kritor.core.DownloadFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse} message DownloadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileAbsolutePath != null && Object.hasOwnProperty.call(message, "fileAbsolutePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileAbsolutePath);
                if (message.fileMd5 != null && Object.hasOwnProperty.call(message, "fileMd5"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileMd5);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileResponse message, length delimited. Does not implicitly {@link kritor.core.DownloadFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse} message DownloadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.DownloadFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileAbsolutePath = reader.string();
                            break;
                        }
                    case 2: {
                            message.fileMd5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileResponse message.
             * @function verify
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileAbsolutePath != null && message.hasOwnProperty("fileAbsolutePath"))
                    if (!$util.isString(message.fileAbsolutePath))
                        return "fileAbsolutePath: string expected";
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5"))
                    if (!$util.isString(message.fileMd5))
                        return "fileMd5: string expected";
                return null;
            };

            /**
             * Creates a DownloadFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             */
            DownloadFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.DownloadFileResponse)
                    return object;
                let message = new $root.kritor.core.DownloadFileResponse();
                if (object.fileAbsolutePath != null)
                    message.fileAbsolutePath = String(object.fileAbsolutePath);
                if (object.fileMd5 != null)
                    message.fileMd5 = String(object.fileMd5);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.DownloadFileResponse} message DownloadFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fileAbsolutePath = "";
                    object.fileMd5 = "";
                }
                if (message.fileAbsolutePath != null && message.hasOwnProperty("fileAbsolutePath"))
                    object.fileAbsolutePath = message.fileAbsolutePath;
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5"))
                    object.fileMd5 = message.fileMd5;
                return object;
            };

            /**
             * Converts this DownloadFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileResponse
             * @function getTypeUrl
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.DownloadFileResponse";
            };

            return DownloadFileResponse;
        })();

        core.GetCurrentAccountRequest = (function() {

            /**
             * Properties of a GetCurrentAccountRequest.
             * @memberof kritor.core
             * @interface IGetCurrentAccountRequest
             */

            /**
             * Constructs a new GetCurrentAccountRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetCurrentAccountRequest.
             * @implements IGetCurrentAccountRequest
             * @constructor
             * @param {kritor.core.IGetCurrentAccountRequest=} [properties] Properties to set
             */
            function GetCurrentAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetCurrentAccountRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest=} [properties] Properties to set
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest instance
             */
            GetCurrentAccountRequest.create = function create(properties) {
                return new GetCurrentAccountRequest(properties);
            };

            /**
             * Encodes the specified GetCurrentAccountRequest message. Does not implicitly {@link kritor.core.GetCurrentAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest} message GetCurrentAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetCurrentAccountRequest message, length delimited. Does not implicitly {@link kritor.core.GetCurrentAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest} message GetCurrentAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCurrentAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetCurrentAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCurrentAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCurrentAccountRequest message.
             * @function verify
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCurrentAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetCurrentAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             */
            GetCurrentAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetCurrentAccountRequest)
                    return object;
                return new $root.kritor.core.GetCurrentAccountRequest();
            };

            /**
             * Creates a plain object from a GetCurrentAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.GetCurrentAccountRequest} message GetCurrentAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCurrentAccountRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetCurrentAccountRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetCurrentAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCurrentAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCurrentAccountRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCurrentAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetCurrentAccountRequest";
            };

            return GetCurrentAccountRequest;
        })();

        core.GetCurrentAccountResponse = (function() {

            /**
             * Properties of a GetCurrentAccountResponse.
             * @memberof kritor.core
             * @interface IGetCurrentAccountResponse
             * @property {string|null} [accountUid] GetCurrentAccountResponse accountUid
             * @property {number|Long|null} [accountUin] GetCurrentAccountResponse accountUin
             * @property {string|null} [accountName] GetCurrentAccountResponse accountName
             */

            /**
             * Constructs a new GetCurrentAccountResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetCurrentAccountResponse.
             * @implements IGetCurrentAccountResponse
             * @constructor
             * @param {kritor.core.IGetCurrentAccountResponse=} [properties] Properties to set
             */
            function GetCurrentAccountResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCurrentAccountResponse accountUid.
             * @member {string} accountUid
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.accountUid = "";

            /**
             * GetCurrentAccountResponse accountUin.
             * @member {number|Long} accountUin
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.accountUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetCurrentAccountResponse accountName.
             * @member {string} accountName
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.accountName = "";

            /**
             * Creates a new GetCurrentAccountResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse=} [properties] Properties to set
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse instance
             */
            GetCurrentAccountResponse.create = function create(properties) {
                return new GetCurrentAccountResponse(properties);
            };

            /**
             * Encodes the specified GetCurrentAccountResponse message. Does not implicitly {@link kritor.core.GetCurrentAccountResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse} message GetCurrentAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.accountUid);
                if (message.accountUin != null && Object.hasOwnProperty.call(message, "accountUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accountUin);
                if (message.accountName != null && Object.hasOwnProperty.call(message, "accountName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.accountName);
                return writer;
            };

            /**
             * Encodes the specified GetCurrentAccountResponse message, length delimited. Does not implicitly {@link kritor.core.GetCurrentAccountResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse} message GetCurrentAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCurrentAccountResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetCurrentAccountResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.accountUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.accountName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCurrentAccountResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCurrentAccountResponse message.
             * @function verify
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCurrentAccountResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                    if (!$util.isString(message.accountUid))
                        return "accountUid: string expected";
                if (message.accountUin != null && message.hasOwnProperty("accountUin"))
                    if (!$util.isInteger(message.accountUin) && !(message.accountUin && $util.isInteger(message.accountUin.low) && $util.isInteger(message.accountUin.high)))
                        return "accountUin: integer|Long expected";
                if (message.accountName != null && message.hasOwnProperty("accountName"))
                    if (!$util.isString(message.accountName))
                        return "accountName: string expected";
                return null;
            };

            /**
             * Creates a GetCurrentAccountResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             */
            GetCurrentAccountResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetCurrentAccountResponse)
                    return object;
                let message = new $root.kritor.core.GetCurrentAccountResponse();
                if (object.accountUid != null)
                    message.accountUid = String(object.accountUid);
                if (object.accountUin != null)
                    if ($util.Long)
                        (message.accountUin = $util.Long.fromValue(object.accountUin)).unsigned = true;
                    else if (typeof object.accountUin === "string")
                        message.accountUin = parseInt(object.accountUin, 10);
                    else if (typeof object.accountUin === "number")
                        message.accountUin = object.accountUin;
                    else if (typeof object.accountUin === "object")
                        message.accountUin = new $util.LongBits(object.accountUin.low >>> 0, object.accountUin.high >>> 0).toNumber(true);
                if (object.accountName != null)
                    message.accountName = String(object.accountName);
                return message;
            };

            /**
             * Creates a plain object from a GetCurrentAccountResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.GetCurrentAccountResponse} message GetCurrentAccountResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCurrentAccountResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.accountUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.accountUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.accountUin = options.longs === String ? "0" : 0;
                    object.accountName = "";
                }
                if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                    object.accountUid = message.accountUid;
                if (message.accountUin != null && message.hasOwnProperty("accountUin"))
                    if (typeof message.accountUin === "number")
                        object.accountUin = options.longs === String ? String(message.accountUin) : message.accountUin;
                    else
                        object.accountUin = options.longs === String ? $util.Long.prototype.toString.call(message.accountUin) : options.longs === Number ? new $util.LongBits(message.accountUin.low >>> 0, message.accountUin.high >>> 0).toNumber(true) : message.accountUin;
                if (message.accountName != null && message.hasOwnProperty("accountName"))
                    object.accountName = message.accountName;
                return object;
            };

            /**
             * Converts this GetCurrentAccountResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCurrentAccountResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCurrentAccountResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCurrentAccountResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetCurrentAccountResponse";
            };

            return GetCurrentAccountResponse;
        })();

        core.SwitchAccountRequest = (function() {

            /**
             * Properties of a SwitchAccountRequest.
             * @memberof kritor.core
             * @interface ISwitchAccountRequest
             * @property {string|null} [accountUid] SwitchAccountRequest accountUid
             * @property {number|Long|null} [accountUin] SwitchAccountRequest accountUin
             * @property {string|null} [superTicket] SwitchAccountRequest superTicket
             */

            /**
             * Constructs a new SwitchAccountRequest.
             * @memberof kritor.core
             * @classdesc Represents a SwitchAccountRequest.
             * @implements ISwitchAccountRequest
             * @constructor
             * @param {kritor.core.ISwitchAccountRequest=} [properties] Properties to set
             */
            function SwitchAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SwitchAccountRequest accountUid.
             * @member {string|null|undefined} accountUid
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.accountUid = null;

            /**
             * SwitchAccountRequest accountUin.
             * @member {number|Long|null|undefined} accountUin
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.accountUin = null;

            /**
             * SwitchAccountRequest superTicket.
             * @member {string} superTicket
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.superTicket = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SwitchAccountRequest account.
             * @member {"accountUid"|"accountUin"|undefined} account
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            Object.defineProperty(SwitchAccountRequest.prototype, "account", {
                get: $util.oneOfGetter($oneOfFields = ["accountUid", "accountUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SwitchAccountRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest=} [properties] Properties to set
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest instance
             */
            SwitchAccountRequest.create = function create(properties) {
                return new SwitchAccountRequest(properties);
            };

            /**
             * Encodes the specified SwitchAccountRequest message. Does not implicitly {@link kritor.core.SwitchAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest} message SwitchAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.accountUid);
                if (message.accountUin != null && Object.hasOwnProperty.call(message, "accountUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accountUin);
                if (message.superTicket != null && Object.hasOwnProperty.call(message, "superTicket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.superTicket);
                return writer;
            };

            /**
             * Encodes the specified SwitchAccountRequest message, length delimited. Does not implicitly {@link kritor.core.SwitchAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest} message SwitchAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.SwitchAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.accountUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.superTicket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchAccountRequest message.
             * @function verify
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    properties.account = 1;
                    if (!$util.isString(message.accountUid))
                        return "accountUid: string expected";
                }
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    if (properties.account === 1)
                        return "account: multiple values";
                    properties.account = 1;
                    if (!$util.isInteger(message.accountUin) && !(message.accountUin && $util.isInteger(message.accountUin.low) && $util.isInteger(message.accountUin.high)))
                        return "accountUin: integer|Long expected";
                }
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    if (!$util.isString(message.superTicket))
                        return "superTicket: string expected";
                return null;
            };

            /**
             * Creates a SwitchAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             */
            SwitchAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.SwitchAccountRequest)
                    return object;
                let message = new $root.kritor.core.SwitchAccountRequest();
                if (object.accountUid != null)
                    message.accountUid = String(object.accountUid);
                if (object.accountUin != null)
                    if ($util.Long)
                        (message.accountUin = $util.Long.fromValue(object.accountUin)).unsigned = true;
                    else if (typeof object.accountUin === "string")
                        message.accountUin = parseInt(object.accountUin, 10);
                    else if (typeof object.accountUin === "number")
                        message.accountUin = object.accountUin;
                    else if (typeof object.accountUin === "object")
                        message.accountUin = new $util.LongBits(object.accountUin.low >>> 0, object.accountUin.high >>> 0).toNumber(true);
                if (object.superTicket != null)
                    message.superTicket = String(object.superTicket);
                return message;
            };

            /**
             * Creates a plain object from a SwitchAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.SwitchAccountRequest} message SwitchAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchAccountRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.superTicket = "";
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    object.accountUid = message.accountUid;
                    if (options.oneofs)
                        object.account = "accountUid";
                }
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    if (typeof message.accountUin === "number")
                        object.accountUin = options.longs === String ? String(message.accountUin) : message.accountUin;
                    else
                        object.accountUin = options.longs === String ? $util.Long.prototype.toString.call(message.accountUin) : options.longs === Number ? new $util.LongBits(message.accountUin.low >>> 0, message.accountUin.high >>> 0).toNumber(true) : message.accountUin;
                    if (options.oneofs)
                        object.account = "accountUin";
                }
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    object.superTicket = message.superTicket;
                return object;
            };

            /**
             * Converts this SwitchAccountRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchAccountRequest
             * @function getTypeUrl
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.SwitchAccountRequest";
            };

            return SwitchAccountRequest;
        })();

        core.SwitchAccountResponse = (function() {

            /**
             * Properties of a SwitchAccountResponse.
             * @memberof kritor.core
             * @interface ISwitchAccountResponse
             */

            /**
             * Constructs a new SwitchAccountResponse.
             * @memberof kritor.core
             * @classdesc Represents a SwitchAccountResponse.
             * @implements ISwitchAccountResponse
             * @constructor
             * @param {kritor.core.ISwitchAccountResponse=} [properties] Properties to set
             */
            function SwitchAccountResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SwitchAccountResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse=} [properties] Properties to set
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse instance
             */
            SwitchAccountResponse.create = function create(properties) {
                return new SwitchAccountResponse(properties);
            };

            /**
             * Encodes the specified SwitchAccountResponse message. Does not implicitly {@link kritor.core.SwitchAccountResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse} message SwitchAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SwitchAccountResponse message, length delimited. Does not implicitly {@link kritor.core.SwitchAccountResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse} message SwitchAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchAccountResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.SwitchAccountResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchAccountResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchAccountResponse message.
             * @function verify
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchAccountResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SwitchAccountResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             */
            SwitchAccountResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.SwitchAccountResponse)
                    return object;
                return new $root.kritor.core.SwitchAccountResponse();
            };

            /**
             * Creates a plain object from a SwitchAccountResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.SwitchAccountResponse} message SwitchAccountResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchAccountResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SwitchAccountResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.SwitchAccountResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchAccountResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchAccountResponse
             * @function getTypeUrl
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchAccountResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.SwitchAccountResponse";
            };

            return SwitchAccountResponse;
        })();

        core.GetDeviceBatteryRequest = (function() {

            /**
             * Properties of a GetDeviceBatteryRequest.
             * @memberof kritor.core
             * @interface IGetDeviceBatteryRequest
             */

            /**
             * Constructs a new GetDeviceBatteryRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetDeviceBatteryRequest.
             * @implements IGetDeviceBatteryRequest
             * @constructor
             * @param {kritor.core.IGetDeviceBatteryRequest=} [properties] Properties to set
             */
            function GetDeviceBatteryRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetDeviceBatteryRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {kritor.core.IGetDeviceBatteryRequest=} [properties] Properties to set
             * @returns {kritor.core.GetDeviceBatteryRequest} GetDeviceBatteryRequest instance
             */
            GetDeviceBatteryRequest.create = function create(properties) {
                return new GetDeviceBatteryRequest(properties);
            };

            /**
             * Encodes the specified GetDeviceBatteryRequest message. Does not implicitly {@link kritor.core.GetDeviceBatteryRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {kritor.core.IGetDeviceBatteryRequest} message GetDeviceBatteryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetDeviceBatteryRequest message, length delimited. Does not implicitly {@link kritor.core.GetDeviceBatteryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {kritor.core.IGetDeviceBatteryRequest} message GetDeviceBatteryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceBatteryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetDeviceBatteryRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceBatteryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceBatteryRequest message.
             * @function verify
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceBatteryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetDeviceBatteryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             */
            GetDeviceBatteryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetDeviceBatteryRequest)
                    return object;
                return new $root.kritor.core.GetDeviceBatteryRequest();
            };

            /**
             * Creates a plain object from a GetDeviceBatteryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {kritor.core.GetDeviceBatteryRequest} message GetDeviceBatteryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceBatteryRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetDeviceBatteryRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceBatteryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceBatteryRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetDeviceBatteryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceBatteryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetDeviceBatteryRequest";
            };

            return GetDeviceBatteryRequest;
        })();

        core.GetDeviceBatteryResponse = (function() {

            /**
             * Properties of a GetDeviceBatteryResponse.
             * @memberof kritor.core
             * @interface IGetDeviceBatteryResponse
             * @property {number|null} [battery] GetDeviceBatteryResponse battery
             * @property {number|null} [scale] GetDeviceBatteryResponse scale
             * @property {number|null} [status] GetDeviceBatteryResponse status
             */

            /**
             * Constructs a new GetDeviceBatteryResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetDeviceBatteryResponse.
             * @implements IGetDeviceBatteryResponse
             * @constructor
             * @param {kritor.core.IGetDeviceBatteryResponse=} [properties] Properties to set
             */
            function GetDeviceBatteryResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceBatteryResponse battery.
             * @member {number} battery
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.battery = 0;

            /**
             * GetDeviceBatteryResponse scale.
             * @member {number} scale
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.scale = 0;

            /**
             * GetDeviceBatteryResponse status.
             * @member {number} status
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.status = 0;

            /**
             * Creates a new GetDeviceBatteryResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {kritor.core.IGetDeviceBatteryResponse=} [properties] Properties to set
             * @returns {kritor.core.GetDeviceBatteryResponse} GetDeviceBatteryResponse instance
             */
            GetDeviceBatteryResponse.create = function create(properties) {
                return new GetDeviceBatteryResponse(properties);
            };

            /**
             * Encodes the specified GetDeviceBatteryResponse message. Does not implicitly {@link kritor.core.GetDeviceBatteryResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {kritor.core.IGetDeviceBatteryResponse} message GetDeviceBatteryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.battery != null && Object.hasOwnProperty.call(message, "battery"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battery);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.scale);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.status);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceBatteryResponse message, length delimited. Does not implicitly {@link kritor.core.GetDeviceBatteryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {kritor.core.IGetDeviceBatteryResponse} message GetDeviceBatteryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceBatteryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetDeviceBatteryResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.battery = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.scale = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.status = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceBatteryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceBatteryResponse message.
             * @function verify
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceBatteryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.battery != null && message.hasOwnProperty("battery"))
                    if (!$util.isInteger(message.battery))
                        return "battery: integer expected";
                if (message.scale != null && message.hasOwnProperty("scale"))
                    if (!$util.isInteger(message.scale))
                        return "scale: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                return null;
            };

            /**
             * Creates a GetDeviceBatteryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             */
            GetDeviceBatteryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetDeviceBatteryResponse)
                    return object;
                let message = new $root.kritor.core.GetDeviceBatteryResponse();
                if (object.battery != null)
                    message.battery = object.battery >>> 0;
                if (object.scale != null)
                    message.scale = object.scale >>> 0;
                if (object.status != null)
                    message.status = object.status >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceBatteryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {kritor.core.GetDeviceBatteryResponse} message GetDeviceBatteryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceBatteryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.battery = 0;
                    object.scale = 0;
                    object.status = 0;
                }
                if (message.battery != null && message.hasOwnProperty("battery"))
                    object.battery = message.battery;
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = message.scale;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Converts this GetDeviceBatteryResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceBatteryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceBatteryResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetDeviceBatteryResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceBatteryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetDeviceBatteryResponse";
            };

            return GetDeviceBatteryResponse;
        })();

        return core;
    })();

    kritor.qsign = (function() {

        /**
         * Namespace qsign.
         * @memberof kritor
         * @namespace
         */
        const qsign = {};

        qsign.DeveloperService = (function() {

            /**
             * Constructs a new DeveloperService service.
             * @memberof kritor.qsign
             * @classdesc Represents a DeveloperService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DeveloperService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DeveloperService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DeveloperService;

            /**
             * Creates new DeveloperService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.qsign.DeveloperService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DeveloperService} RPC service. Useful where requests and/or responses are streamed.
             */
            DeveloperService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.qsign.DeveloperService#sign}.
             * @memberof kritor.qsign.DeveloperService
             * @typedef SignCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.qsign.SignResponse} [response] SignResponse
             */

            /**
             * Calls Sign.
             * @function sign
             * @memberof kritor.qsign.DeveloperService
             * @instance
             * @param {kritor.qsign.ISignRequest} request SignRequest message or plain object
             * @param {kritor.qsign.DeveloperService.SignCallback} callback Node-style callback called with the error, if any, and SignResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.sign = function sign(request, callback) {
                return this.rpcCall(sign, $root.kritor.qsign.SignRequest, $root.kritor.qsign.SignResponse, request, callback);
            }, "name", { value: "Sign" });

            /**
             * Calls Sign.
             * @function sign
             * @memberof kritor.qsign.DeveloperService
             * @instance
             * @param {kritor.qsign.ISignRequest} request SignRequest message or plain object
             * @returns {Promise<kritor.qsign.SignResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.qsign.DeveloperService#energy}.
             * @memberof kritor.qsign.DeveloperService
             * @typedef EnergyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.qsign.EnergyResponse} [response] EnergyResponse
             */

            /**
             * Calls Energy.
             * @function energy
             * @memberof kritor.qsign.DeveloperService
             * @instance
             * @param {kritor.qsign.IEnergyRequest} request EnergyRequest message or plain object
             * @param {kritor.qsign.DeveloperService.EnergyCallback} callback Node-style callback called with the error, if any, and EnergyResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.energy = function energy(request, callback) {
                return this.rpcCall(energy, $root.kritor.qsign.EnergyRequest, $root.kritor.qsign.EnergyResponse, request, callback);
            }, "name", { value: "Energy" });

            /**
             * Calls Energy.
             * @function energy
             * @memberof kritor.qsign.DeveloperService
             * @instance
             * @param {kritor.qsign.IEnergyRequest} request EnergyRequest message or plain object
             * @returns {Promise<kritor.qsign.EnergyResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.qsign.DeveloperService#sendPacket}.
             * @memberof kritor.qsign.DeveloperService
             * @typedef SendPacketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.qsign.SendPacketResponse} [response] SendPacketResponse
             */

            /**
             * Calls SendPacket.
             * @function sendPacket
             * @memberof kritor.qsign.DeveloperService
             * @instance
             * @param {kritor.qsign.ISendPacketRequest} request SendPacketRequest message or plain object
             * @param {kritor.qsign.DeveloperService.SendPacketCallback} callback Node-style callback called with the error, if any, and SendPacketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.sendPacket = function sendPacket(request, callback) {
                return this.rpcCall(sendPacket, $root.kritor.qsign.SendPacketRequest, $root.kritor.qsign.SendPacketResponse, request, callback);
            }, "name", { value: "SendPacket" });

            /**
             * Calls SendPacket.
             * @function sendPacket
             * @memberof kritor.qsign.DeveloperService
             * @instance
             * @param {kritor.qsign.ISendPacketRequest} request SendPacketRequest message or plain object
             * @returns {Promise<kritor.qsign.SendPacketResponse>} Promise
             * @variation 2
             */

            return DeveloperService;
        })();

        qsign.SignRequest = (function() {

            /**
             * Properties of a SignRequest.
             * @memberof kritor.qsign
             * @interface ISignRequest
             * @property {string|null} [uin] SignRequest uin
             * @property {string|null} [command] SignRequest command
             * @property {number|null} [seq] SignRequest seq
             * @property {Uint8Array|null} [buffer] SignRequest buffer
             * @property {string|null} [qua] SignRequest qua
             */

            /**
             * Constructs a new SignRequest.
             * @memberof kritor.qsign
             * @classdesc Represents a SignRequest.
             * @implements ISignRequest
             * @constructor
             * @param {kritor.qsign.ISignRequest=} [properties] Properties to set
             */
            function SignRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignRequest uin.
             * @member {string} uin
             * @memberof kritor.qsign.SignRequest
             * @instance
             */
            SignRequest.prototype.uin = "";

            /**
             * SignRequest command.
             * @member {string} command
             * @memberof kritor.qsign.SignRequest
             * @instance
             */
            SignRequest.prototype.command = "";

            /**
             * SignRequest seq.
             * @member {number} seq
             * @memberof kritor.qsign.SignRequest
             * @instance
             */
            SignRequest.prototype.seq = 0;

            /**
             * SignRequest buffer.
             * @member {Uint8Array} buffer
             * @memberof kritor.qsign.SignRequest
             * @instance
             */
            SignRequest.prototype.buffer = $util.newBuffer([]);

            /**
             * SignRequest qua.
             * @member {string|null|undefined} qua
             * @memberof kritor.qsign.SignRequest
             * @instance
             */
            SignRequest.prototype.qua = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SignRequest _qua.
             * @member {"qua"|undefined} _qua
             * @memberof kritor.qsign.SignRequest
             * @instance
             */
            Object.defineProperty(SignRequest.prototype, "_qua", {
                get: $util.oneOfGetter($oneOfFields = ["qua"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SignRequest instance using the specified properties.
             * @function create
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {kritor.qsign.ISignRequest=} [properties] Properties to set
             * @returns {kritor.qsign.SignRequest} SignRequest instance
             */
            SignRequest.create = function create(properties) {
                return new SignRequest(properties);
            };

            /**
             * Encodes the specified SignRequest message. Does not implicitly {@link kritor.qsign.SignRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {kritor.qsign.ISignRequest} message SignRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uin);
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.command);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.seq);
                if (message.buffer != null && Object.hasOwnProperty.call(message, "buffer"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.buffer);
                if (message.qua != null && Object.hasOwnProperty.call(message, "qua"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.qua);
                return writer;
            };

            /**
             * Encodes the specified SignRequest message, length delimited. Does not implicitly {@link kritor.qsign.SignRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {kritor.qsign.ISignRequest} message SignRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.qsign.SignRequest} SignRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.qsign.SignRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uin = reader.string();
                            break;
                        }
                    case 2: {
                            message.command = reader.string();
                            break;
                        }
                    case 3: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.buffer = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.qua = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.qsign.SignRequest} SignRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignRequest message.
             * @function verify
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isString(message.uin))
                        return "uin: string expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.buffer != null && message.hasOwnProperty("buffer"))
                    if (!(message.buffer && typeof message.buffer.length === "number" || $util.isString(message.buffer)))
                        return "buffer: buffer expected";
                if (message.qua != null && message.hasOwnProperty("qua")) {
                    properties._qua = 1;
                    if (!$util.isString(message.qua))
                        return "qua: string expected";
                }
                return null;
            };

            /**
             * Creates a SignRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.qsign.SignRequest} SignRequest
             */
            SignRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.qsign.SignRequest)
                    return object;
                let message = new $root.kritor.qsign.SignRequest();
                if (object.uin != null)
                    message.uin = String(object.uin);
                if (object.command != null)
                    message.command = String(object.command);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                if (object.buffer != null)
                    if (typeof object.buffer === "string")
                        $util.base64.decode(object.buffer, message.buffer = $util.newBuffer($util.base64.length(object.buffer)), 0);
                    else if (object.buffer.length >= 0)
                        message.buffer = object.buffer;
                if (object.qua != null)
                    message.qua = String(object.qua);
                return message;
            };

            /**
             * Creates a plain object from a SignRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {kritor.qsign.SignRequest} message SignRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uin = "";
                    object.command = "";
                    object.seq = 0;
                    if (options.bytes === String)
                        object.buffer = "";
                    else {
                        object.buffer = [];
                        if (options.bytes !== Array)
                            object.buffer = $util.newBuffer(object.buffer);
                    }
                }
                if (message.uin != null && message.hasOwnProperty("uin"))
                    object.uin = message.uin;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.buffer != null && message.hasOwnProperty("buffer"))
                    object.buffer = options.bytes === String ? $util.base64.encode(message.buffer, 0, message.buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.buffer) : message.buffer;
                if (message.qua != null && message.hasOwnProperty("qua")) {
                    object.qua = message.qua;
                    if (options.oneofs)
                        object._qua = "qua";
                }
                return object;
            };

            /**
             * Converts this SignRequest to JSON.
             * @function toJSON
             * @memberof kritor.qsign.SignRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SignRequest
             * @function getTypeUrl
             * @memberof kritor.qsign.SignRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SignRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.qsign.SignRequest";
            };

            return SignRequest;
        })();

        qsign.SignResponse = (function() {

            /**
             * Properties of a SignResponse.
             * @memberof kritor.qsign
             * @interface ISignResponse
             * @property {Uint8Array|null} [sign] SignResponse sign
             * @property {Uint8Array|null} [token] SignResponse token
             * @property {Uint8Array|null} [extra] SignResponse extra
             */

            /**
             * Constructs a new SignResponse.
             * @memberof kritor.qsign
             * @classdesc Represents a SignResponse.
             * @implements ISignResponse
             * @constructor
             * @param {kritor.qsign.ISignResponse=} [properties] Properties to set
             */
            function SignResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignResponse sign.
             * @member {Uint8Array} sign
             * @memberof kritor.qsign.SignResponse
             * @instance
             */
            SignResponse.prototype.sign = $util.newBuffer([]);

            /**
             * SignResponse token.
             * @member {Uint8Array} token
             * @memberof kritor.qsign.SignResponse
             * @instance
             */
            SignResponse.prototype.token = $util.newBuffer([]);

            /**
             * SignResponse extra.
             * @member {Uint8Array} extra
             * @memberof kritor.qsign.SignResponse
             * @instance
             */
            SignResponse.prototype.extra = $util.newBuffer([]);

            /**
             * Creates a new SignResponse instance using the specified properties.
             * @function create
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {kritor.qsign.ISignResponse=} [properties] Properties to set
             * @returns {kritor.qsign.SignResponse} SignResponse instance
             */
            SignResponse.create = function create(properties) {
                return new SignResponse(properties);
            };

            /**
             * Encodes the specified SignResponse message. Does not implicitly {@link kritor.qsign.SignResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {kritor.qsign.ISignResponse} message SignResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sign);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.token);
                if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.extra);
                return writer;
            };

            /**
             * Encodes the specified SignResponse message, length delimited. Does not implicitly {@link kritor.qsign.SignResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {kritor.qsign.ISignResponse} message SignResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.qsign.SignResponse} SignResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.qsign.SignResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sign = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.token = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.extra = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.qsign.SignResponse} SignResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignResponse message.
             * @function verify
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sign != null && message.hasOwnProperty("sign"))
                    if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                        return "sign: buffer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.extra != null && message.hasOwnProperty("extra"))
                    if (!(message.extra && typeof message.extra.length === "number" || $util.isString(message.extra)))
                        return "extra: buffer expected";
                return null;
            };

            /**
             * Creates a SignResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.qsign.SignResponse} SignResponse
             */
            SignResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.qsign.SignResponse)
                    return object;
                let message = new $root.kritor.qsign.SignResponse();
                if (object.sign != null)
                    if (typeof object.sign === "string")
                        $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                    else if (object.sign.length >= 0)
                        message.sign = object.sign;
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length >= 0)
                        message.token = object.token;
                if (object.extra != null)
                    if (typeof object.extra === "string")
                        $util.base64.decode(object.extra, message.extra = $util.newBuffer($util.base64.length(object.extra)), 0);
                    else if (object.extra.length >= 0)
                        message.extra = object.extra;
                return message;
            };

            /**
             * Creates a plain object from a SignResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {kritor.qsign.SignResponse} message SignResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.sign = "";
                    else {
                        object.sign = [];
                        if (options.bytes !== Array)
                            object.sign = $util.newBuffer(object.sign);
                    }
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    if (options.bytes === String)
                        object.extra = "";
                    else {
                        object.extra = [];
                        if (options.bytes !== Array)
                            object.extra = $util.newBuffer(object.extra);
                    }
                }
                if (message.sign != null && message.hasOwnProperty("sign"))
                    object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.extra != null && message.hasOwnProperty("extra"))
                    object.extra = options.bytes === String ? $util.base64.encode(message.extra, 0, message.extra.length) : options.bytes === Array ? Array.prototype.slice.call(message.extra) : message.extra;
                return object;
            };

            /**
             * Converts this SignResponse to JSON.
             * @function toJSON
             * @memberof kritor.qsign.SignResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SignResponse
             * @function getTypeUrl
             * @memberof kritor.qsign.SignResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SignResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.qsign.SignResponse";
            };

            return SignResponse;
        })();

        qsign.EnergyRequest = (function() {

            /**
             * Properties of an EnergyRequest.
             * @memberof kritor.qsign
             * @interface IEnergyRequest
             * @property {string|null} [data] EnergyRequest data
             * @property {Uint8Array|null} [salt] EnergyRequest salt
             */

            /**
             * Constructs a new EnergyRequest.
             * @memberof kritor.qsign
             * @classdesc Represents an EnergyRequest.
             * @implements IEnergyRequest
             * @constructor
             * @param {kritor.qsign.IEnergyRequest=} [properties] Properties to set
             */
            function EnergyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnergyRequest data.
             * @member {string} data
             * @memberof kritor.qsign.EnergyRequest
             * @instance
             */
            EnergyRequest.prototype.data = "";

            /**
             * EnergyRequest salt.
             * @member {Uint8Array} salt
             * @memberof kritor.qsign.EnergyRequest
             * @instance
             */
            EnergyRequest.prototype.salt = $util.newBuffer([]);

            /**
             * Creates a new EnergyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {kritor.qsign.IEnergyRequest=} [properties] Properties to set
             * @returns {kritor.qsign.EnergyRequest} EnergyRequest instance
             */
            EnergyRequest.create = function create(properties) {
                return new EnergyRequest(properties);
            };

            /**
             * Encodes the specified EnergyRequest message. Does not implicitly {@link kritor.qsign.EnergyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {kritor.qsign.IEnergyRequest} message EnergyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
                return writer;
            };

            /**
             * Encodes the specified EnergyRequest message, length delimited. Does not implicitly {@link kritor.qsign.EnergyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {kritor.qsign.IEnergyRequest} message EnergyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnergyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.qsign.EnergyRequest} EnergyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.qsign.EnergyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    case 3: {
                            message.salt = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnergyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.qsign.EnergyRequest} EnergyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnergyRequest message.
             * @function verify
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnergyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.salt != null && message.hasOwnProperty("salt"))
                    if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                        return "salt: buffer expected";
                return null;
            };

            /**
             * Creates an EnergyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.qsign.EnergyRequest} EnergyRequest
             */
            EnergyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.qsign.EnergyRequest)
                    return object;
                let message = new $root.kritor.qsign.EnergyRequest();
                if (object.data != null)
                    message.data = String(object.data);
                if (object.salt != null)
                    if (typeof object.salt === "string")
                        $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                    else if (object.salt.length >= 0)
                        message.salt = object.salt;
                return message;
            };

            /**
             * Creates a plain object from an EnergyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {kritor.qsign.EnergyRequest} message EnergyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnergyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.data = "";
                    if (options.bytes === String)
                        object.salt = "";
                    else {
                        object.salt = [];
                        if (options.bytes !== Array)
                            object.salt = $util.newBuffer(object.salt);
                    }
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.salt != null && message.hasOwnProperty("salt"))
                    object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
                return object;
            };

            /**
             * Converts this EnergyRequest to JSON.
             * @function toJSON
             * @memberof kritor.qsign.EnergyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnergyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnergyRequest
             * @function getTypeUrl
             * @memberof kritor.qsign.EnergyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnergyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.qsign.EnergyRequest";
            };

            return EnergyRequest;
        })();

        qsign.EnergyResponse = (function() {

            /**
             * Properties of an EnergyResponse.
             * @memberof kritor.qsign
             * @interface IEnergyResponse
             * @property {Uint8Array|null} [result] EnergyResponse result
             */

            /**
             * Constructs a new EnergyResponse.
             * @memberof kritor.qsign
             * @classdesc Represents an EnergyResponse.
             * @implements IEnergyResponse
             * @constructor
             * @param {kritor.qsign.IEnergyResponse=} [properties] Properties to set
             */
            function EnergyResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnergyResponse result.
             * @member {Uint8Array} result
             * @memberof kritor.qsign.EnergyResponse
             * @instance
             */
            EnergyResponse.prototype.result = $util.newBuffer([]);

            /**
             * Creates a new EnergyResponse instance using the specified properties.
             * @function create
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {kritor.qsign.IEnergyResponse=} [properties] Properties to set
             * @returns {kritor.qsign.EnergyResponse} EnergyResponse instance
             */
            EnergyResponse.create = function create(properties) {
                return new EnergyResponse(properties);
            };

            /**
             * Encodes the specified EnergyResponse message. Does not implicitly {@link kritor.qsign.EnergyResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {kritor.qsign.IEnergyResponse} message EnergyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.result);
                return writer;
            };

            /**
             * Encodes the specified EnergyResponse message, length delimited. Does not implicitly {@link kritor.qsign.EnergyResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {kritor.qsign.IEnergyResponse} message EnergyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnergyResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.qsign.EnergyResponse} EnergyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.qsign.EnergyResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.result = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnergyResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.qsign.EnergyResponse} EnergyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnergyResponse message.
             * @function verify
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnergyResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.result != null && message.hasOwnProperty("result"))
                    if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))
                        return "result: buffer expected";
                return null;
            };

            /**
             * Creates an EnergyResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.qsign.EnergyResponse} EnergyResponse
             */
            EnergyResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.qsign.EnergyResponse)
                    return object;
                let message = new $root.kritor.qsign.EnergyResponse();
                if (object.result != null)
                    if (typeof object.result === "string")
                        $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);
                    else if (object.result.length >= 0)
                        message.result = object.result;
                return message;
            };

            /**
             * Creates a plain object from an EnergyResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {kritor.qsign.EnergyResponse} message EnergyResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnergyResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.result = "";
                    else {
                        object.result = [];
                        if (options.bytes !== Array)
                            object.result = $util.newBuffer(object.result);
                    }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;
                return object;
            };

            /**
             * Converts this EnergyResponse to JSON.
             * @function toJSON
             * @memberof kritor.qsign.EnergyResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnergyResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnergyResponse
             * @function getTypeUrl
             * @memberof kritor.qsign.EnergyResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnergyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.qsign.EnergyResponse";
            };

            return EnergyResponse;
        })();

        qsign.SendPacketRequest = (function() {

            /**
             * Properties of a SendPacketRequest.
             * @memberof kritor.qsign
             * @interface ISendPacketRequest
             * @property {string|null} [command] SendPacketRequest command
             * @property {Uint8Array|null} [requestBuffer] SendPacketRequest requestBuffer
             * @property {boolean|null} [isProtobuf] SendPacketRequest isProtobuf
             * @property {Object.<string,string>|null} [attrs] SendPacketRequest attrs
             */

            /**
             * Constructs a new SendPacketRequest.
             * @memberof kritor.qsign
             * @classdesc Represents a SendPacketRequest.
             * @implements ISendPacketRequest
             * @constructor
             * @param {kritor.qsign.ISendPacketRequest=} [properties] Properties to set
             */
            function SendPacketRequest(properties) {
                this.attrs = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPacketRequest command.
             * @member {string} command
             * @memberof kritor.qsign.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.command = "";

            /**
             * SendPacketRequest requestBuffer.
             * @member {Uint8Array} requestBuffer
             * @memberof kritor.qsign.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.requestBuffer = $util.newBuffer([]);

            /**
             * SendPacketRequest isProtobuf.
             * @member {boolean} isProtobuf
             * @memberof kritor.qsign.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.isProtobuf = false;

            /**
             * SendPacketRequest attrs.
             * @member {Object.<string,string>} attrs
             * @memberof kritor.qsign.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.attrs = $util.emptyObject;

            /**
             * Creates a new SendPacketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {kritor.qsign.ISendPacketRequest=} [properties] Properties to set
             * @returns {kritor.qsign.SendPacketRequest} SendPacketRequest instance
             */
            SendPacketRequest.create = function create(properties) {
                return new SendPacketRequest(properties);
            };

            /**
             * Encodes the specified SendPacketRequest message. Does not implicitly {@link kritor.qsign.SendPacketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {kritor.qsign.ISendPacketRequest} message SendPacketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                if (message.requestBuffer != null && Object.hasOwnProperty.call(message, "requestBuffer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.requestBuffer);
                if (message.isProtobuf != null && Object.hasOwnProperty.call(message, "isProtobuf"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isProtobuf);
                if (message.attrs != null && Object.hasOwnProperty.call(message, "attrs"))
                    for (let keys = Object.keys(message.attrs), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attrs[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SendPacketRequest message, length delimited. Does not implicitly {@link kritor.qsign.SendPacketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {kritor.qsign.ISendPacketRequest} message SendPacketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPacketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.qsign.SendPacketRequest} SendPacketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.qsign.SendPacketRequest(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.command = reader.string();
                            break;
                        }
                    case 2: {
                            message.requestBuffer = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.isProtobuf = reader.bool();
                            break;
                        }
                    case 4: {
                            if (message.attrs === $util.emptyObject)
                                message.attrs = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.attrs[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPacketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.qsign.SendPacketRequest} SendPacketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPacketRequest message.
             * @function verify
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPacketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.requestBuffer != null && message.hasOwnProperty("requestBuffer"))
                    if (!(message.requestBuffer && typeof message.requestBuffer.length === "number" || $util.isString(message.requestBuffer)))
                        return "requestBuffer: buffer expected";
                if (message.isProtobuf != null && message.hasOwnProperty("isProtobuf"))
                    if (typeof message.isProtobuf !== "boolean")
                        return "isProtobuf: boolean expected";
                if (message.attrs != null && message.hasOwnProperty("attrs")) {
                    if (!$util.isObject(message.attrs))
                        return "attrs: object expected";
                    let key = Object.keys(message.attrs);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attrs[key[i]]))
                            return "attrs: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a SendPacketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.qsign.SendPacketRequest} SendPacketRequest
             */
            SendPacketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.qsign.SendPacketRequest)
                    return object;
                let message = new $root.kritor.qsign.SendPacketRequest();
                if (object.command != null)
                    message.command = String(object.command);
                if (object.requestBuffer != null)
                    if (typeof object.requestBuffer === "string")
                        $util.base64.decode(object.requestBuffer, message.requestBuffer = $util.newBuffer($util.base64.length(object.requestBuffer)), 0);
                    else if (object.requestBuffer.length >= 0)
                        message.requestBuffer = object.requestBuffer;
                if (object.isProtobuf != null)
                    message.isProtobuf = Boolean(object.isProtobuf);
                if (object.attrs) {
                    if (typeof object.attrs !== "object")
                        throw TypeError(".kritor.qsign.SendPacketRequest.attrs: object expected");
                    message.attrs = {};
                    for (let keys = Object.keys(object.attrs), i = 0; i < keys.length; ++i)
                        message.attrs[keys[i]] = String(object.attrs[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SendPacketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {kritor.qsign.SendPacketRequest} message SendPacketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPacketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.attrs = {};
                if (options.defaults) {
                    object.command = "";
                    if (options.bytes === String)
                        object.requestBuffer = "";
                    else {
                        object.requestBuffer = [];
                        if (options.bytes !== Array)
                            object.requestBuffer = $util.newBuffer(object.requestBuffer);
                    }
                    object.isProtobuf = false;
                }
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.requestBuffer != null && message.hasOwnProperty("requestBuffer"))
                    object.requestBuffer = options.bytes === String ? $util.base64.encode(message.requestBuffer, 0, message.requestBuffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.requestBuffer) : message.requestBuffer;
                if (message.isProtobuf != null && message.hasOwnProperty("isProtobuf"))
                    object.isProtobuf = message.isProtobuf;
                let keys2;
                if (message.attrs && (keys2 = Object.keys(message.attrs)).length) {
                    object.attrs = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.attrs[keys2[j]] = message.attrs[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this SendPacketRequest to JSON.
             * @function toJSON
             * @memberof kritor.qsign.SendPacketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPacketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendPacketRequest
             * @function getTypeUrl
             * @memberof kritor.qsign.SendPacketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendPacketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.qsign.SendPacketRequest";
            };

            return SendPacketRequest;
        })();

        qsign.SendPacketResponse = (function() {

            /**
             * Properties of a SendPacketResponse.
             * @memberof kritor.qsign
             * @interface ISendPacketResponse
             * @property {boolean|null} [isSuccess] SendPacketResponse isSuccess
             * @property {Uint8Array|null} [responseBuffer] SendPacketResponse responseBuffer
             */

            /**
             * Constructs a new SendPacketResponse.
             * @memberof kritor.qsign
             * @classdesc Represents a SendPacketResponse.
             * @implements ISendPacketResponse
             * @constructor
             * @param {kritor.qsign.ISendPacketResponse=} [properties] Properties to set
             */
            function SendPacketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPacketResponse isSuccess.
             * @member {boolean} isSuccess
             * @memberof kritor.qsign.SendPacketResponse
             * @instance
             */
            SendPacketResponse.prototype.isSuccess = false;

            /**
             * SendPacketResponse responseBuffer.
             * @member {Uint8Array} responseBuffer
             * @memberof kritor.qsign.SendPacketResponse
             * @instance
             */
            SendPacketResponse.prototype.responseBuffer = $util.newBuffer([]);

            /**
             * Creates a new SendPacketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {kritor.qsign.ISendPacketResponse=} [properties] Properties to set
             * @returns {kritor.qsign.SendPacketResponse} SendPacketResponse instance
             */
            SendPacketResponse.create = function create(properties) {
                return new SendPacketResponse(properties);
            };

            /**
             * Encodes the specified SendPacketResponse message. Does not implicitly {@link kritor.qsign.SendPacketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {kritor.qsign.ISendPacketResponse} message SendPacketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isSuccess != null && Object.hasOwnProperty.call(message, "isSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isSuccess);
                if (message.responseBuffer != null && Object.hasOwnProperty.call(message, "responseBuffer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.responseBuffer);
                return writer;
            };

            /**
             * Encodes the specified SendPacketResponse message, length delimited. Does not implicitly {@link kritor.qsign.SendPacketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {kritor.qsign.ISendPacketResponse} message SendPacketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPacketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.qsign.SendPacketResponse} SendPacketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.qsign.SendPacketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isSuccess = reader.bool();
                            break;
                        }
                    case 2: {
                            message.responseBuffer = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPacketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.qsign.SendPacketResponse} SendPacketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPacketResponse message.
             * @function verify
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPacketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    if (typeof message.isSuccess !== "boolean")
                        return "isSuccess: boolean expected";
                if (message.responseBuffer != null && message.hasOwnProperty("responseBuffer"))
                    if (!(message.responseBuffer && typeof message.responseBuffer.length === "number" || $util.isString(message.responseBuffer)))
                        return "responseBuffer: buffer expected";
                return null;
            };

            /**
             * Creates a SendPacketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.qsign.SendPacketResponse} SendPacketResponse
             */
            SendPacketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.qsign.SendPacketResponse)
                    return object;
                let message = new $root.kritor.qsign.SendPacketResponse();
                if (object.isSuccess != null)
                    message.isSuccess = Boolean(object.isSuccess);
                if (object.responseBuffer != null)
                    if (typeof object.responseBuffer === "string")
                        $util.base64.decode(object.responseBuffer, message.responseBuffer = $util.newBuffer($util.base64.length(object.responseBuffer)), 0);
                    else if (object.responseBuffer.length >= 0)
                        message.responseBuffer = object.responseBuffer;
                return message;
            };

            /**
             * Creates a plain object from a SendPacketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {kritor.qsign.SendPacketResponse} message SendPacketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPacketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.isSuccess = false;
                    if (options.bytes === String)
                        object.responseBuffer = "";
                    else {
                        object.responseBuffer = [];
                        if (options.bytes !== Array)
                            object.responseBuffer = $util.newBuffer(object.responseBuffer);
                    }
                }
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    object.isSuccess = message.isSuccess;
                if (message.responseBuffer != null && message.hasOwnProperty("responseBuffer"))
                    object.responseBuffer = options.bytes === String ? $util.base64.encode(message.responseBuffer, 0, message.responseBuffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.responseBuffer) : message.responseBuffer;
                return object;
            };

            /**
             * Converts this SendPacketResponse to JSON.
             * @function toJSON
             * @memberof kritor.qsign.SendPacketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPacketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendPacketResponse
             * @function getTypeUrl
             * @memberof kritor.qsign.SendPacketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendPacketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.qsign.SendPacketResponse";
            };

            return SendPacketResponse;
        })();

        return qsign;
    })();

    kritor.event = (function() {

        /**
         * Namespace event.
         * @memberof kritor
         * @namespace
         */
        const event = {};

        /**
         * Scene enum.
         * @name kritor.event.Scene
         * @enum {number}
         * @property {number} GROUP=0 GROUP value
         * @property {number} FRIEND=1 FRIEND value
         * @property {number} GUILD=2 GUILD value
         * @property {number} STRANGER_FROM_GROUP=10 STRANGER_FROM_GROUP value
         * @property {number} NEARBY=5 NEARBY value
         * @property {number} STRANGER=9 STRANGER value
         */
        event.Scene = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GROUP"] = 0;
            values[valuesById[1] = "FRIEND"] = 1;
            values[valuesById[2] = "GUILD"] = 2;
            values[valuesById[10] = "STRANGER_FROM_GROUP"] = 10;
            values[valuesById[5] = "NEARBY"] = 5;
            values[valuesById[9] = "STRANGER"] = 9;
            return values;
        })();

        event.Contact = (function() {

            /**
             * Properties of a Contact.
             * @memberof kritor.event
             * @interface IContact
             * @property {kritor.event.Scene|null} [scene] Contact scene
             * @property {string|null} [peer] Contact peer
             * @property {string|null} [subPeer] Contact subPeer
             */

            /**
             * Constructs a new Contact.
             * @memberof kritor.event
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {kritor.event.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contact scene.
             * @member {kritor.event.Scene} scene
             * @memberof kritor.event.Contact
             * @instance
             */
            Contact.prototype.scene = 0;

            /**
             * Contact peer.
             * @member {string} peer
             * @memberof kritor.event.Contact
             * @instance
             */
            Contact.prototype.peer = "";

            /**
             * Contact subPeer.
             * @member {string|null|undefined} subPeer
             * @memberof kritor.event.Contact
             * @instance
             */
            Contact.prototype.subPeer = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Contact _subPeer.
             * @member {"subPeer"|undefined} _subPeer
             * @memberof kritor.event.Contact
             * @instance
             */
            Object.defineProperty(Contact.prototype, "_subPeer", {
                get: $util.oneOfGetter($oneOfFields = ["subPeer"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof kritor.event.Contact
             * @static
             * @param {kritor.event.IContact=} [properties] Properties to set
             * @returns {kritor.event.Contact} Contact instance
             */
            Contact.create = function create(properties) {
                return new Contact(properties);
            };

            /**
             * Encodes the specified Contact message. Does not implicitly {@link kritor.event.Contact.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.Contact
             * @static
             * @param {kritor.event.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                if (message.subPeer != null && Object.hasOwnProperty.call(message, "subPeer"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subPeer);
                return writer;
            };

            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link kritor.event.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.Contact
             * @static
             * @param {kritor.event.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.Contact();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    case 3: {
                            message.subPeer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contact message.
             * @function verify
             * @memberof kritor.event.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                if (message.subPeer != null && message.hasOwnProperty("subPeer")) {
                    properties._subPeer = 1;
                    if (!$util.isString(message.subPeer))
                        return "subPeer: string expected";
                }
                return null;
            };

            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.Contact)
                    return object;
                let message = new $root.kritor.event.Contact();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                if (object.subPeer != null)
                    message.subPeer = String(object.subPeer);
                return message;
            };

            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.Contact
             * @static
             * @param {kritor.event.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.event.Scene[message.scene] === undefined ? message.scene : $root.kritor.event.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                if (message.subPeer != null && message.hasOwnProperty("subPeer")) {
                    object.subPeer = message.subPeer;
                    if (options.oneofs)
                        object._subPeer = "subPeer";
                }
                return object;
            };

            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof kritor.event.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Contact
             * @function getTypeUrl
             * @memberof kritor.event.Contact
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Contact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.Contact";
            };

            return Contact;
        })();

        event.Sender = (function() {

            /**
             * Properties of a Sender.
             * @memberof kritor.event
             * @interface ISender
             * @property {string|null} [nick] Sender nick
             * @property {string|null} [uid] Sender uid
             * @property {number|Long|null} [uin] Sender uin
             */

            /**
             * Constructs a new Sender.
             * @memberof kritor.event
             * @classdesc Represents a Sender.
             * @implements ISender
             * @constructor
             * @param {kritor.event.ISender=} [properties] Properties to set
             */
            function Sender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sender nick.
             * @member {string} nick
             * @memberof kritor.event.Sender
             * @instance
             */
            Sender.prototype.nick = "";

            /**
             * Sender uid.
             * @member {string} uid
             * @memberof kritor.event.Sender
             * @instance
             */
            Sender.prototype.uid = "";

            /**
             * Sender uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.event.Sender
             * @instance
             */
            Sender.prototype.uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Sender _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.event.Sender
             * @instance
             */
            Object.defineProperty(Sender.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Sender instance using the specified properties.
             * @function create
             * @memberof kritor.event.Sender
             * @static
             * @param {kritor.event.ISender=} [properties] Properties to set
             * @returns {kritor.event.Sender} Sender instance
             */
            Sender.create = function create(properties) {
                return new Sender(properties);
            };

            /**
             * Encodes the specified Sender message. Does not implicitly {@link kritor.event.Sender.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.Sender
             * @static
             * @param {kritor.event.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nick);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified Sender message, length delimited. Does not implicitly {@link kritor.event.Sender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.Sender
             * @static
             * @param {kritor.event.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.Sender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nick = reader.string();
                            break;
                        }
                    case 2: {
                            message.uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sender message.
             * @function verify
             * @memberof kritor.event.Sender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a Sender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.Sender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.Sender} Sender
             */
            Sender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.Sender)
                    return object;
                let message = new $root.kritor.event.Sender();
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Sender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.Sender
             * @static
             * @param {kritor.event.Sender} message Sender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nick = "";
                    object.uid = "";
                }
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                return object;
            };

            /**
             * Converts this Sender to JSON.
             * @function toJSON
             * @memberof kritor.event.Sender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sender
             * @function getTypeUrl
             * @memberof kritor.event.Sender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.Sender";
            };

            return Sender;
        })();

        /**
         * ElementType enum.
         * @name kritor.event.ElementType
         * @enum {number}
         * @property {number} TEXT=0 TEXT value
         * @property {number} AT=1 AT value
         * @property {number} FACE=2 FACE value
         * @property {number} BUBBLE_FACE=3 BUBBLE_FACE value
         * @property {number} REPLY=4 REPLY value
         * @property {number} IMAGE=5 IMAGE value
         * @property {number} VOICE=6 VOICE value
         * @property {number} VIDEO=7 VIDEO value
         * @property {number} BASKETBALL=8 BASKETBALL value
         * @property {number} DICE=9 DICE value
         * @property {number} RPS=10 RPS value
         * @property {number} POKE=11 POKE value
         * @property {number} MUSIC=12 MUSIC value
         * @property {number} WEATHER=13 WEATHER value
         * @property {number} LOCATION=14 LOCATION value
         * @property {number} SHARE=15 SHARE value
         * @property {number} GIFT=16 GIFT value
         * @property {number} MARKET_FACE=17 MARKET_FACE value
         * @property {number} FORWARD=18 FORWARD value
         * @property {number} CONTACT=19 CONTACT value
         * @property {number} JSON=20 JSON value
         * @property {number} XML=21 XML value
         * @property {number} FILE=22 FILE value
         * @property {number} MARKDOWN=23 MARKDOWN value
         * @property {number} BUTTON=24 BUTTON value
         * @property {number} NODE=99 NODE value
         */
        event.ElementType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TEXT"] = 0;
            values[valuesById[1] = "AT"] = 1;
            values[valuesById[2] = "FACE"] = 2;
            values[valuesById[3] = "BUBBLE_FACE"] = 3;
            values[valuesById[4] = "REPLY"] = 4;
            values[valuesById[5] = "IMAGE"] = 5;
            values[valuesById[6] = "VOICE"] = 6;
            values[valuesById[7] = "VIDEO"] = 7;
            values[valuesById[8] = "BASKETBALL"] = 8;
            values[valuesById[9] = "DICE"] = 9;
            values[valuesById[10] = "RPS"] = 10;
            values[valuesById[11] = "POKE"] = 11;
            values[valuesById[12] = "MUSIC"] = 12;
            values[valuesById[13] = "WEATHER"] = 13;
            values[valuesById[14] = "LOCATION"] = 14;
            values[valuesById[15] = "SHARE"] = 15;
            values[valuesById[16] = "GIFT"] = 16;
            values[valuesById[17] = "MARKET_FACE"] = 17;
            values[valuesById[18] = "FORWARD"] = 18;
            values[valuesById[19] = "CONTACT"] = 19;
            values[valuesById[20] = "JSON"] = 20;
            values[valuesById[21] = "XML"] = 21;
            values[valuesById[22] = "FILE"] = 22;
            values[valuesById[23] = "MARKDOWN"] = 23;
            values[valuesById[24] = "BUTTON"] = 24;
            values[valuesById[99] = "NODE"] = 99;
            return values;
        })();

        event.Element = (function() {

            /**
             * Properties of an Element.
             * @memberof kritor.event
             * @interface IElement
             * @property {kritor.event.ElementType|null} [type] Element type
             * @property {kritor.event.ITextElement|null} [text] Element text
             * @property {kritor.event.IAtElement|null} [at] Element at
             * @property {kritor.event.IFaceElement|null} [face] Element face
             * @property {kritor.event.IBubbleFaceElement|null} [bubbleFace] Element bubbleFace
             * @property {kritor.event.IReplyElement|null} [reply] Element reply
             * @property {kritor.event.IImageElement|null} [image] Element image
             * @property {kritor.event.IVoiceElement|null} [voice] Element voice
             * @property {kritor.event.IVideoElement|null} [video] Element video
             * @property {kritor.event.IBasketballElement|null} [basketball] Element basketball
             * @property {kritor.event.IDiceElement|null} [dice] Element dice
             * @property {kritor.event.IRpsElement|null} [rps] Element rps
             * @property {kritor.event.IPokeElement|null} [poke] Element poke
             * @property {kritor.event.IMusicElement|null} [music] Element music
             * @property {kritor.event.IWeatherElement|null} [weather] Element weather
             * @property {kritor.event.ILocationElement|null} [location] Element location
             * @property {kritor.event.IShareElement|null} [share] Element share
             * @property {kritor.event.IGiftElement|null} [gift] Element gift
             * @property {kritor.event.IMarketFaceElement|null} [marketFace] Element marketFace
             * @property {kritor.event.IForwardElement|null} [forward] Element forward
             * @property {kritor.event.IContactElement|null} [contact] Element contact
             * @property {kritor.event.IJsonElement|null} [json] Element json
             * @property {kritor.event.IXmlElement|null} [xml] Element xml
             * @property {kritor.event.IFileElement|null} [file] Element file
             * @property {kritor.event.IMarkdownElement|null} [markdown] Element markdown
             * @property {kritor.event.IButtonElement|null} [button] Element button
             * @property {kritor.event.INodeElement|null} [node] Element node
             */

            /**
             * Constructs a new Element.
             * @memberof kritor.event
             * @classdesc Represents an Element.
             * @implements IElement
             * @constructor
             * @param {kritor.event.IElement=} [properties] Properties to set
             */
            function Element(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Element type.
             * @member {kritor.event.ElementType} type
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.type = 0;

            /**
             * Element text.
             * @member {kritor.event.ITextElement|null|undefined} text
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.text = null;

            /**
             * Element at.
             * @member {kritor.event.IAtElement|null|undefined} at
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.at = null;

            /**
             * Element face.
             * @member {kritor.event.IFaceElement|null|undefined} face
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.face = null;

            /**
             * Element bubbleFace.
             * @member {kritor.event.IBubbleFaceElement|null|undefined} bubbleFace
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.bubbleFace = null;

            /**
             * Element reply.
             * @member {kritor.event.IReplyElement|null|undefined} reply
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.reply = null;

            /**
             * Element image.
             * @member {kritor.event.IImageElement|null|undefined} image
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.image = null;

            /**
             * Element voice.
             * @member {kritor.event.IVoiceElement|null|undefined} voice
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.voice = null;

            /**
             * Element video.
             * @member {kritor.event.IVideoElement|null|undefined} video
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.video = null;

            /**
             * Element basketball.
             * @member {kritor.event.IBasketballElement|null|undefined} basketball
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.basketball = null;

            /**
             * Element dice.
             * @member {kritor.event.IDiceElement|null|undefined} dice
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.dice = null;

            /**
             * Element rps.
             * @member {kritor.event.IRpsElement|null|undefined} rps
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.rps = null;

            /**
             * Element poke.
             * @member {kritor.event.IPokeElement|null|undefined} poke
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.poke = null;

            /**
             * Element music.
             * @member {kritor.event.IMusicElement|null|undefined} music
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.music = null;

            /**
             * Element weather.
             * @member {kritor.event.IWeatherElement|null|undefined} weather
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.weather = null;

            /**
             * Element location.
             * @member {kritor.event.ILocationElement|null|undefined} location
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.location = null;

            /**
             * Element share.
             * @member {kritor.event.IShareElement|null|undefined} share
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.share = null;

            /**
             * Element gift.
             * @member {kritor.event.IGiftElement|null|undefined} gift
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.gift = null;

            /**
             * Element marketFace.
             * @member {kritor.event.IMarketFaceElement|null|undefined} marketFace
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.marketFace = null;

            /**
             * Element forward.
             * @member {kritor.event.IForwardElement|null|undefined} forward
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.forward = null;

            /**
             * Element contact.
             * @member {kritor.event.IContactElement|null|undefined} contact
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.contact = null;

            /**
             * Element json.
             * @member {kritor.event.IJsonElement|null|undefined} json
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.json = null;

            /**
             * Element xml.
             * @member {kritor.event.IXmlElement|null|undefined} xml
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.xml = null;

            /**
             * Element file.
             * @member {kritor.event.IFileElement|null|undefined} file
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.file = null;

            /**
             * Element markdown.
             * @member {kritor.event.IMarkdownElement|null|undefined} markdown
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.markdown = null;

            /**
             * Element button.
             * @member {kritor.event.IButtonElement|null|undefined} button
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.button = null;

            /**
             * Element node.
             * @member {kritor.event.INodeElement|null|undefined} node
             * @memberof kritor.event.Element
             * @instance
             */
            Element.prototype.node = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Element data.
             * @member {"text"|"at"|"face"|"bubbleFace"|"reply"|"image"|"voice"|"video"|"basketball"|"dice"|"rps"|"poke"|"music"|"weather"|"location"|"share"|"gift"|"marketFace"|"forward"|"contact"|"json"|"xml"|"file"|"markdown"|"button"|"node"|undefined} data
             * @memberof kritor.event.Element
             * @instance
             */
            Object.defineProperty(Element.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["text", "at", "face", "bubbleFace", "reply", "image", "voice", "video", "basketball", "dice", "rps", "poke", "music", "weather", "location", "share", "gift", "marketFace", "forward", "contact", "json", "xml", "file", "markdown", "button", "node"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Element instance using the specified properties.
             * @function create
             * @memberof kritor.event.Element
             * @static
             * @param {kritor.event.IElement=} [properties] Properties to set
             * @returns {kritor.event.Element} Element instance
             */
            Element.create = function create(properties) {
                return new Element(properties);
            };

            /**
             * Encodes the specified Element message. Does not implicitly {@link kritor.event.Element.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.Element
             * @static
             * @param {kritor.event.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    $root.kritor.event.TextElement.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.at != null && Object.hasOwnProperty.call(message, "at"))
                    $root.kritor.event.AtElement.encode(message.at, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                    $root.kritor.event.FaceElement.encode(message.face, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.bubbleFace != null && Object.hasOwnProperty.call(message, "bubbleFace"))
                    $root.kritor.event.BubbleFaceElement.encode(message.bubbleFace, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    $root.kritor.event.ReplyElement.encode(message.reply, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.kritor.event.ImageElement.encode(message.image, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.voice != null && Object.hasOwnProperty.call(message, "voice"))
                    $root.kritor.event.VoiceElement.encode(message.voice, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                    $root.kritor.event.VideoElement.encode(message.video, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.basketball != null && Object.hasOwnProperty.call(message, "basketball"))
                    $root.kritor.event.BasketballElement.encode(message.basketball, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.dice != null && Object.hasOwnProperty.call(message, "dice"))
                    $root.kritor.event.DiceElement.encode(message.dice, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.rps != null && Object.hasOwnProperty.call(message, "rps"))
                    $root.kritor.event.RpsElement.encode(message.rps, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.poke != null && Object.hasOwnProperty.call(message, "poke"))
                    $root.kritor.event.PokeElement.encode(message.poke, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.music != null && Object.hasOwnProperty.call(message, "music"))
                    $root.kritor.event.MusicElement.encode(message.music, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.weather != null && Object.hasOwnProperty.call(message, "weather"))
                    $root.kritor.event.WeatherElement.encode(message.weather, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.kritor.event.LocationElement.encode(message.location, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.share != null && Object.hasOwnProperty.call(message, "share"))
                    $root.kritor.event.ShareElement.encode(message.share, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.gift != null && Object.hasOwnProperty.call(message, "gift"))
                    $root.kritor.event.GiftElement.encode(message.gift, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.marketFace != null && Object.hasOwnProperty.call(message, "marketFace"))
                    $root.kritor.event.MarketFaceElement.encode(message.marketFace, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.kritor.event.ForwardElement.encode(message.forward, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.event.ContactElement.encode(message.contact, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    $root.kritor.event.JsonElement.encode(message.json, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    $root.kritor.event.XmlElement.encode(message.xml, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.kritor.event.FileElement.encode(message.file, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    $root.kritor.event.MarkdownElement.encode(message.markdown, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.button != null && Object.hasOwnProperty.call(message, "button"))
                    $root.kritor.event.ButtonElement.encode(message.button, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.node != null && Object.hasOwnProperty.call(message, "node"))
                    $root.kritor.event.NodeElement.encode(message.node, writer.uint32(/* id 99, wireType 2 =*/794).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Element message, length delimited. Does not implicitly {@link kritor.event.Element.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.Element
             * @static
             * @param {kritor.event.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Element message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.Element();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.text = $root.kritor.event.TextElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.at = $root.kritor.event.AtElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.face = $root.kritor.event.FaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.bubbleFace = $root.kritor.event.BubbleFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.reply = $root.kritor.event.ReplyElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.image = $root.kritor.event.ImageElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.voice = $root.kritor.event.VoiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.video = $root.kritor.event.VideoElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.basketball = $root.kritor.event.BasketballElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dice = $root.kritor.event.DiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.rps = $root.kritor.event.RpsElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.poke = $root.kritor.event.PokeElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.music = $root.kritor.event.MusicElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.weather = $root.kritor.event.WeatherElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.location = $root.kritor.event.LocationElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.share = $root.kritor.event.ShareElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.gift = $root.kritor.event.GiftElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.marketFace = $root.kritor.event.MarketFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.forward = $root.kritor.event.ForwardElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.contact = $root.kritor.event.ContactElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.json = $root.kritor.event.JsonElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.xml = $root.kritor.event.XmlElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.file = $root.kritor.event.FileElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.markdown = $root.kritor.event.MarkdownElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.button = $root.kritor.event.ButtonElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 99: {
                            message.node = $root.kritor.event.NodeElement.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Element message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Element message.
             * @function verify
             * @memberof kritor.event.Element
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Element.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 99:
                        break;
                    }
                if (message.text != null && message.hasOwnProperty("text")) {
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.TextElement.verify(message.text);
                        if (error)
                            return "text." + error;
                    }
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.AtElement.verify(message.at);
                        if (error)
                            return "at." + error;
                    }
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.FaceElement.verify(message.face);
                        if (error)
                            return "face." + error;
                    }
                }
                if (message.bubbleFace != null && message.hasOwnProperty("bubbleFace")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.BubbleFaceElement.verify(message.bubbleFace);
                        if (error)
                            return "bubbleFace." + error;
                    }
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.ReplyElement.verify(message.reply);
                        if (error)
                            return "reply." + error;
                    }
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.ImageElement.verify(message.image);
                        if (error)
                            return "image." + error;
                    }
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.VoiceElement.verify(message.voice);
                        if (error)
                            return "voice." + error;
                    }
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.VideoElement.verify(message.video);
                        if (error)
                            return "video." + error;
                    }
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.BasketballElement.verify(message.basketball);
                        if (error)
                            return "basketball." + error;
                    }
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.DiceElement.verify(message.dice);
                        if (error)
                            return "dice." + error;
                    }
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.RpsElement.verify(message.rps);
                        if (error)
                            return "rps." + error;
                    }
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.PokeElement.verify(message.poke);
                        if (error)
                            return "poke." + error;
                    }
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.MusicElement.verify(message.music);
                        if (error)
                            return "music." + error;
                    }
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.WeatherElement.verify(message.weather);
                        if (error)
                            return "weather." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.LocationElement.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.ShareElement.verify(message.share);
                        if (error)
                            return "share." + error;
                    }
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.GiftElement.verify(message.gift);
                        if (error)
                            return "gift." + error;
                    }
                }
                if (message.marketFace != null && message.hasOwnProperty("marketFace")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.MarketFaceElement.verify(message.marketFace);
                        if (error)
                            return "marketFace." + error;
                    }
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.ForwardElement.verify(message.forward);
                        if (error)
                            return "forward." + error;
                    }
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.ContactElement.verify(message.contact);
                        if (error)
                            return "contact." + error;
                    }
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.JsonElement.verify(message.json);
                        if (error)
                            return "json." + error;
                    }
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.XmlElement.verify(message.xml);
                        if (error)
                            return "xml." + error;
                    }
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.FileElement.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.MarkdownElement.verify(message.markdown);
                        if (error)
                            return "markdown." + error;
                    }
                }
                if (message.button != null && message.hasOwnProperty("button")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.ButtonElement.verify(message.button);
                        if (error)
                            return "button." + error;
                    }
                }
                if (message.node != null && message.hasOwnProperty("node")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.NodeElement.verify(message.node);
                        if (error)
                            return "node." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Element message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.Element
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.Element} Element
             */
            Element.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.Element)
                    return object;
                let message = new $root.kritor.event.Element();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TEXT":
                case 0:
                    message.type = 0;
                    break;
                case "AT":
                case 1:
                    message.type = 1;
                    break;
                case "FACE":
                case 2:
                    message.type = 2;
                    break;
                case "BUBBLE_FACE":
                case 3:
                    message.type = 3;
                    break;
                case "REPLY":
                case 4:
                    message.type = 4;
                    break;
                case "IMAGE":
                case 5:
                    message.type = 5;
                    break;
                case "VOICE":
                case 6:
                    message.type = 6;
                    break;
                case "VIDEO":
                case 7:
                    message.type = 7;
                    break;
                case "BASKETBALL":
                case 8:
                    message.type = 8;
                    break;
                case "DICE":
                case 9:
                    message.type = 9;
                    break;
                case "RPS":
                case 10:
                    message.type = 10;
                    break;
                case "POKE":
                case 11:
                    message.type = 11;
                    break;
                case "MUSIC":
                case 12:
                    message.type = 12;
                    break;
                case "WEATHER":
                case 13:
                    message.type = 13;
                    break;
                case "LOCATION":
                case 14:
                    message.type = 14;
                    break;
                case "SHARE":
                case 15:
                    message.type = 15;
                    break;
                case "GIFT":
                case 16:
                    message.type = 16;
                    break;
                case "MARKET_FACE":
                case 17:
                    message.type = 17;
                    break;
                case "FORWARD":
                case 18:
                    message.type = 18;
                    break;
                case "CONTACT":
                case 19:
                    message.type = 19;
                    break;
                case "JSON":
                case 20:
                    message.type = 20;
                    break;
                case "XML":
                case 21:
                    message.type = 21;
                    break;
                case "FILE":
                case 22:
                    message.type = 22;
                    break;
                case "MARKDOWN":
                case 23:
                    message.type = 23;
                    break;
                case "BUTTON":
                case 24:
                    message.type = 24;
                    break;
                case "NODE":
                case 99:
                    message.type = 99;
                    break;
                }
                if (object.text != null) {
                    if (typeof object.text !== "object")
                        throw TypeError(".kritor.event.Element.text: object expected");
                    message.text = $root.kritor.event.TextElement.fromObject(object.text);
                }
                if (object.at != null) {
                    if (typeof object.at !== "object")
                        throw TypeError(".kritor.event.Element.at: object expected");
                    message.at = $root.kritor.event.AtElement.fromObject(object.at);
                }
                if (object.face != null) {
                    if (typeof object.face !== "object")
                        throw TypeError(".kritor.event.Element.face: object expected");
                    message.face = $root.kritor.event.FaceElement.fromObject(object.face);
                }
                if (object.bubbleFace != null) {
                    if (typeof object.bubbleFace !== "object")
                        throw TypeError(".kritor.event.Element.bubbleFace: object expected");
                    message.bubbleFace = $root.kritor.event.BubbleFaceElement.fromObject(object.bubbleFace);
                }
                if (object.reply != null) {
                    if (typeof object.reply !== "object")
                        throw TypeError(".kritor.event.Element.reply: object expected");
                    message.reply = $root.kritor.event.ReplyElement.fromObject(object.reply);
                }
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".kritor.event.Element.image: object expected");
                    message.image = $root.kritor.event.ImageElement.fromObject(object.image);
                }
                if (object.voice != null) {
                    if (typeof object.voice !== "object")
                        throw TypeError(".kritor.event.Element.voice: object expected");
                    message.voice = $root.kritor.event.VoiceElement.fromObject(object.voice);
                }
                if (object.video != null) {
                    if (typeof object.video !== "object")
                        throw TypeError(".kritor.event.Element.video: object expected");
                    message.video = $root.kritor.event.VideoElement.fromObject(object.video);
                }
                if (object.basketball != null) {
                    if (typeof object.basketball !== "object")
                        throw TypeError(".kritor.event.Element.basketball: object expected");
                    message.basketball = $root.kritor.event.BasketballElement.fromObject(object.basketball);
                }
                if (object.dice != null) {
                    if (typeof object.dice !== "object")
                        throw TypeError(".kritor.event.Element.dice: object expected");
                    message.dice = $root.kritor.event.DiceElement.fromObject(object.dice);
                }
                if (object.rps != null) {
                    if (typeof object.rps !== "object")
                        throw TypeError(".kritor.event.Element.rps: object expected");
                    message.rps = $root.kritor.event.RpsElement.fromObject(object.rps);
                }
                if (object.poke != null) {
                    if (typeof object.poke !== "object")
                        throw TypeError(".kritor.event.Element.poke: object expected");
                    message.poke = $root.kritor.event.PokeElement.fromObject(object.poke);
                }
                if (object.music != null) {
                    if (typeof object.music !== "object")
                        throw TypeError(".kritor.event.Element.music: object expected");
                    message.music = $root.kritor.event.MusicElement.fromObject(object.music);
                }
                if (object.weather != null) {
                    if (typeof object.weather !== "object")
                        throw TypeError(".kritor.event.Element.weather: object expected");
                    message.weather = $root.kritor.event.WeatherElement.fromObject(object.weather);
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".kritor.event.Element.location: object expected");
                    message.location = $root.kritor.event.LocationElement.fromObject(object.location);
                }
                if (object.share != null) {
                    if (typeof object.share !== "object")
                        throw TypeError(".kritor.event.Element.share: object expected");
                    message.share = $root.kritor.event.ShareElement.fromObject(object.share);
                }
                if (object.gift != null) {
                    if (typeof object.gift !== "object")
                        throw TypeError(".kritor.event.Element.gift: object expected");
                    message.gift = $root.kritor.event.GiftElement.fromObject(object.gift);
                }
                if (object.marketFace != null) {
                    if (typeof object.marketFace !== "object")
                        throw TypeError(".kritor.event.Element.marketFace: object expected");
                    message.marketFace = $root.kritor.event.MarketFaceElement.fromObject(object.marketFace);
                }
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".kritor.event.Element.forward: object expected");
                    message.forward = $root.kritor.event.ForwardElement.fromObject(object.forward);
                }
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.event.Element.contact: object expected");
                    message.contact = $root.kritor.event.ContactElement.fromObject(object.contact);
                }
                if (object.json != null) {
                    if (typeof object.json !== "object")
                        throw TypeError(".kritor.event.Element.json: object expected");
                    message.json = $root.kritor.event.JsonElement.fromObject(object.json);
                }
                if (object.xml != null) {
                    if (typeof object.xml !== "object")
                        throw TypeError(".kritor.event.Element.xml: object expected");
                    message.xml = $root.kritor.event.XmlElement.fromObject(object.xml);
                }
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".kritor.event.Element.file: object expected");
                    message.file = $root.kritor.event.FileElement.fromObject(object.file);
                }
                if (object.markdown != null) {
                    if (typeof object.markdown !== "object")
                        throw TypeError(".kritor.event.Element.markdown: object expected");
                    message.markdown = $root.kritor.event.MarkdownElement.fromObject(object.markdown);
                }
                if (object.button != null) {
                    if (typeof object.button !== "object")
                        throw TypeError(".kritor.event.Element.button: object expected");
                    message.button = $root.kritor.event.ButtonElement.fromObject(object.button);
                }
                if (object.node != null) {
                    if (typeof object.node !== "object")
                        throw TypeError(".kritor.event.Element.node: object expected");
                    message.node = $root.kritor.event.NodeElement.fromObject(object.node);
                }
                return message;
            };

            /**
             * Creates a plain object from an Element message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.Element
             * @static
             * @param {kritor.event.Element} message Element
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Element.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "TEXT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.ElementType[message.type] === undefined ? message.type : $root.kritor.event.ElementType[message.type] : message.type;
                if (message.text != null && message.hasOwnProperty("text")) {
                    object.text = $root.kritor.event.TextElement.toObject(message.text, options);
                    if (options.oneofs)
                        object.data = "text";
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    object.at = $root.kritor.event.AtElement.toObject(message.at, options);
                    if (options.oneofs)
                        object.data = "at";
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    object.face = $root.kritor.event.FaceElement.toObject(message.face, options);
                    if (options.oneofs)
                        object.data = "face";
                }
                if (message.bubbleFace != null && message.hasOwnProperty("bubbleFace")) {
                    object.bubbleFace = $root.kritor.event.BubbleFaceElement.toObject(message.bubbleFace, options);
                    if (options.oneofs)
                        object.data = "bubbleFace";
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    object.reply = $root.kritor.event.ReplyElement.toObject(message.reply, options);
                    if (options.oneofs)
                        object.data = "reply";
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    object.image = $root.kritor.event.ImageElement.toObject(message.image, options);
                    if (options.oneofs)
                        object.data = "image";
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    object.voice = $root.kritor.event.VoiceElement.toObject(message.voice, options);
                    if (options.oneofs)
                        object.data = "voice";
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    object.video = $root.kritor.event.VideoElement.toObject(message.video, options);
                    if (options.oneofs)
                        object.data = "video";
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    object.basketball = $root.kritor.event.BasketballElement.toObject(message.basketball, options);
                    if (options.oneofs)
                        object.data = "basketball";
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    object.dice = $root.kritor.event.DiceElement.toObject(message.dice, options);
                    if (options.oneofs)
                        object.data = "dice";
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    object.rps = $root.kritor.event.RpsElement.toObject(message.rps, options);
                    if (options.oneofs)
                        object.data = "rps";
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    object.poke = $root.kritor.event.PokeElement.toObject(message.poke, options);
                    if (options.oneofs)
                        object.data = "poke";
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    object.music = $root.kritor.event.MusicElement.toObject(message.music, options);
                    if (options.oneofs)
                        object.data = "music";
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    object.weather = $root.kritor.event.WeatherElement.toObject(message.weather, options);
                    if (options.oneofs)
                        object.data = "weather";
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    object.location = $root.kritor.event.LocationElement.toObject(message.location, options);
                    if (options.oneofs)
                        object.data = "location";
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    object.share = $root.kritor.event.ShareElement.toObject(message.share, options);
                    if (options.oneofs)
                        object.data = "share";
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    object.gift = $root.kritor.event.GiftElement.toObject(message.gift, options);
                    if (options.oneofs)
                        object.data = "gift";
                }
                if (message.marketFace != null && message.hasOwnProperty("marketFace")) {
                    object.marketFace = $root.kritor.event.MarketFaceElement.toObject(message.marketFace, options);
                    if (options.oneofs)
                        object.data = "marketFace";
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    object.forward = $root.kritor.event.ForwardElement.toObject(message.forward, options);
                    if (options.oneofs)
                        object.data = "forward";
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    object.contact = $root.kritor.event.ContactElement.toObject(message.contact, options);
                    if (options.oneofs)
                        object.data = "contact";
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    object.json = $root.kritor.event.JsonElement.toObject(message.json, options);
                    if (options.oneofs)
                        object.data = "json";
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    object.xml = $root.kritor.event.XmlElement.toObject(message.xml, options);
                    if (options.oneofs)
                        object.data = "xml";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = $root.kritor.event.FileElement.toObject(message.file, options);
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    object.markdown = $root.kritor.event.MarkdownElement.toObject(message.markdown, options);
                    if (options.oneofs)
                        object.data = "markdown";
                }
                if (message.button != null && message.hasOwnProperty("button")) {
                    object.button = $root.kritor.event.ButtonElement.toObject(message.button, options);
                    if (options.oneofs)
                        object.data = "button";
                }
                if (message.node != null && message.hasOwnProperty("node")) {
                    object.node = $root.kritor.event.NodeElement.toObject(message.node, options);
                    if (options.oneofs)
                        object.data = "node";
                }
                return object;
            };

            /**
             * Converts this Element to JSON.
             * @function toJSON
             * @memberof kritor.event.Element
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Element.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Element
             * @function getTypeUrl
             * @memberof kritor.event.Element
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Element.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.Element";
            };

            return Element;
        })();

        event.TextElement = (function() {

            /**
             * Properties of a TextElement.
             * @memberof kritor.event
             * @interface ITextElement
             * @property {string|null} [text] TextElement text
             */

            /**
             * Constructs a new TextElement.
             * @memberof kritor.event
             * @classdesc Represents a TextElement.
             * @implements ITextElement
             * @constructor
             * @param {kritor.event.ITextElement=} [properties] Properties to set
             */
            function TextElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TextElement text.
             * @member {string} text
             * @memberof kritor.event.TextElement
             * @instance
             */
            TextElement.prototype.text = "";

            /**
             * Creates a new TextElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.TextElement
             * @static
             * @param {kritor.event.ITextElement=} [properties] Properties to set
             * @returns {kritor.event.TextElement} TextElement instance
             */
            TextElement.create = function create(properties) {
                return new TextElement(properties);
            };

            /**
             * Encodes the specified TextElement message. Does not implicitly {@link kritor.event.TextElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.TextElement
             * @static
             * @param {kritor.event.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };

            /**
             * Encodes the specified TextElement message, length delimited. Does not implicitly {@link kritor.event.TextElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.TextElement
             * @static
             * @param {kritor.event.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.TextElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.text = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TextElement message.
             * @function verify
             * @memberof kritor.event.TextElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TextElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };

            /**
             * Creates a TextElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.TextElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.TextElement} TextElement
             */
            TextElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.TextElement)
                    return object;
                let message = new $root.kritor.event.TextElement();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };

            /**
             * Creates a plain object from a TextElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.TextElement
             * @static
             * @param {kritor.event.TextElement} message TextElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TextElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };

            /**
             * Converts this TextElement to JSON.
             * @function toJSON
             * @memberof kritor.event.TextElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TextElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TextElement
             * @function getTypeUrl
             * @memberof kritor.event.TextElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TextElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.TextElement";
            };

            return TextElement;
        })();

        event.AtElement = (function() {

            /**
             * Properties of an AtElement.
             * @memberof kritor.event
             * @interface IAtElement
             * @property {string|null} [uid] AtElement uid
             * @property {number|Long|null} [uin] AtElement uin
             */

            /**
             * Constructs a new AtElement.
             * @memberof kritor.event
             * @classdesc Represents an AtElement.
             * @implements IAtElement
             * @constructor
             * @param {kritor.event.IAtElement=} [properties] Properties to set
             */
            function AtElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AtElement uid.
             * @member {string} uid
             * @memberof kritor.event.AtElement
             * @instance
             */
            AtElement.prototype.uid = "";

            /**
             * AtElement uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.event.AtElement
             * @instance
             */
            AtElement.prototype.uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AtElement _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.event.AtElement
             * @instance
             */
            Object.defineProperty(AtElement.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AtElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.AtElement
             * @static
             * @param {kritor.event.IAtElement=} [properties] Properties to set
             * @returns {kritor.event.AtElement} AtElement instance
             */
            AtElement.create = function create(properties) {
                return new AtElement(properties);
            };

            /**
             * Encodes the specified AtElement message. Does not implicitly {@link kritor.event.AtElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.AtElement
             * @static
             * @param {kritor.event.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified AtElement message, length delimited. Does not implicitly {@link kritor.event.AtElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.AtElement
             * @static
             * @param {kritor.event.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.AtElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AtElement message.
             * @function verify
             * @memberof kritor.event.AtElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AtElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates an AtElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.AtElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.AtElement} AtElement
             */
            AtElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.AtElement)
                    return object;
                let message = new $root.kritor.event.AtElement();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an AtElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.AtElement
             * @static
             * @param {kritor.event.AtElement} message AtElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AtElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.uid = "";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                return object;
            };

            /**
             * Converts this AtElement to JSON.
             * @function toJSON
             * @memberof kritor.event.AtElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AtElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AtElement
             * @function getTypeUrl
             * @memberof kritor.event.AtElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AtElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.AtElement";
            };

            return AtElement;
        })();

        event.FaceElement = (function() {

            /**
             * Properties of a FaceElement.
             * @memberof kritor.event
             * @interface IFaceElement
             * @property {number|null} [id] FaceElement id
             * @property {boolean|null} [isBig] FaceElement isBig
             * @property {number|null} [result] FaceElement result
             */

            /**
             * Constructs a new FaceElement.
             * @memberof kritor.event
             * @classdesc Represents a FaceElement.
             * @implements IFaceElement
             * @constructor
             * @param {kritor.event.IFaceElement=} [properties] Properties to set
             */
            function FaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FaceElement id.
             * @member {number} id
             * @memberof kritor.event.FaceElement
             * @instance
             */
            FaceElement.prototype.id = 0;

            /**
             * FaceElement isBig.
             * @member {boolean|null|undefined} isBig
             * @memberof kritor.event.FaceElement
             * @instance
             */
            FaceElement.prototype.isBig = null;

            /**
             * FaceElement result.
             * @member {number|null|undefined} result
             * @memberof kritor.event.FaceElement
             * @instance
             */
            FaceElement.prototype.result = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FaceElement _isBig.
             * @member {"isBig"|undefined} _isBig
             * @memberof kritor.event.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_isBig", {
                get: $util.oneOfGetter($oneOfFields = ["isBig"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FaceElement _result.
             * @member {"result"|undefined} _result
             * @memberof kritor.event.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_result", {
                get: $util.oneOfGetter($oneOfFields = ["result"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.FaceElement
             * @static
             * @param {kritor.event.IFaceElement=} [properties] Properties to set
             * @returns {kritor.event.FaceElement} FaceElement instance
             */
            FaceElement.create = function create(properties) {
                return new FaceElement(properties);
            };

            /**
             * Encodes the specified FaceElement message. Does not implicitly {@link kritor.event.FaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FaceElement
             * @static
             * @param {kritor.event.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.isBig != null && Object.hasOwnProperty.call(message, "isBig"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBig);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.result);
                return writer;
            };

            /**
             * Encodes the specified FaceElement message, length delimited. Does not implicitly {@link kritor.event.FaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FaceElement
             * @static
             * @param {kritor.event.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.isBig = reader.bool();
                            break;
                        }
                    case 3: {
                            message.result = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FaceElement message.
             * @function verify
             * @memberof kritor.event.FaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.isBig != null && message.hasOwnProperty("isBig")) {
                    properties._isBig = 1;
                    if (typeof message.isBig !== "boolean")
                        return "isBig: boolean expected";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    properties._result = 1;
                    if (!$util.isInteger(message.result))
                        return "result: integer expected";
                }
                return null;
            };

            /**
             * Creates a FaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FaceElement} FaceElement
             */
            FaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FaceElement)
                    return object;
                let message = new $root.kritor.event.FaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.isBig != null)
                    message.isBig = Boolean(object.isBig);
                if (object.result != null)
                    message.result = object.result >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a FaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FaceElement
             * @static
             * @param {kritor.event.FaceElement} message FaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.isBig != null && message.hasOwnProperty("isBig")) {
                    object.isBig = message.isBig;
                    if (options.oneofs)
                        object._isBig = "isBig";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object._result = "result";
                }
                return object;
            };

            /**
             * Converts this FaceElement to JSON.
             * @function toJSON
             * @memberof kritor.event.FaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FaceElement
             * @function getTypeUrl
             * @memberof kritor.event.FaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FaceElement";
            };

            return FaceElement;
        })();

        event.BubbleFaceElement = (function() {

            /**
             * Properties of a BubbleFaceElement.
             * @memberof kritor.event
             * @interface IBubbleFaceElement
             * @property {number|null} [id] BubbleFaceElement id
             * @property {number|null} [count] BubbleFaceElement count
             */

            /**
             * Constructs a new BubbleFaceElement.
             * @memberof kritor.event
             * @classdesc Represents a BubbleFaceElement.
             * @implements IBubbleFaceElement
             * @constructor
             * @param {kritor.event.IBubbleFaceElement=} [properties] Properties to set
             */
            function BubbleFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BubbleFaceElement id.
             * @member {number} id
             * @memberof kritor.event.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.id = 0;

            /**
             * BubbleFaceElement count.
             * @member {number} count
             * @memberof kritor.event.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.count = 0;

            /**
             * Creates a new BubbleFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {kritor.event.IBubbleFaceElement=} [properties] Properties to set
             * @returns {kritor.event.BubbleFaceElement} BubbleFaceElement instance
             */
            BubbleFaceElement.create = function create(properties) {
                return new BubbleFaceElement(properties);
            };

            /**
             * Encodes the specified BubbleFaceElement message. Does not implicitly {@link kritor.event.BubbleFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {kritor.event.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified BubbleFaceElement message, length delimited. Does not implicitly {@link kritor.event.BubbleFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {kritor.event.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.BubbleFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BubbleFaceElement message.
             * @function verify
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BubbleFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a BubbleFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.BubbleFaceElement} BubbleFaceElement
             */
            BubbleFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.BubbleFaceElement)
                    return object;
                let message = new $root.kritor.event.BubbleFaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BubbleFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {kritor.event.BubbleFaceElement} message BubbleFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BubbleFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.count = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this BubbleFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.event.BubbleFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BubbleFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BubbleFaceElement
             * @function getTypeUrl
             * @memberof kritor.event.BubbleFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BubbleFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.BubbleFaceElement";
            };

            return BubbleFaceElement;
        })();

        event.ReplyElement = (function() {

            /**
             * Properties of a ReplyElement.
             * @memberof kritor.event
             * @interface IReplyElement
             * @property {number|Long|null} [messageId] ReplyElement messageId
             */

            /**
             * Constructs a new ReplyElement.
             * @memberof kritor.event
             * @classdesc Represents a ReplyElement.
             * @implements IReplyElement
             * @constructor
             * @param {kritor.event.IReplyElement=} [properties] Properties to set
             */
            function ReplyElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplyElement messageId.
             * @member {number|Long} messageId
             * @memberof kritor.event.ReplyElement
             * @instance
             */
            ReplyElement.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ReplyElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {kritor.event.IReplyElement=} [properties] Properties to set
             * @returns {kritor.event.ReplyElement} ReplyElement instance
             */
            ReplyElement.create = function create(properties) {
                return new ReplyElement(properties);
            };

            /**
             * Encodes the specified ReplyElement message. Does not implicitly {@link kritor.event.ReplyElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {kritor.event.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified ReplyElement message, length delimited. Does not implicitly {@link kritor.event.ReplyElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {kritor.event.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ReplyElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplyElement message.
             * @function verify
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplyElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a ReplyElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ReplyElement} ReplyElement
             */
            ReplyElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ReplyElement)
                    return object;
                let message = new $root.kritor.event.ReplyElement();
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ReplyElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {kritor.event.ReplyElement} message ReplyElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplyElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this ReplyElement to JSON.
             * @function toJSON
             * @memberof kritor.event.ReplyElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplyElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReplyElement
             * @function getTypeUrl
             * @memberof kritor.event.ReplyElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReplyElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ReplyElement";
            };

            return ReplyElement;
        })();

        /**
         * ImageType enum.
         * @name kritor.event.ImageType
         * @enum {number}
         * @property {number} COMMON=0 COMMON value
         * @property {number} ORIGIN=1 ORIGIN value
         * @property {number} FLASH=2 FLASH value
         */
        event.ImageType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COMMON"] = 0;
            values[valuesById[1] = "ORIGIN"] = 1;
            values[valuesById[2] = "FLASH"] = 2;
            return values;
        })();

        event.ImageElement = (function() {

            /**
             * Properties of an ImageElement.
             * @memberof kritor.event
             * @interface IImageElement
             * @property {string|null} [file] ImageElement file
             * @property {string|null} [url] ImageElement url
             * @property {kritor.event.ImageType|null} [type] ImageElement type
             * @property {number|null} [subType] ImageElement subType
             */

            /**
             * Constructs a new ImageElement.
             * @memberof kritor.event
             * @classdesc Represents an ImageElement.
             * @implements IImageElement
             * @constructor
             * @param {kritor.event.IImageElement=} [properties] Properties to set
             */
            function ImageElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImageElement file.
             * @member {string} file
             * @memberof kritor.event.ImageElement
             * @instance
             */
            ImageElement.prototype.file = "";

            /**
             * ImageElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.event.ImageElement
             * @instance
             */
            ImageElement.prototype.url = null;

            /**
             * ImageElement type.
             * @member {kritor.event.ImageType|null|undefined} type
             * @memberof kritor.event.ImageElement
             * @instance
             */
            ImageElement.prototype.type = null;

            /**
             * ImageElement subType.
             * @member {number|null|undefined} subType
             * @memberof kritor.event.ImageElement
             * @instance
             */
            ImageElement.prototype.subType = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ImageElement _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.event.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _type.
             * @member {"type"|undefined} _type
             * @memberof kritor.event.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_type", {
                get: $util.oneOfGetter($oneOfFields = ["type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _subType.
             * @member {"subType"|undefined} _subType
             * @memberof kritor.event.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_subType", {
                get: $util.oneOfGetter($oneOfFields = ["subType"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ImageElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.ImageElement
             * @static
             * @param {kritor.event.IImageElement=} [properties] Properties to set
             * @returns {kritor.event.ImageElement} ImageElement instance
             */
            ImageElement.create = function create(properties) {
                return new ImageElement(properties);
            };

            /**
             * Encodes the specified ImageElement message. Does not implicitly {@link kritor.event.ImageElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ImageElement
             * @static
             * @param {kritor.event.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.subType);
                return writer;
            };

            /**
             * Encodes the specified ImageElement message, length delimited. Does not implicitly {@link kritor.event.ImageElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ImageElement
             * @static
             * @param {kritor.event.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ImageElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    case 3: {
                            message.type = reader.int32();
                            break;
                        }
                    case 4: {
                            message.subType = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImageElement message.
             * @function verify
             * @memberof kritor.event.ImageElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImageElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    properties._type = 1;
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                }
                if (message.subType != null && message.hasOwnProperty("subType")) {
                    properties._subType = 1;
                    if (!$util.isInteger(message.subType))
                        return "subType: integer expected";
                }
                return null;
            };

            /**
             * Creates an ImageElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ImageElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ImageElement} ImageElement
             */
            ImageElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ImageElement)
                    return object;
                let message = new $root.kritor.event.ImageElement();
                if (object.file != null)
                    message.file = String(object.file);
                if (object.url != null)
                    message.url = String(object.url);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "COMMON":
                case 0:
                    message.type = 0;
                    break;
                case "ORIGIN":
                case 1:
                    message.type = 1;
                    break;
                case "FLASH":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.subType != null)
                    message.subType = object.subType >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an ImageElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ImageElement
             * @static
             * @param {kritor.event.ImageElement} message ImageElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.file = "";
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    object.type = options.enums === String ? $root.kritor.event.ImageType[message.type] === undefined ? message.type : $root.kritor.event.ImageType[message.type] : message.type;
                    if (options.oneofs)
                        object._type = "type";
                }
                if (message.subType != null && message.hasOwnProperty("subType")) {
                    object.subType = message.subType;
                    if (options.oneofs)
                        object._subType = "subType";
                }
                return object;
            };

            /**
             * Converts this ImageElement to JSON.
             * @function toJSON
             * @memberof kritor.event.ImageElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImageElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ImageElement
             * @function getTypeUrl
             * @memberof kritor.event.ImageElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ImageElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ImageElement";
            };

            return ImageElement;
        })();

        event.VoiceElement = (function() {

            /**
             * Properties of a VoiceElement.
             * @memberof kritor.event
             * @interface IVoiceElement
             * @property {string|null} [file] VoiceElement file
             * @property {string|null} [url] VoiceElement url
             * @property {boolean|null} [magic] VoiceElement magic
             */

            /**
             * Constructs a new VoiceElement.
             * @memberof kritor.event
             * @classdesc Represents a VoiceElement.
             * @implements IVoiceElement
             * @constructor
             * @param {kritor.event.IVoiceElement=} [properties] Properties to set
             */
            function VoiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoiceElement file.
             * @member {string|null|undefined} file
             * @memberof kritor.event.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file = null;

            /**
             * VoiceElement url.
             * @member {string} url
             * @memberof kritor.event.VoiceElement
             * @instance
             */
            VoiceElement.prototype.url = "";

            /**
             * VoiceElement magic.
             * @member {boolean|null|undefined} magic
             * @memberof kritor.event.VoiceElement
             * @instance
             */
            VoiceElement.prototype.magic = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoiceElement _file.
             * @member {"file"|undefined} _file
             * @memberof kritor.event.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_file", {
                get: $util.oneOfGetter($oneOfFields = ["file"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _magic.
             * @member {"magic"|undefined} _magic
             * @memberof kritor.event.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_magic", {
                get: $util.oneOfGetter($oneOfFields = ["magic"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {kritor.event.IVoiceElement=} [properties] Properties to set
             * @returns {kritor.event.VoiceElement} VoiceElement instance
             */
            VoiceElement.create = function create(properties) {
                return new VoiceElement(properties);
            };

            /**
             * Encodes the specified VoiceElement message. Does not implicitly {@link kritor.event.VoiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {kritor.event.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                if (message.magic != null && Object.hasOwnProperty.call(message, "magic"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.magic);
                return writer;
            };

            /**
             * Encodes the specified VoiceElement message, length delimited. Does not implicitly {@link kritor.event.VoiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {kritor.event.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.VoiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    case 3: {
                            message.magic = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoiceElement message.
             * @function verify
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties._file = 1;
                    if (!$util.isString(message.file))
                        return "file: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    properties._magic = 1;
                    if (typeof message.magic !== "boolean")
                        return "magic: boolean expected";
                }
                return null;
            };

            /**
             * Creates a VoiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.VoiceElement} VoiceElement
             */
            VoiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.VoiceElement)
                    return object;
                let message = new $root.kritor.event.VoiceElement();
                if (object.file != null)
                    message.file = String(object.file);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.magic != null)
                    message.magic = Boolean(object.magic);
                return message;
            };

            /**
             * Creates a plain object from a VoiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {kritor.event.VoiceElement} message VoiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.url = "";
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = message.file;
                    if (options.oneofs)
                        object._file = "file";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    object.magic = message.magic;
                    if (options.oneofs)
                        object._magic = "magic";
                }
                return object;
            };

            /**
             * Converts this VoiceElement to JSON.
             * @function toJSON
             * @memberof kritor.event.VoiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoiceElement
             * @function getTypeUrl
             * @memberof kritor.event.VoiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.VoiceElement";
            };

            return VoiceElement;
        })();

        event.VideoElement = (function() {

            /**
             * Properties of a VideoElement.
             * @memberof kritor.event
             * @interface IVideoElement
             * @property {string|null} [file] VideoElement file
             * @property {string|null} [url] VideoElement url
             */

            /**
             * Constructs a new VideoElement.
             * @memberof kritor.event
             * @classdesc Represents a VideoElement.
             * @implements IVideoElement
             * @constructor
             * @param {kritor.event.IVideoElement=} [properties] Properties to set
             */
            function VideoElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VideoElement file.
             * @member {string} file
             * @memberof kritor.event.VideoElement
             * @instance
             */
            VideoElement.prototype.file = "";

            /**
             * VideoElement url.
             * @member {string} url
             * @memberof kritor.event.VideoElement
             * @instance
             */
            VideoElement.prototype.url = "";

            /**
             * Creates a new VideoElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.VideoElement
             * @static
             * @param {kritor.event.IVideoElement=} [properties] Properties to set
             * @returns {kritor.event.VideoElement} VideoElement instance
             */
            VideoElement.create = function create(properties) {
                return new VideoElement(properties);
            };

            /**
             * Encodes the specified VideoElement message. Does not implicitly {@link kritor.event.VideoElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.VideoElement
             * @static
             * @param {kritor.event.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified VideoElement message, length delimited. Does not implicitly {@link kritor.event.VideoElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.VideoElement
             * @static
             * @param {kritor.event.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.VideoElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VideoElement message.
             * @function verify
             * @memberof kritor.event.VideoElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VideoElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a VideoElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.VideoElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.VideoElement} VideoElement
             */
            VideoElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.VideoElement)
                    return object;
                let message = new $root.kritor.event.VideoElement();
                if (object.file != null)
                    message.file = String(object.file);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a VideoElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.VideoElement
             * @static
             * @param {kritor.event.VideoElement} message VideoElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VideoElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.file = "";
                    object.url = "";
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this VideoElement to JSON.
             * @function toJSON
             * @memberof kritor.event.VideoElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VideoElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VideoElement
             * @function getTypeUrl
             * @memberof kritor.event.VideoElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VideoElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.VideoElement";
            };

            return VideoElement;
        })();

        event.BasketballElement = (function() {

            /**
             * Properties of a BasketballElement.
             * @memberof kritor.event
             * @interface IBasketballElement
             * @property {number|null} [id] BasketballElement id
             */

            /**
             * Constructs a new BasketballElement.
             * @memberof kritor.event
             * @classdesc Represents a BasketballElement.
             * @implements IBasketballElement
             * @constructor
             * @param {kritor.event.IBasketballElement=} [properties] Properties to set
             */
            function BasketballElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BasketballElement id.
             * @member {number} id
             * @memberof kritor.event.BasketballElement
             * @instance
             */
            BasketballElement.prototype.id = 0;

            /**
             * Creates a new BasketballElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {kritor.event.IBasketballElement=} [properties] Properties to set
             * @returns {kritor.event.BasketballElement} BasketballElement instance
             */
            BasketballElement.create = function create(properties) {
                return new BasketballElement(properties);
            };

            /**
             * Encodes the specified BasketballElement message. Does not implicitly {@link kritor.event.BasketballElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {kritor.event.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified BasketballElement message, length delimited. Does not implicitly {@link kritor.event.BasketballElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {kritor.event.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.BasketballElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BasketballElement message.
             * @function verify
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BasketballElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a BasketballElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.BasketballElement} BasketballElement
             */
            BasketballElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.BasketballElement)
                    return object;
                let message = new $root.kritor.event.BasketballElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BasketballElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {kritor.event.BasketballElement} message BasketballElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BasketballElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this BasketballElement to JSON.
             * @function toJSON
             * @memberof kritor.event.BasketballElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BasketballElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BasketballElement
             * @function getTypeUrl
             * @memberof kritor.event.BasketballElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BasketballElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.BasketballElement";
            };

            return BasketballElement;
        })();

        event.DiceElement = (function() {

            /**
             * Properties of a DiceElement.
             * @memberof kritor.event
             * @interface IDiceElement
             * @property {number|null} [id] DiceElement id
             */

            /**
             * Constructs a new DiceElement.
             * @memberof kritor.event
             * @classdesc Represents a DiceElement.
             * @implements IDiceElement
             * @constructor
             * @param {kritor.event.IDiceElement=} [properties] Properties to set
             */
            function DiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiceElement id.
             * @member {number} id
             * @memberof kritor.event.DiceElement
             * @instance
             */
            DiceElement.prototype.id = 0;

            /**
             * Creates a new DiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.DiceElement
             * @static
             * @param {kritor.event.IDiceElement=} [properties] Properties to set
             * @returns {kritor.event.DiceElement} DiceElement instance
             */
            DiceElement.create = function create(properties) {
                return new DiceElement(properties);
            };

            /**
             * Encodes the specified DiceElement message. Does not implicitly {@link kritor.event.DiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.DiceElement
             * @static
             * @param {kritor.event.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified DiceElement message, length delimited. Does not implicitly {@link kritor.event.DiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.DiceElement
             * @static
             * @param {kritor.event.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.DiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiceElement message.
             * @function verify
             * @memberof kritor.event.DiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a DiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.DiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.DiceElement} DiceElement
             */
            DiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.DiceElement)
                    return object;
                let message = new $root.kritor.event.DiceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.DiceElement
             * @static
             * @param {kritor.event.DiceElement} message DiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DiceElement to JSON.
             * @function toJSON
             * @memberof kritor.event.DiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DiceElement
             * @function getTypeUrl
             * @memberof kritor.event.DiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.DiceElement";
            };

            return DiceElement;
        })();

        event.RpsElement = (function() {

            /**
             * Properties of a RpsElement.
             * @memberof kritor.event
             * @interface IRpsElement
             * @property {number|null} [id] RpsElement id
             */

            /**
             * Constructs a new RpsElement.
             * @memberof kritor.event
             * @classdesc Represents a RpsElement.
             * @implements IRpsElement
             * @constructor
             * @param {kritor.event.IRpsElement=} [properties] Properties to set
             */
            function RpsElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RpsElement id.
             * @member {number} id
             * @memberof kritor.event.RpsElement
             * @instance
             */
            RpsElement.prototype.id = 0;

            /**
             * Creates a new RpsElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.RpsElement
             * @static
             * @param {kritor.event.IRpsElement=} [properties] Properties to set
             * @returns {kritor.event.RpsElement} RpsElement instance
             */
            RpsElement.create = function create(properties) {
                return new RpsElement(properties);
            };

            /**
             * Encodes the specified RpsElement message. Does not implicitly {@link kritor.event.RpsElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RpsElement
             * @static
             * @param {kritor.event.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified RpsElement message, length delimited. Does not implicitly {@link kritor.event.RpsElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RpsElement
             * @static
             * @param {kritor.event.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RpsElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RpsElement message.
             * @function verify
             * @memberof kritor.event.RpsElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RpsElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a RpsElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RpsElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RpsElement} RpsElement
             */
            RpsElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RpsElement)
                    return object;
                let message = new $root.kritor.event.RpsElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RpsElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RpsElement
             * @static
             * @param {kritor.event.RpsElement} message RpsElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RpsElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this RpsElement to JSON.
             * @function toJSON
             * @memberof kritor.event.RpsElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RpsElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RpsElement
             * @function getTypeUrl
             * @memberof kritor.event.RpsElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RpsElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RpsElement";
            };

            return RpsElement;
        })();

        event.PokeElement = (function() {

            /**
             * Properties of a PokeElement.
             * @memberof kritor.event
             * @interface IPokeElement
             * @property {number|null} [id] PokeElement id
             * @property {number|null} [type] PokeElement type
             * @property {number|null} [strength] PokeElement strength
             */

            /**
             * Constructs a new PokeElement.
             * @memberof kritor.event
             * @classdesc Represents a PokeElement.
             * @implements IPokeElement
             * @constructor
             * @param {kritor.event.IPokeElement=} [properties] Properties to set
             */
            function PokeElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeElement id.
             * @member {number} id
             * @memberof kritor.event.PokeElement
             * @instance
             */
            PokeElement.prototype.id = 0;

            /**
             * PokeElement type.
             * @member {number} type
             * @memberof kritor.event.PokeElement
             * @instance
             */
            PokeElement.prototype.type = 0;

            /**
             * PokeElement strength.
             * @member {number} strength
             * @memberof kritor.event.PokeElement
             * @instance
             */
            PokeElement.prototype.strength = 0;

            /**
             * Creates a new PokeElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.PokeElement
             * @static
             * @param {kritor.event.IPokeElement=} [properties] Properties to set
             * @returns {kritor.event.PokeElement} PokeElement instance
             */
            PokeElement.create = function create(properties) {
                return new PokeElement(properties);
            };

            /**
             * Encodes the specified PokeElement message. Does not implicitly {@link kritor.event.PokeElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.PokeElement
             * @static
             * @param {kritor.event.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
                if (message.strength != null && Object.hasOwnProperty.call(message, "strength"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.strength);
                return writer;
            };

            /**
             * Encodes the specified PokeElement message, length delimited. Does not implicitly {@link kritor.event.PokeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.PokeElement
             * @static
             * @param {kritor.event.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.PokeElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.strength = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeElement message.
             * @function verify
             * @memberof kritor.event.PokeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.strength != null && message.hasOwnProperty("strength"))
                    if (!$util.isInteger(message.strength))
                        return "strength: integer expected";
                return null;
            };

            /**
             * Creates a PokeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.PokeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.PokeElement} PokeElement
             */
            PokeElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.PokeElement)
                    return object;
                let message = new $root.kritor.event.PokeElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.strength != null)
                    message.strength = object.strength >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a PokeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.PokeElement
             * @static
             * @param {kritor.event.PokeElement} message PokeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.type = 0;
                    object.strength = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.strength != null && message.hasOwnProperty("strength"))
                    object.strength = message.strength;
                return object;
            };

            /**
             * Converts this PokeElement to JSON.
             * @function toJSON
             * @memberof kritor.event.PokeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeElement
             * @function getTypeUrl
             * @memberof kritor.event.PokeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.PokeElement";
            };

            return PokeElement;
        })();

        /**
         * MusicPlatform enum.
         * @name kritor.event.MusicPlatform
         * @enum {number}
         * @property {number} QQ=0 QQ value
         * @property {number} NetEase=1 NetEase value
         * @property {number} Custom=10 Custom value
         */
        event.MusicPlatform = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "QQ"] = 0;
            values[valuesById[1] = "NetEase"] = 1;
            values[valuesById[10] = "Custom"] = 10;
            return values;
        })();

        event.CustomMusicData = (function() {

            /**
             * Properties of a CustomMusicData.
             * @memberof kritor.event
             * @interface ICustomMusicData
             * @property {string|null} [url] CustomMusicData url
             * @property {string|null} [audio] CustomMusicData audio
             * @property {string|null} [title] CustomMusicData title
             * @property {string|null} [author] CustomMusicData author
             * @property {string|null} [pic] CustomMusicData pic
             */

            /**
             * Constructs a new CustomMusicData.
             * @memberof kritor.event
             * @classdesc Represents a CustomMusicData.
             * @implements ICustomMusicData
             * @constructor
             * @param {kritor.event.ICustomMusicData=} [properties] Properties to set
             */
            function CustomMusicData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomMusicData url.
             * @member {string} url
             * @memberof kritor.event.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.url = "";

            /**
             * CustomMusicData audio.
             * @member {string} audio
             * @memberof kritor.event.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.audio = "";

            /**
             * CustomMusicData title.
             * @member {string} title
             * @memberof kritor.event.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.title = "";

            /**
             * CustomMusicData author.
             * @member {string} author
             * @memberof kritor.event.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.author = "";

            /**
             * CustomMusicData pic.
             * @member {string} pic
             * @memberof kritor.event.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.pic = "";

            /**
             * Creates a new CustomMusicData instance using the specified properties.
             * @function create
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {kritor.event.ICustomMusicData=} [properties] Properties to set
             * @returns {kritor.event.CustomMusicData} CustomMusicData instance
             */
            CustomMusicData.create = function create(properties) {
                return new CustomMusicData(properties);
            };

            /**
             * Encodes the specified CustomMusicData message. Does not implicitly {@link kritor.event.CustomMusicData.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {kritor.event.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.audio);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.author);
                if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.pic);
                return writer;
            };

            /**
             * Encodes the specified CustomMusicData message, length delimited. Does not implicitly {@link kritor.event.CustomMusicData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {kritor.event.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.CustomMusicData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.audio = reader.string();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.author = reader.string();
                            break;
                        }
                    case 5: {
                            message.pic = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomMusicData message.
             * @function verify
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomMusicData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.audio != null && message.hasOwnProperty("audio"))
                    if (!$util.isString(message.audio))
                        return "audio: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.author != null && message.hasOwnProperty("author"))
                    if (!$util.isString(message.author))
                        return "author: string expected";
                if (message.pic != null && message.hasOwnProperty("pic"))
                    if (!$util.isString(message.pic))
                        return "pic: string expected";
                return null;
            };

            /**
             * Creates a CustomMusicData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.CustomMusicData} CustomMusicData
             */
            CustomMusicData.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.CustomMusicData)
                    return object;
                let message = new $root.kritor.event.CustomMusicData();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.audio != null)
                    message.audio = String(object.audio);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.author != null)
                    message.author = String(object.author);
                if (object.pic != null)
                    message.pic = String(object.pic);
                return message;
            };

            /**
             * Creates a plain object from a CustomMusicData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {kritor.event.CustomMusicData} message CustomMusicData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomMusicData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.audio = "";
                    object.title = "";
                    object.author = "";
                    object.pic = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.audio != null && message.hasOwnProperty("audio"))
                    object.audio = message.audio;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.author != null && message.hasOwnProperty("author"))
                    object.author = message.author;
                if (message.pic != null && message.hasOwnProperty("pic"))
                    object.pic = message.pic;
                return object;
            };

            /**
             * Converts this CustomMusicData to JSON.
             * @function toJSON
             * @memberof kritor.event.CustomMusicData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomMusicData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CustomMusicData
             * @function getTypeUrl
             * @memberof kritor.event.CustomMusicData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CustomMusicData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.CustomMusicData";
            };

            return CustomMusicData;
        })();

        event.MusicElement = (function() {

            /**
             * Properties of a MusicElement.
             * @memberof kritor.event
             * @interface IMusicElement
             * @property {kritor.event.MusicPlatform|null} [platform] MusicElement platform
             * @property {string|null} [id] MusicElement id
             * @property {kritor.event.ICustomMusicData|null} [custom] MusicElement custom
             */

            /**
             * Constructs a new MusicElement.
             * @memberof kritor.event
             * @classdesc Represents a MusicElement.
             * @implements IMusicElement
             * @constructor
             * @param {kritor.event.IMusicElement=} [properties] Properties to set
             */
            function MusicElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MusicElement platform.
             * @member {kritor.event.MusicPlatform} platform
             * @memberof kritor.event.MusicElement
             * @instance
             */
            MusicElement.prototype.platform = 0;

            /**
             * MusicElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.event.MusicElement
             * @instance
             */
            MusicElement.prototype.id = null;

            /**
             * MusicElement custom.
             * @member {kritor.event.ICustomMusicData|null|undefined} custom
             * @memberof kritor.event.MusicElement
             * @instance
             */
            MusicElement.prototype.custom = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MusicElement data.
             * @member {"id"|"custom"|undefined} data
             * @memberof kritor.event.MusicElement
             * @instance
             */
            Object.defineProperty(MusicElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["id", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MusicElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.MusicElement
             * @static
             * @param {kritor.event.IMusicElement=} [properties] Properties to set
             * @returns {kritor.event.MusicElement} MusicElement instance
             */
            MusicElement.create = function create(properties) {
                return new MusicElement(properties);
            };

            /**
             * Encodes the specified MusicElement message. Does not implicitly {@link kritor.event.MusicElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.MusicElement
             * @static
             * @param {kritor.event.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
                    $root.kritor.event.CustomMusicData.encode(message.custom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MusicElement message, length delimited. Does not implicitly {@link kritor.event.MusicElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.MusicElement
             * @static
             * @param {kritor.event.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.MusicElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.platform = reader.int32();
                            break;
                        }
                    case 2: {
                            message.id = reader.string();
                            break;
                        }
                    case 3: {
                            message.custom = $root.kritor.event.CustomMusicData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MusicElement message.
             * @function verify
             * @memberof kritor.event.MusicElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MusicElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 10:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties.data = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.event.CustomMusicData.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MusicElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.MusicElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.MusicElement} MusicElement
             */
            MusicElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.MusicElement)
                    return object;
                let message = new $root.kritor.event.MusicElement();
                switch (object.platform) {
                default:
                    if (typeof object.platform === "number") {
                        message.platform = object.platform;
                        break;
                    }
                    break;
                case "QQ":
                case 0:
                    message.platform = 0;
                    break;
                case "NetEase":
                case 1:
                    message.platform = 1;
                    break;
                case "Custom":
                case 10:
                    message.platform = 10;
                    break;
                }
                if (object.id != null)
                    message.id = String(object.id);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".kritor.event.MusicElement.custom: object expected");
                    message.custom = $root.kritor.event.CustomMusicData.fromObject(object.custom);
                }
                return message;
            };

            /**
             * Creates a plain object from a MusicElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.MusicElement
             * @static
             * @param {kritor.event.MusicElement} message MusicElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MusicElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.platform = options.enums === String ? "QQ" : 0;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.kritor.event.MusicPlatform[message.platform] === undefined ? message.platform : $root.kritor.event.MusicPlatform[message.platform] : message.platform;
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object.data = "id";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.kritor.event.CustomMusicData.toObject(message.custom, options);
                    if (options.oneofs)
                        object.data = "custom";
                }
                return object;
            };

            /**
             * Converts this MusicElement to JSON.
             * @function toJSON
             * @memberof kritor.event.MusicElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MusicElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MusicElement
             * @function getTypeUrl
             * @memberof kritor.event.MusicElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MusicElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.MusicElement";
            };

            return MusicElement;
        })();

        event.WeatherElement = (function() {

            /**
             * Properties of a WeatherElement.
             * @memberof kritor.event
             * @interface IWeatherElement
             * @property {string|null} [city] WeatherElement city
             * @property {string|null} [code] WeatherElement code
             */

            /**
             * Constructs a new WeatherElement.
             * @memberof kritor.event
             * @classdesc Represents a WeatherElement.
             * @implements IWeatherElement
             * @constructor
             * @param {kritor.event.IWeatherElement=} [properties] Properties to set
             */
            function WeatherElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeatherElement city.
             * @member {string} city
             * @memberof kritor.event.WeatherElement
             * @instance
             */
            WeatherElement.prototype.city = "";

            /**
             * WeatherElement code.
             * @member {string} code
             * @memberof kritor.event.WeatherElement
             * @instance
             */
            WeatherElement.prototype.code = "";

            /**
             * Creates a new WeatherElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {kritor.event.IWeatherElement=} [properties] Properties to set
             * @returns {kritor.event.WeatherElement} WeatherElement instance
             */
            WeatherElement.create = function create(properties) {
                return new WeatherElement(properties);
            };

            /**
             * Encodes the specified WeatherElement message. Does not implicitly {@link kritor.event.WeatherElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {kritor.event.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.city);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
                return writer;
            };

            /**
             * Encodes the specified WeatherElement message, length delimited. Does not implicitly {@link kritor.event.WeatherElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {kritor.event.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.WeatherElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.city = reader.string();
                            break;
                        }
                    case 2: {
                            message.code = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeatherElement message.
             * @function verify
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeatherElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.city != null && message.hasOwnProperty("city"))
                    if (!$util.isString(message.city))
                        return "city: string expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                return null;
            };

            /**
             * Creates a WeatherElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.WeatherElement} WeatherElement
             */
            WeatherElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.WeatherElement)
                    return object;
                let message = new $root.kritor.event.WeatherElement();
                if (object.city != null)
                    message.city = String(object.city);
                if (object.code != null)
                    message.code = String(object.code);
                return message;
            };

            /**
             * Creates a plain object from a WeatherElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {kritor.event.WeatherElement} message WeatherElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WeatherElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.city = "";
                    object.code = "";
                }
                if (message.city != null && message.hasOwnProperty("city"))
                    object.city = message.city;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                return object;
            };

            /**
             * Converts this WeatherElement to JSON.
             * @function toJSON
             * @memberof kritor.event.WeatherElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WeatherElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WeatherElement
             * @function getTypeUrl
             * @memberof kritor.event.WeatherElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WeatherElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.WeatherElement";
            };

            return WeatherElement;
        })();

        event.LocationElement = (function() {

            /**
             * Properties of a LocationElement.
             * @memberof kritor.event
             * @interface ILocationElement
             * @property {number|null} [lat] LocationElement lat
             * @property {number|null} [lon] LocationElement lon
             * @property {string|null} [title] LocationElement title
             * @property {string|null} [address] LocationElement address
             */

            /**
             * Constructs a new LocationElement.
             * @memberof kritor.event
             * @classdesc Represents a LocationElement.
             * @implements ILocationElement
             * @constructor
             * @param {kritor.event.ILocationElement=} [properties] Properties to set
             */
            function LocationElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationElement lat.
             * @member {number} lat
             * @memberof kritor.event.LocationElement
             * @instance
             */
            LocationElement.prototype.lat = 0;

            /**
             * LocationElement lon.
             * @member {number} lon
             * @memberof kritor.event.LocationElement
             * @instance
             */
            LocationElement.prototype.lon = 0;

            /**
             * LocationElement title.
             * @member {string} title
             * @memberof kritor.event.LocationElement
             * @instance
             */
            LocationElement.prototype.title = "";

            /**
             * LocationElement address.
             * @member {string} address
             * @memberof kritor.event.LocationElement
             * @instance
             */
            LocationElement.prototype.address = "";

            /**
             * Creates a new LocationElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.LocationElement
             * @static
             * @param {kritor.event.ILocationElement=} [properties] Properties to set
             * @returns {kritor.event.LocationElement} LocationElement instance
             */
            LocationElement.create = function create(properties) {
                return new LocationElement(properties);
            };

            /**
             * Encodes the specified LocationElement message. Does not implicitly {@link kritor.event.LocationElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.LocationElement
             * @static
             * @param {kritor.event.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.lat);
                if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.lon);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified LocationElement message, length delimited. Does not implicitly {@link kritor.event.LocationElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.LocationElement
             * @static
             * @param {kritor.event.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.LocationElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.lat = reader.float();
                            break;
                        }
                    case 2: {
                            message.lon = reader.float();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.address = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationElement message.
             * @function verify
             * @memberof kritor.event.LocationElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lat != null && message.hasOwnProperty("lat"))
                    if (typeof message.lat !== "number")
                        return "lat: number expected";
                if (message.lon != null && message.hasOwnProperty("lon"))
                    if (typeof message.lon !== "number")
                        return "lon: number expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a LocationElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.LocationElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.LocationElement} LocationElement
             */
            LocationElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.LocationElement)
                    return object;
                let message = new $root.kritor.event.LocationElement();
                if (object.lat != null)
                    message.lat = Number(object.lat);
                if (object.lon != null)
                    message.lon = Number(object.lon);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a LocationElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.LocationElement
             * @static
             * @param {kritor.event.LocationElement} message LocationElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lat = 0;
                    object.lon = 0;
                    object.title = "";
                    object.address = "";
                }
                if (message.lat != null && message.hasOwnProperty("lat"))
                    object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
                if (message.lon != null && message.hasOwnProperty("lon"))
                    object.lon = options.json && !isFinite(message.lon) ? String(message.lon) : message.lon;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this LocationElement to JSON.
             * @function toJSON
             * @memberof kritor.event.LocationElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocationElement
             * @function getTypeUrl
             * @memberof kritor.event.LocationElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocationElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.LocationElement";
            };

            return LocationElement;
        })();

        event.ShareElement = (function() {

            /**
             * Properties of a ShareElement.
             * @memberof kritor.event
             * @interface IShareElement
             * @property {string|null} [url] ShareElement url
             * @property {string|null} [title] ShareElement title
             * @property {string|null} [content] ShareElement content
             * @property {string|null} [image] ShareElement image
             */

            /**
             * Constructs a new ShareElement.
             * @memberof kritor.event
             * @classdesc Represents a ShareElement.
             * @implements IShareElement
             * @constructor
             * @param {kritor.event.IShareElement=} [properties] Properties to set
             */
            function ShareElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShareElement url.
             * @member {string} url
             * @memberof kritor.event.ShareElement
             * @instance
             */
            ShareElement.prototype.url = "";

            /**
             * ShareElement title.
             * @member {string} title
             * @memberof kritor.event.ShareElement
             * @instance
             */
            ShareElement.prototype.title = "";

            /**
             * ShareElement content.
             * @member {string} content
             * @memberof kritor.event.ShareElement
             * @instance
             */
            ShareElement.prototype.content = "";

            /**
             * ShareElement image.
             * @member {string} image
             * @memberof kritor.event.ShareElement
             * @instance
             */
            ShareElement.prototype.image = "";

            /**
             * Creates a new ShareElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.ShareElement
             * @static
             * @param {kritor.event.IShareElement=} [properties] Properties to set
             * @returns {kritor.event.ShareElement} ShareElement instance
             */
            ShareElement.create = function create(properties) {
                return new ShareElement(properties);
            };

            /**
             * Encodes the specified ShareElement message. Does not implicitly {@link kritor.event.ShareElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ShareElement
             * @static
             * @param {kritor.event.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.image);
                return writer;
            };

            /**
             * Encodes the specified ShareElement message, length delimited. Does not implicitly {@link kritor.event.ShareElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ShareElement
             * @static
             * @param {kritor.event.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ShareElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.content = reader.string();
                            break;
                        }
                    case 4: {
                            message.image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShareElement message.
             * @function verify
             * @memberof kritor.event.ShareElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShareElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                if (message.image != null && message.hasOwnProperty("image"))
                    if (!$util.isString(message.image))
                        return "image: string expected";
                return null;
            };

            /**
             * Creates a ShareElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ShareElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ShareElement} ShareElement
             */
            ShareElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ShareElement)
                    return object;
                let message = new $root.kritor.event.ShareElement();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.content != null)
                    message.content = String(object.content);
                if (object.image != null)
                    message.image = String(object.image);
                return message;
            };

            /**
             * Creates a plain object from a ShareElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ShareElement
             * @static
             * @param {kritor.event.ShareElement} message ShareElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShareElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.title = "";
                    object.content = "";
                    object.image = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = message.image;
                return object;
            };

            /**
             * Converts this ShareElement to JSON.
             * @function toJSON
             * @memberof kritor.event.ShareElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShareElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShareElement
             * @function getTypeUrl
             * @memberof kritor.event.ShareElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShareElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ShareElement";
            };

            return ShareElement;
        })();

        event.GiftElement = (function() {

            /**
             * Properties of a GiftElement.
             * @memberof kritor.event
             * @interface IGiftElement
             * @property {number|Long|null} [qq] GiftElement qq
             * @property {number|null} [id] GiftElement id
             */

            /**
             * Constructs a new GiftElement.
             * @memberof kritor.event
             * @classdesc Represents a GiftElement.
             * @implements IGiftElement
             * @constructor
             * @param {kritor.event.IGiftElement=} [properties] Properties to set
             */
            function GiftElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GiftElement qq.
             * @member {number|Long} qq
             * @memberof kritor.event.GiftElement
             * @instance
             */
            GiftElement.prototype.qq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GiftElement id.
             * @member {number} id
             * @memberof kritor.event.GiftElement
             * @instance
             */
            GiftElement.prototype.id = 0;

            /**
             * Creates a new GiftElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.GiftElement
             * @static
             * @param {kritor.event.IGiftElement=} [properties] Properties to set
             * @returns {kritor.event.GiftElement} GiftElement instance
             */
            GiftElement.create = function create(properties) {
                return new GiftElement(properties);
            };

            /**
             * Encodes the specified GiftElement message. Does not implicitly {@link kritor.event.GiftElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GiftElement
             * @static
             * @param {kritor.event.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.qq != null && Object.hasOwnProperty.call(message, "qq"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.qq);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified GiftElement message, length delimited. Does not implicitly {@link kritor.event.GiftElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GiftElement
             * @static
             * @param {kritor.event.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GiftElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.qq = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GiftElement message.
             * @function verify
             * @memberof kritor.event.GiftElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GiftElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (!$util.isInteger(message.qq) && !(message.qq && $util.isInteger(message.qq.low) && $util.isInteger(message.qq.high)))
                        return "qq: integer|Long expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a GiftElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GiftElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GiftElement} GiftElement
             */
            GiftElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GiftElement)
                    return object;
                let message = new $root.kritor.event.GiftElement();
                if (object.qq != null)
                    if ($util.Long)
                        (message.qq = $util.Long.fromValue(object.qq)).unsigned = true;
                    else if (typeof object.qq === "string")
                        message.qq = parseInt(object.qq, 10);
                    else if (typeof object.qq === "number")
                        message.qq = object.qq;
                    else if (typeof object.qq === "object")
                        message.qq = new $util.LongBits(object.qq.low >>> 0, object.qq.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GiftElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GiftElement
             * @static
             * @param {kritor.event.GiftElement} message GiftElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GiftElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.qq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.qq = options.longs === String ? "0" : 0;
                    object.id = 0;
                }
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (typeof message.qq === "number")
                        object.qq = options.longs === String ? String(message.qq) : message.qq;
                    else
                        object.qq = options.longs === String ? $util.Long.prototype.toString.call(message.qq) : options.longs === Number ? new $util.LongBits(message.qq.low >>> 0, message.qq.high >>> 0).toNumber(true) : message.qq;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GiftElement to JSON.
             * @function toJSON
             * @memberof kritor.event.GiftElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GiftElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GiftElement
             * @function getTypeUrl
             * @memberof kritor.event.GiftElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GiftElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GiftElement";
            };

            return GiftElement;
        })();

        event.MarketFaceElement = (function() {

            /**
             * Properties of a MarketFaceElement.
             * @memberof kritor.event
             * @interface IMarketFaceElement
             * @property {string|null} [id] MarketFaceElement id
             */

            /**
             * Constructs a new MarketFaceElement.
             * @memberof kritor.event
             * @classdesc Represents a MarketFaceElement.
             * @implements IMarketFaceElement
             * @constructor
             * @param {kritor.event.IMarketFaceElement=} [properties] Properties to set
             */
            function MarketFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarketFaceElement id.
             * @member {string} id
             * @memberof kritor.event.MarketFaceElement
             * @instance
             */
            MarketFaceElement.prototype.id = "";

            /**
             * Creates a new MarketFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {kritor.event.IMarketFaceElement=} [properties] Properties to set
             * @returns {kritor.event.MarketFaceElement} MarketFaceElement instance
             */
            MarketFaceElement.create = function create(properties) {
                return new MarketFaceElement(properties);
            };

            /**
             * Encodes the specified MarketFaceElement message. Does not implicitly {@link kritor.event.MarketFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {kritor.event.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified MarketFaceElement message, length delimited. Does not implicitly {@link kritor.event.MarketFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {kritor.event.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.MarketFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarketFaceElement message.
             * @function verify
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarketFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a MarketFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.MarketFaceElement} MarketFaceElement
             */
            MarketFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.MarketFaceElement)
                    return object;
                let message = new $root.kritor.event.MarketFaceElement();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a MarketFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {kritor.event.MarketFaceElement} message MarketFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarketFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this MarketFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.event.MarketFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarketFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarketFaceElement
             * @function getTypeUrl
             * @memberof kritor.event.MarketFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarketFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.MarketFaceElement";
            };

            return MarketFaceElement;
        })();

        event.ForwardElement = (function() {

            /**
             * Properties of a ForwardElement.
             * @memberof kritor.event
             * @interface IForwardElement
             * @property {string|null} [id] ForwardElement id
             * @property {string|null} [uniseq] ForwardElement uniseq
             * @property {string|null} [summary] ForwardElement summary
             * @property {string|null} [description] ForwardElement description
             */

            /**
             * Constructs a new ForwardElement.
             * @memberof kritor.event
             * @classdesc Represents a ForwardElement.
             * @implements IForwardElement
             * @constructor
             * @param {kritor.event.IForwardElement=} [properties] Properties to set
             */
            function ForwardElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardElement id.
             * @member {string} id
             * @memberof kritor.event.ForwardElement
             * @instance
             */
            ForwardElement.prototype.id = "";

            /**
             * ForwardElement uniseq.
             * @member {string} uniseq
             * @memberof kritor.event.ForwardElement
             * @instance
             */
            ForwardElement.prototype.uniseq = "";

            /**
             * ForwardElement summary.
             * @member {string} summary
             * @memberof kritor.event.ForwardElement
             * @instance
             */
            ForwardElement.prototype.summary = "";

            /**
             * ForwardElement description.
             * @member {string} description
             * @memberof kritor.event.ForwardElement
             * @instance
             */
            ForwardElement.prototype.description = "";

            /**
             * Creates a new ForwardElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {kritor.event.IForwardElement=} [properties] Properties to set
             * @returns {kritor.event.ForwardElement} ForwardElement instance
             */
            ForwardElement.create = function create(properties) {
                return new ForwardElement(properties);
            };

            /**
             * Encodes the specified ForwardElement message. Does not implicitly {@link kritor.event.ForwardElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {kritor.event.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.uniseq != null && Object.hasOwnProperty.call(message, "uniseq"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uniseq);
                if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.summary);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified ForwardElement message, length delimited. Does not implicitly {@link kritor.event.ForwardElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {kritor.event.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ForwardElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.uniseq = reader.string();
                            break;
                        }
                    case 3: {
                            message.summary = reader.string();
                            break;
                        }
                    case 4: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardElement message.
             * @function verify
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    if (!$util.isString(message.uniseq))
                        return "uniseq: string expected";
                if (message.summary != null && message.hasOwnProperty("summary"))
                    if (!$util.isString(message.summary))
                        return "summary: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a ForwardElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ForwardElement} ForwardElement
             */
            ForwardElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ForwardElement)
                    return object;
                let message = new $root.kritor.event.ForwardElement();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.uniseq != null)
                    message.uniseq = String(object.uniseq);
                if (object.summary != null)
                    message.summary = String(object.summary);
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a ForwardElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {kritor.event.ForwardElement} message ForwardElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.uniseq = "";
                    object.summary = "";
                    object.description = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    object.uniseq = message.uniseq;
                if (message.summary != null && message.hasOwnProperty("summary"))
                    object.summary = message.summary;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this ForwardElement to JSON.
             * @function toJSON
             * @memberof kritor.event.ForwardElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardElement
             * @function getTypeUrl
             * @memberof kritor.event.ForwardElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ForwardElement";
            };

            return ForwardElement;
        })();

        event.ContactElement = (function() {

            /**
             * Properties of a ContactElement.
             * @memberof kritor.event
             * @interface IContactElement
             * @property {kritor.event.Scene|null} [scene] ContactElement scene
             * @property {string|null} [peer] ContactElement peer
             */

            /**
             * Constructs a new ContactElement.
             * @memberof kritor.event
             * @classdesc Represents a ContactElement.
             * @implements IContactElement
             * @constructor
             * @param {kritor.event.IContactElement=} [properties] Properties to set
             */
            function ContactElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactElement scene.
             * @member {kritor.event.Scene} scene
             * @memberof kritor.event.ContactElement
             * @instance
             */
            ContactElement.prototype.scene = 0;

            /**
             * ContactElement peer.
             * @member {string} peer
             * @memberof kritor.event.ContactElement
             * @instance
             */
            ContactElement.prototype.peer = "";

            /**
             * Creates a new ContactElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.ContactElement
             * @static
             * @param {kritor.event.IContactElement=} [properties] Properties to set
             * @returns {kritor.event.ContactElement} ContactElement instance
             */
            ContactElement.create = function create(properties) {
                return new ContactElement(properties);
            };

            /**
             * Encodes the specified ContactElement message. Does not implicitly {@link kritor.event.ContactElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ContactElement
             * @static
             * @param {kritor.event.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                return writer;
            };

            /**
             * Encodes the specified ContactElement message, length delimited. Does not implicitly {@link kritor.event.ContactElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ContactElement
             * @static
             * @param {kritor.event.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ContactElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactElement message.
             * @function verify
             * @memberof kritor.event.ContactElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                return null;
            };

            /**
             * Creates a ContactElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ContactElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ContactElement} ContactElement
             */
            ContactElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ContactElement)
                    return object;
                let message = new $root.kritor.event.ContactElement();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                return message;
            };

            /**
             * Creates a plain object from a ContactElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ContactElement
             * @static
             * @param {kritor.event.ContactElement} message ContactElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.event.Scene[message.scene] === undefined ? message.scene : $root.kritor.event.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                return object;
            };

            /**
             * Converts this ContactElement to JSON.
             * @function toJSON
             * @memberof kritor.event.ContactElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ContactElement
             * @function getTypeUrl
             * @memberof kritor.event.ContactElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ContactElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ContactElement";
            };

            return ContactElement;
        })();

        event.JsonElement = (function() {

            /**
             * Properties of a JsonElement.
             * @memberof kritor.event
             * @interface IJsonElement
             * @property {string|null} [json] JsonElement json
             */

            /**
             * Constructs a new JsonElement.
             * @memberof kritor.event
             * @classdesc Represents a JsonElement.
             * @implements IJsonElement
             * @constructor
             * @param {kritor.event.IJsonElement=} [properties] Properties to set
             */
            function JsonElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JsonElement json.
             * @member {string} json
             * @memberof kritor.event.JsonElement
             * @instance
             */
            JsonElement.prototype.json = "";

            /**
             * Creates a new JsonElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.JsonElement
             * @static
             * @param {kritor.event.IJsonElement=} [properties] Properties to set
             * @returns {kritor.event.JsonElement} JsonElement instance
             */
            JsonElement.create = function create(properties) {
                return new JsonElement(properties);
            };

            /**
             * Encodes the specified JsonElement message. Does not implicitly {@link kritor.event.JsonElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.JsonElement
             * @static
             * @param {kritor.event.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
                return writer;
            };

            /**
             * Encodes the specified JsonElement message, length delimited. Does not implicitly {@link kritor.event.JsonElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.JsonElement
             * @static
             * @param {kritor.event.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.JsonElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.json = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JsonElement message.
             * @function verify
             * @memberof kritor.event.JsonElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JsonElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.json != null && message.hasOwnProperty("json"))
                    if (!$util.isString(message.json))
                        return "json: string expected";
                return null;
            };

            /**
             * Creates a JsonElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.JsonElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.JsonElement} JsonElement
             */
            JsonElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.JsonElement)
                    return object;
                let message = new $root.kritor.event.JsonElement();
                if (object.json != null)
                    message.json = String(object.json);
                return message;
            };

            /**
             * Creates a plain object from a JsonElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.JsonElement
             * @static
             * @param {kritor.event.JsonElement} message JsonElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JsonElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.json = "";
                if (message.json != null && message.hasOwnProperty("json"))
                    object.json = message.json;
                return object;
            };

            /**
             * Converts this JsonElement to JSON.
             * @function toJSON
             * @memberof kritor.event.JsonElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JsonElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JsonElement
             * @function getTypeUrl
             * @memberof kritor.event.JsonElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JsonElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.JsonElement";
            };

            return JsonElement;
        })();

        event.XmlElement = (function() {

            /**
             * Properties of a XmlElement.
             * @memberof kritor.event
             * @interface IXmlElement
             * @property {string|null} [xml] XmlElement xml
             */

            /**
             * Constructs a new XmlElement.
             * @memberof kritor.event
             * @classdesc Represents a XmlElement.
             * @implements IXmlElement
             * @constructor
             * @param {kritor.event.IXmlElement=} [properties] Properties to set
             */
            function XmlElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * XmlElement xml.
             * @member {string} xml
             * @memberof kritor.event.XmlElement
             * @instance
             */
            XmlElement.prototype.xml = "";

            /**
             * Creates a new XmlElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.XmlElement
             * @static
             * @param {kritor.event.IXmlElement=} [properties] Properties to set
             * @returns {kritor.event.XmlElement} XmlElement instance
             */
            XmlElement.create = function create(properties) {
                return new XmlElement(properties);
            };

            /**
             * Encodes the specified XmlElement message. Does not implicitly {@link kritor.event.XmlElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.XmlElement
             * @static
             * @param {kritor.event.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.xml);
                return writer;
            };

            /**
             * Encodes the specified XmlElement message, length delimited. Does not implicitly {@link kritor.event.XmlElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.XmlElement
             * @static
             * @param {kritor.event.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.XmlElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.xml = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a XmlElement message.
             * @function verify
             * @memberof kritor.event.XmlElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            XmlElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    if (!$util.isString(message.xml))
                        return "xml: string expected";
                return null;
            };

            /**
             * Creates a XmlElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.XmlElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.XmlElement} XmlElement
             */
            XmlElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.XmlElement)
                    return object;
                let message = new $root.kritor.event.XmlElement();
                if (object.xml != null)
                    message.xml = String(object.xml);
                return message;
            };

            /**
             * Creates a plain object from a XmlElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.XmlElement
             * @static
             * @param {kritor.event.XmlElement} message XmlElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            XmlElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.xml = "";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    object.xml = message.xml;
                return object;
            };

            /**
             * Converts this XmlElement to JSON.
             * @function toJSON
             * @memberof kritor.event.XmlElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            XmlElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for XmlElement
             * @function getTypeUrl
             * @memberof kritor.event.XmlElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            XmlElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.XmlElement";
            };

            return XmlElement;
        })();

        event.FileElement = (function() {

            /**
             * Properties of a FileElement.
             * @memberof kritor.event
             * @interface IFileElement
             * @property {string|null} [name] FileElement name
             * @property {number|Long|null} [size] FileElement size
             * @property {number|Long|null} [expireTime] FileElement expireTime
             * @property {string|null} [id] FileElement id
             * @property {string|null} [url] FileElement url
             * @property {number|null} [biz] FileElement biz
             * @property {string|null} [subId] FileElement subId
             */

            /**
             * Constructs a new FileElement.
             * @memberof kritor.event
             * @classdesc Represents a FileElement.
             * @implements IFileElement
             * @constructor
             * @param {kritor.event.IFileElement=} [properties] Properties to set
             */
            function FileElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileElement name.
             * @member {string} name
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.name = "";

            /**
             * FileElement size.
             * @member {number|Long} size
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FileElement expireTime.
             * @member {number|Long} expireTime
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.expireTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FileElement id.
             * @member {string} id
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.id = "";

            /**
             * FileElement url.
             * @member {string} url
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.url = "";

            /**
             * FileElement biz.
             * @member {number} biz
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.biz = 0;

            /**
             * FileElement subId.
             * @member {string} subId
             * @memberof kritor.event.FileElement
             * @instance
             */
            FileElement.prototype.subId = "";

            /**
             * Creates a new FileElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.FileElement
             * @static
             * @param {kritor.event.IFileElement=} [properties] Properties to set
             * @returns {kritor.event.FileElement} FileElement instance
             */
            FileElement.create = function create(properties) {
                return new FileElement(properties);
            };

            /**
             * Encodes the specified FileElement message. Does not implicitly {@link kritor.event.FileElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FileElement
             * @static
             * @param {kritor.event.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.size);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.expireTime);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.id);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.biz);
                if (message.subId != null && Object.hasOwnProperty.call(message, "subId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.subId);
                return writer;
            };

            /**
             * Encodes the specified FileElement message, length delimited. Does not implicitly {@link kritor.event.FileElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FileElement
             * @static
             * @param {kritor.event.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FileElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.size = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.expireTime = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.id = reader.string();
                            break;
                        }
                    case 5: {
                            message.url = reader.string();
                            break;
                        }
                    case 6: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 7: {
                            message.subId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileElement message.
             * @function verify
             * @memberof kritor.event.FileElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                        return "expireTime: integer|Long expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.biz != null && message.hasOwnProperty("biz"))
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                if (message.subId != null && message.hasOwnProperty("subId"))
                    if (!$util.isString(message.subId))
                        return "subId: string expected";
                return null;
            };

            /**
             * Creates a FileElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FileElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FileElement} FileElement
             */
            FileElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FileElement)
                    return object;
                let message = new $root.kritor.event.FileElement();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    if ($util.Long)
                        (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = true;
                    else if (typeof object.expireTime === "string")
                        message.expireTime = parseInt(object.expireTime, 10);
                    else if (typeof object.expireTime === "number")
                        message.expireTime = object.expireTime;
                    else if (typeof object.expireTime === "object")
                        message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.subId != null)
                    message.subId = String(object.subId);
                return message;
            };

            /**
             * Creates a plain object from a FileElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FileElement
             * @static
             * @param {kritor.event.FileElement} message FileElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.size = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.expireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expireTime = options.longs === String ? "0" : 0;
                    object.id = "";
                    object.url = "";
                    object.biz = 0;
                    object.subId = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.size != null && message.hasOwnProperty("size"))
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (typeof message.expireTime === "number")
                        object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                    else
                        object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber(true) : message.expireTime;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.biz != null && message.hasOwnProperty("biz"))
                    object.biz = message.biz;
                if (message.subId != null && message.hasOwnProperty("subId"))
                    object.subId = message.subId;
                return object;
            };

            /**
             * Converts this FileElement to JSON.
             * @function toJSON
             * @memberof kritor.event.FileElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileElement
             * @function getTypeUrl
             * @memberof kritor.event.FileElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FileElement";
            };

            return FileElement;
        })();

        event.MarkdownElement = (function() {

            /**
             * Properties of a MarkdownElement.
             * @memberof kritor.event
             * @interface IMarkdownElement
             * @property {string|null} [markdown] MarkdownElement markdown
             */

            /**
             * Constructs a new MarkdownElement.
             * @memberof kritor.event
             * @classdesc Represents a MarkdownElement.
             * @implements IMarkdownElement
             * @constructor
             * @param {kritor.event.IMarkdownElement=} [properties] Properties to set
             */
            function MarkdownElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarkdownElement markdown.
             * @member {string} markdown
             * @memberof kritor.event.MarkdownElement
             * @instance
             */
            MarkdownElement.prototype.markdown = "";

            /**
             * Creates a new MarkdownElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {kritor.event.IMarkdownElement=} [properties] Properties to set
             * @returns {kritor.event.MarkdownElement} MarkdownElement instance
             */
            MarkdownElement.create = function create(properties) {
                return new MarkdownElement(properties);
            };

            /**
             * Encodes the specified MarkdownElement message. Does not implicitly {@link kritor.event.MarkdownElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {kritor.event.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.markdown);
                return writer;
            };

            /**
             * Encodes the specified MarkdownElement message, length delimited. Does not implicitly {@link kritor.event.MarkdownElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {kritor.event.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.MarkdownElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.markdown = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarkdownElement message.
             * @function verify
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarkdownElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    if (!$util.isString(message.markdown))
                        return "markdown: string expected";
                return null;
            };

            /**
             * Creates a MarkdownElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.MarkdownElement} MarkdownElement
             */
            MarkdownElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.MarkdownElement)
                    return object;
                let message = new $root.kritor.event.MarkdownElement();
                if (object.markdown != null)
                    message.markdown = String(object.markdown);
                return message;
            };

            /**
             * Creates a plain object from a MarkdownElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {kritor.event.MarkdownElement} message MarkdownElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarkdownElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.markdown = "";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    object.markdown = message.markdown;
                return object;
            };

            /**
             * Converts this MarkdownElement to JSON.
             * @function toJSON
             * @memberof kritor.event.MarkdownElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarkdownElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarkdownElement
             * @function getTypeUrl
             * @memberof kritor.event.MarkdownElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarkdownElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.MarkdownElement";
            };

            return MarkdownElement;
        })();

        event.ButtonActionPermission = (function() {

            /**
             * Properties of a ButtonActionPermission.
             * @memberof kritor.event
             * @interface IButtonActionPermission
             * @property {number|null} [type] ButtonActionPermission type
             * @property {Array.<string>|null} [roleIds] ButtonActionPermission roleIds
             * @property {Array.<string>|null} [userIds] ButtonActionPermission userIds
             */

            /**
             * Constructs a new ButtonActionPermission.
             * @memberof kritor.event
             * @classdesc Represents a ButtonActionPermission.
             * @implements IButtonActionPermission
             * @constructor
             * @param {kritor.event.IButtonActionPermission=} [properties] Properties to set
             */
            function ButtonActionPermission(properties) {
                this.roleIds = [];
                this.userIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonActionPermission type.
             * @member {number} type
             * @memberof kritor.event.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.type = 0;

            /**
             * ButtonActionPermission roleIds.
             * @member {Array.<string>} roleIds
             * @memberof kritor.event.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.roleIds = $util.emptyArray;

            /**
             * ButtonActionPermission userIds.
             * @member {Array.<string>} userIds
             * @memberof kritor.event.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.userIds = $util.emptyArray;

            /**
             * Creates a new ButtonActionPermission instance using the specified properties.
             * @function create
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {kritor.event.IButtonActionPermission=} [properties] Properties to set
             * @returns {kritor.event.ButtonActionPermission} ButtonActionPermission instance
             */
            ButtonActionPermission.create = function create(properties) {
                return new ButtonActionPermission(properties);
            };

            /**
             * Encodes the specified ButtonActionPermission message. Does not implicitly {@link kritor.event.ButtonActionPermission.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {kritor.event.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.roleIds != null && message.roleIds.length)
                    for (let i = 0; i < message.roleIds.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleIds[i]);
                if (message.userIds != null && message.userIds.length)
                    for (let i = 0; i < message.userIds.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.userIds[i]);
                return writer;
            };

            /**
             * Encodes the specified ButtonActionPermission message, length delimited. Does not implicitly {@link kritor.event.ButtonActionPermission.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {kritor.event.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ButtonActionPermission();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            if (!(message.roleIds && message.roleIds.length))
                                message.roleIds = [];
                            message.roleIds.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.userIds && message.userIds.length))
                                message.userIds = [];
                            message.userIds.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonActionPermission message.
             * @function verify
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonActionPermission.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.roleIds != null && message.hasOwnProperty("roleIds")) {
                    if (!Array.isArray(message.roleIds))
                        return "roleIds: array expected";
                    for (let i = 0; i < message.roleIds.length; ++i)
                        if (!$util.isString(message.roleIds[i]))
                            return "roleIds: string[] expected";
                }
                if (message.userIds != null && message.hasOwnProperty("userIds")) {
                    if (!Array.isArray(message.userIds))
                        return "userIds: array expected";
                    for (let i = 0; i < message.userIds.length; ++i)
                        if (!$util.isString(message.userIds[i]))
                            return "userIds: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ButtonActionPermission message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ButtonActionPermission} ButtonActionPermission
             */
            ButtonActionPermission.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ButtonActionPermission)
                    return object;
                let message = new $root.kritor.event.ButtonActionPermission();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.roleIds) {
                    if (!Array.isArray(object.roleIds))
                        throw TypeError(".kritor.event.ButtonActionPermission.roleIds: array expected");
                    message.roleIds = [];
                    for (let i = 0; i < object.roleIds.length; ++i)
                        message.roleIds[i] = String(object.roleIds[i]);
                }
                if (object.userIds) {
                    if (!Array.isArray(object.userIds))
                        throw TypeError(".kritor.event.ButtonActionPermission.userIds: array expected");
                    message.userIds = [];
                    for (let i = 0; i < object.userIds.length; ++i)
                        message.userIds[i] = String(object.userIds[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonActionPermission message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {kritor.event.ButtonActionPermission} message ButtonActionPermission
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonActionPermission.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.roleIds = [];
                    object.userIds = [];
                }
                if (options.defaults)
                    object.type = 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.roleIds && message.roleIds.length) {
                    object.roleIds = [];
                    for (let j = 0; j < message.roleIds.length; ++j)
                        object.roleIds[j] = message.roleIds[j];
                }
                if (message.userIds && message.userIds.length) {
                    object.userIds = [];
                    for (let j = 0; j < message.userIds.length; ++j)
                        object.userIds[j] = message.userIds[j];
                }
                return object;
            };

            /**
             * Converts this ButtonActionPermission to JSON.
             * @function toJSON
             * @memberof kritor.event.ButtonActionPermission
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonActionPermission.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonActionPermission
             * @function getTypeUrl
             * @memberof kritor.event.ButtonActionPermission
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonActionPermission.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ButtonActionPermission";
            };

            return ButtonActionPermission;
        })();

        event.ButtonAction = (function() {

            /**
             * Properties of a ButtonAction.
             * @memberof kritor.event
             * @interface IButtonAction
             * @property {number|null} [type] ButtonAction type
             * @property {kritor.event.IButtonActionPermission|null} [permission] ButtonAction permission
             * @property {string|null} [unsupportedTips] ButtonAction unsupportedTips
             * @property {string|null} [data] ButtonAction data
             * @property {boolean|null} [reply] ButtonAction reply
             * @property {boolean|null} [enter] ButtonAction enter
             */

            /**
             * Constructs a new ButtonAction.
             * @memberof kritor.event
             * @classdesc Represents a ButtonAction.
             * @implements IButtonAction
             * @constructor
             * @param {kritor.event.IButtonAction=} [properties] Properties to set
             */
            function ButtonAction(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonAction type.
             * @member {number} type
             * @memberof kritor.event.ButtonAction
             * @instance
             */
            ButtonAction.prototype.type = 0;

            /**
             * ButtonAction permission.
             * @member {kritor.event.IButtonActionPermission|null|undefined} permission
             * @memberof kritor.event.ButtonAction
             * @instance
             */
            ButtonAction.prototype.permission = null;

            /**
             * ButtonAction unsupportedTips.
             * @member {string} unsupportedTips
             * @memberof kritor.event.ButtonAction
             * @instance
             */
            ButtonAction.prototype.unsupportedTips = "";

            /**
             * ButtonAction data.
             * @member {string} data
             * @memberof kritor.event.ButtonAction
             * @instance
             */
            ButtonAction.prototype.data = "";

            /**
             * ButtonAction reply.
             * @member {boolean} reply
             * @memberof kritor.event.ButtonAction
             * @instance
             */
            ButtonAction.prototype.reply = false;

            /**
             * ButtonAction enter.
             * @member {boolean} enter
             * @memberof kritor.event.ButtonAction
             * @instance
             */
            ButtonAction.prototype.enter = false;

            /**
             * Creates a new ButtonAction instance using the specified properties.
             * @function create
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {kritor.event.IButtonAction=} [properties] Properties to set
             * @returns {kritor.event.ButtonAction} ButtonAction instance
             */
            ButtonAction.create = function create(properties) {
                return new ButtonAction(properties);
            };

            /**
             * Encodes the specified ButtonAction message. Does not implicitly {@link kritor.event.ButtonAction.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {kritor.event.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    $root.kritor.event.ButtonActionPermission.encode(message.permission, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.unsupportedTips != null && Object.hasOwnProperty.call(message, "unsupportedTips"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.unsupportedTips);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.data);
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reply);
                if (message.enter != null && Object.hasOwnProperty.call(message, "enter"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enter);
                return writer;
            };

            /**
             * Encodes the specified ButtonAction message, length delimited. Does not implicitly {@link kritor.event.ButtonAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {kritor.event.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ButtonAction();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.permission = $root.kritor.event.ButtonActionPermission.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.unsupportedTips = reader.string();
                            break;
                        }
                    case 4: {
                            message.data = reader.string();
                            break;
                        }
                    case 5: {
                            message.reply = reader.bool();
                            break;
                        }
                    case 6: {
                            message.enter = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonAction message.
             * @function verify
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.permission != null && message.hasOwnProperty("permission")) {
                    let error = $root.kritor.event.ButtonActionPermission.verify(message.permission);
                    if (error)
                        return "permission." + error;
                }
                if (message.unsupportedTips != null && message.hasOwnProperty("unsupportedTips"))
                    if (!$util.isString(message.unsupportedTips))
                        return "unsupportedTips: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.reply != null && message.hasOwnProperty("reply"))
                    if (typeof message.reply !== "boolean")
                        return "reply: boolean expected";
                if (message.enter != null && message.hasOwnProperty("enter"))
                    if (typeof message.enter !== "boolean")
                        return "enter: boolean expected";
                return null;
            };

            /**
             * Creates a ButtonAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ButtonAction} ButtonAction
             */
            ButtonAction.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ButtonAction)
                    return object;
                let message = new $root.kritor.event.ButtonAction();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.permission != null) {
                    if (typeof object.permission !== "object")
                        throw TypeError(".kritor.event.ButtonAction.permission: object expected");
                    message.permission = $root.kritor.event.ButtonActionPermission.fromObject(object.permission);
                }
                if (object.unsupportedTips != null)
                    message.unsupportedTips = String(object.unsupportedTips);
                if (object.data != null)
                    message.data = String(object.data);
                if (object.reply != null)
                    message.reply = Boolean(object.reply);
                if (object.enter != null)
                    message.enter = Boolean(object.enter);
                return message;
            };

            /**
             * Creates a plain object from a ButtonAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {kritor.event.ButtonAction} message ButtonAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.permission = null;
                    object.unsupportedTips = "";
                    object.data = "";
                    object.reply = false;
                    object.enter = false;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = $root.kritor.event.ButtonActionPermission.toObject(message.permission, options);
                if (message.unsupportedTips != null && message.hasOwnProperty("unsupportedTips"))
                    object.unsupportedTips = message.unsupportedTips;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.reply != null && message.hasOwnProperty("reply"))
                    object.reply = message.reply;
                if (message.enter != null && message.hasOwnProperty("enter"))
                    object.enter = message.enter;
                return object;
            };

            /**
             * Converts this ButtonAction to JSON.
             * @function toJSON
             * @memberof kritor.event.ButtonAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonAction
             * @function getTypeUrl
             * @memberof kritor.event.ButtonAction
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ButtonAction";
            };

            return ButtonAction;
        })();

        event.ButtonRender = (function() {

            /**
             * Properties of a ButtonRender.
             * @memberof kritor.event
             * @interface IButtonRender
             * @property {string|null} [label] ButtonRender label
             * @property {string|null} [visitedLabel] ButtonRender visitedLabel
             * @property {number|null} [style] ButtonRender style
             */

            /**
             * Constructs a new ButtonRender.
             * @memberof kritor.event
             * @classdesc Represents a ButtonRender.
             * @implements IButtonRender
             * @constructor
             * @param {kritor.event.IButtonRender=} [properties] Properties to set
             */
            function ButtonRender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonRender label.
             * @member {string} label
             * @memberof kritor.event.ButtonRender
             * @instance
             */
            ButtonRender.prototype.label = "";

            /**
             * ButtonRender visitedLabel.
             * @member {string} visitedLabel
             * @memberof kritor.event.ButtonRender
             * @instance
             */
            ButtonRender.prototype.visitedLabel = "";

            /**
             * ButtonRender style.
             * @member {number} style
             * @memberof kritor.event.ButtonRender
             * @instance
             */
            ButtonRender.prototype.style = 0;

            /**
             * Creates a new ButtonRender instance using the specified properties.
             * @function create
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {kritor.event.IButtonRender=} [properties] Properties to set
             * @returns {kritor.event.ButtonRender} ButtonRender instance
             */
            ButtonRender.create = function create(properties) {
                return new ButtonRender(properties);
            };

            /**
             * Encodes the specified ButtonRender message. Does not implicitly {@link kritor.event.ButtonRender.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {kritor.event.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                if (message.visitedLabel != null && Object.hasOwnProperty.call(message, "visitedLabel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.visitedLabel);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                return writer;
            };

            /**
             * Encodes the specified ButtonRender message, length delimited. Does not implicitly {@link kritor.event.ButtonRender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {kritor.event.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ButtonRender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.label = reader.string();
                            break;
                        }
                    case 2: {
                            message.visitedLabel = reader.string();
                            break;
                        }
                    case 3: {
                            message.style = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonRender message.
             * @function verify
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonRender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.visitedLabel != null && message.hasOwnProperty("visitedLabel"))
                    if (!$util.isString(message.visitedLabel))
                        return "visitedLabel: string expected";
                if (message.style != null && message.hasOwnProperty("style"))
                    if (!$util.isInteger(message.style))
                        return "style: integer expected";
                return null;
            };

            /**
             * Creates a ButtonRender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ButtonRender} ButtonRender
             */
            ButtonRender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ButtonRender)
                    return object;
                let message = new $root.kritor.event.ButtonRender();
                if (object.label != null)
                    message.label = String(object.label);
                if (object.visitedLabel != null)
                    message.visitedLabel = String(object.visitedLabel);
                if (object.style != null)
                    message.style = object.style | 0;
                return message;
            };

            /**
             * Creates a plain object from a ButtonRender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {kritor.event.ButtonRender} message ButtonRender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonRender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.label = "";
                    object.visitedLabel = "";
                    object.style = 0;
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.visitedLabel != null && message.hasOwnProperty("visitedLabel"))
                    object.visitedLabel = message.visitedLabel;
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = message.style;
                return object;
            };

            /**
             * Converts this ButtonRender to JSON.
             * @function toJSON
             * @memberof kritor.event.ButtonRender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonRender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonRender
             * @function getTypeUrl
             * @memberof kritor.event.ButtonRender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonRender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ButtonRender";
            };

            return ButtonRender;
        })();

        event.Button = (function() {

            /**
             * Properties of a Button.
             * @memberof kritor.event
             * @interface IButton
             * @property {string|null} [id] Button id
             * @property {kritor.event.IButtonRender|null} [renderData] Button renderData
             * @property {kritor.event.IButtonAction|null} [action] Button action
             */

            /**
             * Constructs a new Button.
             * @memberof kritor.event
             * @classdesc Represents a Button.
             * @implements IButton
             * @constructor
             * @param {kritor.event.IButton=} [properties] Properties to set
             */
            function Button(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Button id.
             * @member {string} id
             * @memberof kritor.event.Button
             * @instance
             */
            Button.prototype.id = "";

            /**
             * Button renderData.
             * @member {kritor.event.IButtonRender|null|undefined} renderData
             * @memberof kritor.event.Button
             * @instance
             */
            Button.prototype.renderData = null;

            /**
             * Button action.
             * @member {kritor.event.IButtonAction|null|undefined} action
             * @memberof kritor.event.Button
             * @instance
             */
            Button.prototype.action = null;

            /**
             * Creates a new Button instance using the specified properties.
             * @function create
             * @memberof kritor.event.Button
             * @static
             * @param {kritor.event.IButton=} [properties] Properties to set
             * @returns {kritor.event.Button} Button instance
             */
            Button.create = function create(properties) {
                return new Button(properties);
            };

            /**
             * Encodes the specified Button message. Does not implicitly {@link kritor.event.Button.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.Button
             * @static
             * @param {kritor.event.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.renderData != null && Object.hasOwnProperty.call(message, "renderData"))
                    $root.kritor.event.ButtonRender.encode(message.renderData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    $root.kritor.event.ButtonAction.encode(message.action, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Button message, length delimited. Does not implicitly {@link kritor.event.Button.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.Button
             * @static
             * @param {kritor.event.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Button message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.Button();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.renderData = $root.kritor.event.ButtonRender.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.action = $root.kritor.event.ButtonAction.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Button message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Button message.
             * @function verify
             * @memberof kritor.event.Button
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Button.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.renderData != null && message.hasOwnProperty("renderData")) {
                    let error = $root.kritor.event.ButtonRender.verify(message.renderData);
                    if (error)
                        return "renderData." + error;
                }
                if (message.action != null && message.hasOwnProperty("action")) {
                    let error = $root.kritor.event.ButtonAction.verify(message.action);
                    if (error)
                        return "action." + error;
                }
                return null;
            };

            /**
             * Creates a Button message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.Button
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.Button} Button
             */
            Button.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.Button)
                    return object;
                let message = new $root.kritor.event.Button();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.renderData != null) {
                    if (typeof object.renderData !== "object")
                        throw TypeError(".kritor.event.Button.renderData: object expected");
                    message.renderData = $root.kritor.event.ButtonRender.fromObject(object.renderData);
                }
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".kritor.event.Button.action: object expected");
                    message.action = $root.kritor.event.ButtonAction.fromObject(object.action);
                }
                return message;
            };

            /**
             * Creates a plain object from a Button message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.Button
             * @static
             * @param {kritor.event.Button} message Button
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Button.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.renderData = null;
                    object.action = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.renderData != null && message.hasOwnProperty("renderData"))
                    object.renderData = $root.kritor.event.ButtonRender.toObject(message.renderData, options);
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = $root.kritor.event.ButtonAction.toObject(message.action, options);
                return object;
            };

            /**
             * Converts this Button to JSON.
             * @function toJSON
             * @memberof kritor.event.Button
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Button.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Button
             * @function getTypeUrl
             * @memberof kritor.event.Button
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Button.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.Button";
            };

            return Button;
        })();

        event.Row = (function() {

            /**
             * Properties of a Row.
             * @memberof kritor.event
             * @interface IRow
             * @property {Array.<kritor.event.IButton>|null} [buttons] Row buttons
             */

            /**
             * Constructs a new Row.
             * @memberof kritor.event
             * @classdesc Represents a Row.
             * @implements IRow
             * @constructor
             * @param {kritor.event.IRow=} [properties] Properties to set
             */
            function Row(properties) {
                this.buttons = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Row buttons.
             * @member {Array.<kritor.event.IButton>} buttons
             * @memberof kritor.event.Row
             * @instance
             */
            Row.prototype.buttons = $util.emptyArray;

            /**
             * Creates a new Row instance using the specified properties.
             * @function create
             * @memberof kritor.event.Row
             * @static
             * @param {kritor.event.IRow=} [properties] Properties to set
             * @returns {kritor.event.Row} Row instance
             */
            Row.create = function create(properties) {
                return new Row(properties);
            };

            /**
             * Encodes the specified Row message. Does not implicitly {@link kritor.event.Row.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.Row
             * @static
             * @param {kritor.event.IRow} message Row message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Row.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buttons != null && message.buttons.length)
                    for (let i = 0; i < message.buttons.length; ++i)
                        $root.kritor.event.Button.encode(message.buttons[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Row message, length delimited. Does not implicitly {@link kritor.event.Row.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.Row
             * @static
             * @param {kritor.event.IRow} message Row message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Row.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Row message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.Row
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.Row} Row
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Row.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.Row();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.buttons && message.buttons.length))
                                message.buttons = [];
                            message.buttons.push($root.kritor.event.Button.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Row message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.Row
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.Row} Row
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Row.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Row message.
             * @function verify
             * @memberof kritor.event.Row
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Row.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buttons != null && message.hasOwnProperty("buttons")) {
                    if (!Array.isArray(message.buttons))
                        return "buttons: array expected";
                    for (let i = 0; i < message.buttons.length; ++i) {
                        let error = $root.kritor.event.Button.verify(message.buttons[i]);
                        if (error)
                            return "buttons." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Row message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.Row
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.Row} Row
             */
            Row.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.Row)
                    return object;
                let message = new $root.kritor.event.Row();
                if (object.buttons) {
                    if (!Array.isArray(object.buttons))
                        throw TypeError(".kritor.event.Row.buttons: array expected");
                    message.buttons = [];
                    for (let i = 0; i < object.buttons.length; ++i) {
                        if (typeof object.buttons[i] !== "object")
                            throw TypeError(".kritor.event.Row.buttons: object expected");
                        message.buttons[i] = $root.kritor.event.Button.fromObject(object.buttons[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Row message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.Row
             * @static
             * @param {kritor.event.Row} message Row
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Row.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.buttons = [];
                if (message.buttons && message.buttons.length) {
                    object.buttons = [];
                    for (let j = 0; j < message.buttons.length; ++j)
                        object.buttons[j] = $root.kritor.event.Button.toObject(message.buttons[j], options);
                }
                return object;
            };

            /**
             * Converts this Row to JSON.
             * @function toJSON
             * @memberof kritor.event.Row
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Row.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Row
             * @function getTypeUrl
             * @memberof kritor.event.Row
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Row.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.Row";
            };

            return Row;
        })();

        event.ButtonElement = (function() {

            /**
             * Properties of a ButtonElement.
             * @memberof kritor.event
             * @interface IButtonElement
             * @property {Array.<kritor.event.IRow>|null} [rows] ButtonElement rows
             */

            /**
             * Constructs a new ButtonElement.
             * @memberof kritor.event
             * @classdesc Represents a ButtonElement.
             * @implements IButtonElement
             * @constructor
             * @param {kritor.event.IButtonElement=} [properties] Properties to set
             */
            function ButtonElement(properties) {
                this.rows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonElement rows.
             * @member {Array.<kritor.event.IRow>} rows
             * @memberof kritor.event.ButtonElement
             * @instance
             */
            ButtonElement.prototype.rows = $util.emptyArray;

            /**
             * Creates a new ButtonElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {kritor.event.IButtonElement=} [properties] Properties to set
             * @returns {kritor.event.ButtonElement} ButtonElement instance
             */
            ButtonElement.create = function create(properties) {
                return new ButtonElement(properties);
            };

            /**
             * Encodes the specified ButtonElement message. Does not implicitly {@link kritor.event.ButtonElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {kritor.event.IButtonElement} message ButtonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (let i = 0; i < message.rows.length; ++i)
                        $root.kritor.event.Row.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ButtonElement message, length delimited. Does not implicitly {@link kritor.event.ButtonElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {kritor.event.IButtonElement} message ButtonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.ButtonElement} ButtonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.ButtonElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.kritor.event.Row.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.ButtonElement} ButtonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonElement message.
             * @function verify
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (let i = 0; i < message.rows.length; ++i) {
                        let error = $root.kritor.event.Row.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ButtonElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.ButtonElement} ButtonElement
             */
            ButtonElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.ButtonElement)
                    return object;
                let message = new $root.kritor.event.ButtonElement();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".kritor.event.ButtonElement.rows: array expected");
                    message.rows = [];
                    for (let i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".kritor.event.ButtonElement.rows: object expected");
                        message.rows[i] = $root.kritor.event.Row.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {kritor.event.ButtonElement} message ButtonElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (let j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.kritor.event.Row.toObject(message.rows[j], options);
                }
                return object;
            };

            /**
             * Converts this ButtonElement to JSON.
             * @function toJSON
             * @memberof kritor.event.ButtonElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonElement
             * @function getTypeUrl
             * @memberof kritor.event.ButtonElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.ButtonElement";
            };

            return ButtonElement;
        })();

        event.NodeElement = (function() {

            /**
             * Properties of a NodeElement.
             * @memberof kritor.event
             * @interface INodeElement
             * @property {kritor.event.IContact|null} [scene] NodeElement scene
             * @property {number|Long|null} [messageId] NodeElement messageId
             */

            /**
             * Constructs a new NodeElement.
             * @memberof kritor.event
             * @classdesc Represents a NodeElement.
             * @implements INodeElement
             * @constructor
             * @param {kritor.event.INodeElement=} [properties] Properties to set
             */
            function NodeElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeElement scene.
             * @member {kritor.event.IContact|null|undefined} scene
             * @memberof kritor.event.NodeElement
             * @instance
             */
            NodeElement.prototype.scene = null;

            /**
             * NodeElement messageId.
             * @member {number|Long} messageId
             * @memberof kritor.event.NodeElement
             * @instance
             */
            NodeElement.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new NodeElement instance using the specified properties.
             * @function create
             * @memberof kritor.event.NodeElement
             * @static
             * @param {kritor.event.INodeElement=} [properties] Properties to set
             * @returns {kritor.event.NodeElement} NodeElement instance
             */
            NodeElement.create = function create(properties) {
                return new NodeElement(properties);
            };

            /**
             * Encodes the specified NodeElement message. Does not implicitly {@link kritor.event.NodeElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.NodeElement
             * @static
             * @param {kritor.event.INodeElement} message NodeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    $root.kritor.event.Contact.encode(message.scene, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified NodeElement message, length delimited. Does not implicitly {@link kritor.event.NodeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.NodeElement
             * @static
             * @param {kritor.event.INodeElement} message NodeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.NodeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.NodeElement} NodeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.NodeElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = $root.kritor.event.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.NodeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.NodeElement} NodeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeElement message.
             * @function verify
             * @memberof kritor.event.NodeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scene != null && message.hasOwnProperty("scene")) {
                    let error = $root.kritor.event.Contact.verify(message.scene);
                    if (error)
                        return "scene." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a NodeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.NodeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.NodeElement} NodeElement
             */
            NodeElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.NodeElement)
                    return object;
                let message = new $root.kritor.event.NodeElement();
                if (object.scene != null) {
                    if (typeof object.scene !== "object")
                        throw TypeError(".kritor.event.NodeElement.scene: object expected");
                    message.scene = $root.kritor.event.Contact.fromObject(object.scene);
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a NodeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.NodeElement
             * @static
             * @param {kritor.event.NodeElement} message NodeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = $root.kritor.event.Contact.toObject(message.scene, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this NodeElement to JSON.
             * @function toJSON
             * @memberof kritor.event.NodeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NodeElement
             * @function getTypeUrl
             * @memberof kritor.event.NodeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.NodeElement";
            };

            return NodeElement;
        })();

        event.FriendPokeNotice = (function() {

            /**
             * Properties of a FriendPokeNotice.
             * @memberof kritor.event
             * @interface IFriendPokeNotice
             * @property {number|Long|null} [operator] FriendPokeNotice operator
             * @property {number|Long|null} [target] FriendPokeNotice target
             * @property {string|null} [action] FriendPokeNotice action
             * @property {string|null} [suffix] FriendPokeNotice suffix
             * @property {string|null} [actionImage] FriendPokeNotice actionImage
             */

            /**
             * Constructs a new FriendPokeNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendPokeNotice.
             * @implements IFriendPokeNotice
             * @constructor
             * @param {kritor.event.IFriendPokeNotice=} [properties] Properties to set
             */
            function FriendPokeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendPokeNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendPokeNotice target.
             * @member {number|Long} target
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.target = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendPokeNotice action.
             * @member {string} action
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.action = "";

            /**
             * FriendPokeNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.suffix = "";

            /**
             * FriendPokeNotice actionImage.
             * @member {string} actionImage
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.actionImage = "";

            /**
             * Creates a new FriendPokeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice instance
             */
            FriendPokeNotice.create = function create(properties) {
                return new FriendPokeNotice(properties);
            };

            /**
             * Encodes the specified FriendPokeNotice message. Does not implicitly {@link kritor.event.FriendPokeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice} message FriendPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendPokeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.operator);
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.target);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.suffix);
                if (message.actionImage != null && Object.hasOwnProperty.call(message, "actionImage"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.actionImage);
                return writer;
            };

            /**
             * Encodes the specified FriendPokeNotice message, length delimited. Does not implicitly {@link kritor.event.FriendPokeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice} message FriendPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendPokeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendPokeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendPokeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendPokeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.action = reader.string();
                            break;
                        }
                    case 4: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 5: {
                            message.actionImage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendPokeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendPokeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendPokeNotice message.
             * @function verify
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendPokeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.target != null && message.hasOwnProperty("target"))
                    if (!$util.isInteger(message.target) && !(message.target && $util.isInteger(message.target.low) && $util.isInteger(message.target.high)))
                        return "target: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    if (!$util.isString(message.actionImage))
                        return "actionImage: string expected";
                return null;
            };

            /**
             * Creates a FriendPokeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             */
            FriendPokeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendPokeNotice)
                    return object;
                let message = new $root.kritor.event.FriendPokeNotice();
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.target != null)
                    if ($util.Long)
                        (message.target = $util.Long.fromValue(object.target)).unsigned = true;
                    else if (typeof object.target === "string")
                        message.target = parseInt(object.target, 10);
                    else if (typeof object.target === "number")
                        message.target = object.target;
                    else if (typeof object.target === "object")
                        message.target = new $util.LongBits(object.target.low >>> 0, object.target.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.actionImage != null)
                    message.actionImage = String(object.actionImage);
                return message;
            };

            /**
             * Creates a plain object from a FriendPokeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.FriendPokeNotice} message FriendPokeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendPokeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.actionImage = "";
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                if (message.target != null && message.hasOwnProperty("target"))
                    if (typeof message.target === "number")
                        object.target = options.longs === String ? String(message.target) : message.target;
                    else
                        object.target = options.longs === String ? $util.Long.prototype.toString.call(message.target) : options.longs === Number ? new $util.LongBits(message.target.low >>> 0, message.target.high >>> 0).toNumber(true) : message.target;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    object.actionImage = message.actionImage;
                return object;
            };

            /**
             * Converts this FriendPokeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendPokeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendPokeNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendPokeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendPokeNotice";
            };

            return FriendPokeNotice;
        })();

        event.FriendRecallNotice = (function() {

            /**
             * Properties of a FriendRecallNotice.
             * @memberof kritor.event
             * @interface IFriendRecallNotice
             * @property {number|Long|null} [operator] FriendRecallNotice operator
             * @property {number|Long|null} [messageId] FriendRecallNotice messageId
             * @property {string|null} [tipText] FriendRecallNotice tipText
             */

            /**
             * Constructs a new FriendRecallNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendRecallNotice.
             * @implements IFriendRecallNotice
             * @constructor
             * @param {kritor.event.IFriendRecallNotice=} [properties] Properties to set
             */
            function FriendRecallNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendRecallNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendRecallNotice messageId.
             * @member {number|Long} messageId
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendRecallNotice tipText.
             * @member {string} tipText
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.tipText = "";

            /**
             * Creates a new FriendRecallNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice instance
             */
            FriendRecallNotice.create = function create(properties) {
                return new FriendRecallNotice(properties);
            };

            /**
             * Encodes the specified FriendRecallNotice message. Does not implicitly {@link kritor.event.FriendRecallNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice} message FriendRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendRecallNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.operator);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                if (message.tipText != null && Object.hasOwnProperty.call(message, "tipText"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tipText);
                return writer;
            };

            /**
             * Encodes the specified FriendRecallNotice message, length delimited. Does not implicitly {@link kritor.event.FriendRecallNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice} message FriendRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendRecallNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendRecallNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendRecallNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendRecallNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.tipText = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendRecallNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendRecallNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendRecallNotice message.
             * @function verify
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendRecallNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    if (!$util.isString(message.tipText))
                        return "tipText: string expected";
                return null;
            };

            /**
             * Creates a FriendRecallNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             */
            FriendRecallNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendRecallNotice)
                    return object;
                let message = new $root.kritor.event.FriendRecallNotice();
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.tipText != null)
                    message.tipText = String(object.tipText);
                return message;
            };

            /**
             * Creates a plain object from a FriendRecallNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.FriendRecallNotice} message FriendRecallNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendRecallNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.tipText = "";
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    object.tipText = message.tipText;
                return object;
            };

            /**
             * Converts this FriendRecallNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendRecallNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendRecallNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendRecallNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendRecallNotice";
            };

            return FriendRecallNotice;
        })();

        event.GroupUniqueTitleChangedNotice = (function() {

            /**
             * Properties of a GroupUniqueTitleChangedNotice.
             * @memberof kritor.event
             * @interface IGroupUniqueTitleChangedNotice
             * @property {number|Long|null} [target] GroupUniqueTitleChangedNotice target
             * @property {string|null} [title] GroupUniqueTitleChangedNotice title
             * @property {number|Long|null} [groupId] GroupUniqueTitleChangedNotice groupId
             */

            /**
             * Constructs a new GroupUniqueTitleChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupUniqueTitleChangedNotice.
             * @implements IGroupUniqueTitleChangedNotice
             * @constructor
             * @param {kritor.event.IGroupUniqueTitleChangedNotice=} [properties] Properties to set
             */
            function GroupUniqueTitleChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupUniqueTitleChangedNotice target.
             * @member {number|Long} target
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.target = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupUniqueTitleChangedNotice title.
             * @member {string} title
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.title = "";

            /**
             * GroupUniqueTitleChangedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupUniqueTitleChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice instance
             */
            GroupUniqueTitleChangedNotice.create = function create(properties) {
                return new GroupUniqueTitleChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupUniqueTitleChangedNotice message. Does not implicitly {@link kritor.event.GroupUniqueTitleChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupUniqueTitleChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.target);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GroupUniqueTitleChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupUniqueTitleChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupUniqueTitleChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupUniqueTitleChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupUniqueTitleChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupUniqueTitleChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.target = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupUniqueTitleChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupUniqueTitleChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupUniqueTitleChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupUniqueTitleChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target"))
                    if (!$util.isInteger(message.target) && !(message.target && $util.isInteger(message.target.low) && $util.isInteger(message.target.high)))
                        return "target: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupUniqueTitleChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             */
            GroupUniqueTitleChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupUniqueTitleChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupUniqueTitleChangedNotice();
                if (object.target != null)
                    if ($util.Long)
                        (message.target = $util.Long.fromValue(object.target)).unsigned = true;
                    else if (typeof object.target === "string")
                        message.target = parseInt(object.target, 10);
                    else if (typeof object.target === "number")
                        message.target = object.target;
                    else if (typeof object.target === "object")
                        message.target = new $util.LongBits(object.target.low >>> 0, object.target.high >>> 0).toNumber(true);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupUniqueTitleChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.GroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupUniqueTitleChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target = options.longs === String ? "0" : 0;
                    object.title = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    if (typeof message.target === "number")
                        object.target = options.longs === String ? String(message.target) : message.target;
                    else
                        object.target = options.longs === String ? $util.Long.prototype.toString.call(message.target) : options.longs === Number ? new $util.LongBits(message.target.low >>> 0, message.target.high >>> 0).toNumber(true) : message.target;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GroupUniqueTitleChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupUniqueTitleChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupUniqueTitleChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupUniqueTitleChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupUniqueTitleChangedNotice";
            };

            return GroupUniqueTitleChangedNotice;
        })();

        event.EssenceMessageNotice = (function() {

            /**
             * Properties of an EssenceMessageNotice.
             * @memberof kritor.event
             * @interface IEssenceMessageNotice
             * @property {number|Long|null} [groupId] EssenceMessageNotice groupId
             * @property {number|Long|null} [sender] EssenceMessageNotice sender
             * @property {number|Long|null} [operator] EssenceMessageNotice operator
             * @property {number|Long|null} [messageId] EssenceMessageNotice messageId
             * @property {number|null} [subType] EssenceMessageNotice subType
             */

            /**
             * Constructs a new EssenceMessageNotice.
             * @memberof kritor.event
             * @classdesc Represents an EssenceMessageNotice.
             * @implements IEssenceMessageNotice
             * @constructor
             * @param {kritor.event.IEssenceMessageNotice=} [properties] Properties to set
             */
            function EssenceMessageNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EssenceMessageNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.EssenceMessageNotice
             * @instance
             */
            EssenceMessageNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageNotice sender.
             * @member {number|Long} sender
             * @memberof kritor.event.EssenceMessageNotice
             * @instance
             */
            EssenceMessageNotice.prototype.sender = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.EssenceMessageNotice
             * @instance
             */
            EssenceMessageNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageNotice messageId.
             * @member {number|Long} messageId
             * @memberof kritor.event.EssenceMessageNotice
             * @instance
             */
            EssenceMessageNotice.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageNotice subType.
             * @member {number} subType
             * @memberof kritor.event.EssenceMessageNotice
             * @instance
             */
            EssenceMessageNotice.prototype.subType = 0;

            /**
             * Creates a new EssenceMessageNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {kritor.event.IEssenceMessageNotice=} [properties] Properties to set
             * @returns {kritor.event.EssenceMessageNotice} EssenceMessageNotice instance
             */
            EssenceMessageNotice.create = function create(properties) {
                return new EssenceMessageNotice(properties);
            };

            /**
             * Encodes the specified EssenceMessageNotice message. Does not implicitly {@link kritor.event.EssenceMessageNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {kritor.event.IEssenceMessageNotice} message EssenceMessageNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessageNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sender);
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.messageId);
                if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.subType);
                return writer;
            };

            /**
             * Encodes the specified EssenceMessageNotice message, length delimited. Does not implicitly {@link kritor.event.EssenceMessageNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {kritor.event.IEssenceMessageNotice} message EssenceMessageNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessageNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EssenceMessageNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.EssenceMessageNotice} EssenceMessageNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessageNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.EssenceMessageNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.sender = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.subType = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EssenceMessageNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.EssenceMessageNotice} EssenceMessageNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessageNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EssenceMessageNotice message.
             * @function verify
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EssenceMessageNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isInteger(message.sender) && !(message.sender && $util.isInteger(message.sender.low) && $util.isInteger(message.sender.high)))
                        return "sender: integer|Long expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.subType != null && message.hasOwnProperty("subType"))
                    if (!$util.isInteger(message.subType))
                        return "subType: integer expected";
                return null;
            };

            /**
             * Creates an EssenceMessageNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.EssenceMessageNotice} EssenceMessageNotice
             */
            EssenceMessageNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.EssenceMessageNotice)
                    return object;
                let message = new $root.kritor.event.EssenceMessageNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.sender != null)
                    if ($util.Long)
                        (message.sender = $util.Long.fromValue(object.sender)).unsigned = true;
                    else if (typeof object.sender === "string")
                        message.sender = parseInt(object.sender, 10);
                    else if (typeof object.sender === "number")
                        message.sender = object.sender;
                    else if (typeof object.sender === "object")
                        message.sender = new $util.LongBits(object.sender.low >>> 0, object.sender.high >>> 0).toNumber(true);
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.subType != null)
                    message.subType = object.subType >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an EssenceMessageNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {kritor.event.EssenceMessageNotice} message EssenceMessageNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EssenceMessageNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sender = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sender = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.subType = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (typeof message.sender === "number")
                        object.sender = options.longs === String ? String(message.sender) : message.sender;
                    else
                        object.sender = options.longs === String ? $util.Long.prototype.toString.call(message.sender) : options.longs === Number ? new $util.LongBits(message.sender.low >>> 0, message.sender.high >>> 0).toNumber(true) : message.sender;
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.subType != null && message.hasOwnProperty("subType"))
                    object.subType = message.subType;
                return object;
            };

            /**
             * Converts this EssenceMessageNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.EssenceMessageNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EssenceMessageNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EssenceMessageNotice
             * @function getTypeUrl
             * @memberof kritor.event.EssenceMessageNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EssenceMessageNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.EssenceMessageNotice";
            };

            return EssenceMessageNotice;
        })();

        event.GroupPokeNotice = (function() {

            /**
             * Properties of a GroupPokeNotice.
             * @memberof kritor.event
             * @interface IGroupPokeNotice
             * @property {number|Long|null} [operator] GroupPokeNotice operator
             * @property {number|Long|null} [target] GroupPokeNotice target
             * @property {string|null} [action] GroupPokeNotice action
             * @property {string|null} [suffix] GroupPokeNotice suffix
             * @property {string|null} [actionImage] GroupPokeNotice actionImage
             * @property {number|Long|null} [groupId] GroupPokeNotice groupId
             */

            /**
             * Constructs a new GroupPokeNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupPokeNotice.
             * @implements IGroupPokeNotice
             * @constructor
             * @param {kritor.event.IGroupPokeNotice=} [properties] Properties to set
             */
            function GroupPokeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupPokeNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice target.
             * @member {number|Long} target
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.target = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice action.
             * @member {string} action
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.action = "";

            /**
             * GroupPokeNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.suffix = "";

            /**
             * GroupPokeNotice actionImage.
             * @member {string} actionImage
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.actionImage = "";

            /**
             * GroupPokeNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupPokeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice instance
             */
            GroupPokeNotice.create = function create(properties) {
                return new GroupPokeNotice(properties);
            };

            /**
             * Encodes the specified GroupPokeNotice message. Does not implicitly {@link kritor.event.GroupPokeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice} message GroupPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupPokeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.operator);
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.target);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.suffix);
                if (message.actionImage != null && Object.hasOwnProperty.call(message, "actionImage"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.actionImage);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GroupPokeNotice message, length delimited. Does not implicitly {@link kritor.event.GroupPokeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice} message GroupPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupPokeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupPokeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupPokeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupPokeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.target = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.action = reader.string();
                            break;
                        }
                    case 4: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 5: {
                            message.actionImage = reader.string();
                            break;
                        }
                    case 6: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupPokeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupPokeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupPokeNotice message.
             * @function verify
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupPokeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.target != null && message.hasOwnProperty("target"))
                    if (!$util.isInteger(message.target) && !(message.target && $util.isInteger(message.target.low) && $util.isInteger(message.target.high)))
                        return "target: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    if (!$util.isString(message.actionImage))
                        return "actionImage: string expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupPokeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             */
            GroupPokeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupPokeNotice)
                    return object;
                let message = new $root.kritor.event.GroupPokeNotice();
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.target != null)
                    if ($util.Long)
                        (message.target = $util.Long.fromValue(object.target)).unsigned = true;
                    else if (typeof object.target === "string")
                        message.target = parseInt(object.target, 10);
                    else if (typeof object.target === "number")
                        message.target = object.target;
                    else if (typeof object.target === "object")
                        message.target = new $util.LongBits(object.target.low >>> 0, object.target.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.actionImage != null)
                    message.actionImage = String(object.actionImage);
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupPokeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.GroupPokeNotice} message GroupPokeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupPokeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.actionImage = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                if (message.target != null && message.hasOwnProperty("target"))
                    if (typeof message.target === "number")
                        object.target = options.longs === String ? String(message.target) : message.target;
                    else
                        object.target = options.longs === String ? $util.Long.prototype.toString.call(message.target) : options.longs === Number ? new $util.LongBits(message.target.low >>> 0, message.target.high >>> 0).toNumber(true) : message.target;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    object.actionImage = message.actionImage;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GroupPokeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupPokeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupPokeNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupPokeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupPokeNotice";
            };

            return GroupPokeNotice;
        })();

        /**
         * GroupMemberIncreasedType enum.
         * @name kritor.event.GroupMemberIncreasedType
         * @enum {number}
         * @property {number} APPROVE=0 APPROVE value
         * @property {number} INVITE=1 INVITE value
         */
        event.GroupMemberIncreasedType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "APPROVE"] = 0;
            values[valuesById[1] = "INVITE"] = 1;
            return values;
        })();

        event.GroupMemberIncreasedNotice = (function() {

            /**
             * Properties of a GroupMemberIncreasedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberIncreasedNotice
             * @property {number|Long|null} [groupId] GroupMemberIncreasedNotice groupId
             * @property {string|null} [operatorUid] GroupMemberIncreasedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupMemberIncreasedNotice operatorUin
             * @property {string|null} [targetUid] GroupMemberIncreasedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupMemberIncreasedNotice targetUin
             * @property {kritor.event.GroupMemberIncreasedType|null} [type] GroupMemberIncreasedNotice type
             */

            /**
             * Constructs a new GroupMemberIncreasedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberIncreasedNotice.
             * @implements IGroupMemberIncreasedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberIncreasedNotice=} [properties] Properties to set
             */
            function GroupMemberIncreasedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberIncreasedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.operatorUid = "";

            /**
             * GroupMemberIncreasedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.targetUid = "";

            /**
             * GroupMemberIncreasedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice type.
             * @member {kritor.event.GroupMemberIncreasedType} type
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberIncreasedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice instance
             */
            GroupMemberIncreasedNotice.create = function create(properties) {
                return new GroupMemberIncreasedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberIncreasedNotice message. Does not implicitly {@link kritor.event.GroupMemberIncreasedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice} message GroupMemberIncreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberIncreasedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberIncreasedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberIncreasedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice} message GroupMemberIncreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberIncreasedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberIncreasedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberIncreasedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberIncreasedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberIncreasedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberIncreasedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberIncreasedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberIncreasedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberIncreasedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             */
            GroupMemberIncreasedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberIncreasedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberIncreasedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "APPROVE":
                case 0:
                    message.type = 0;
                    break;
                case "INVITE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberIncreasedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.GroupMemberIncreasedNotice} message GroupMemberIncreasedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberIncreasedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "APPROVE" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberIncreasedType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberIncreasedType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberIncreasedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberIncreasedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberIncreasedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberIncreasedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberIncreasedNotice";
            };

            return GroupMemberIncreasedNotice;
        })();

        /**
         * GroupMemberDecreasedType enum.
         * @name kritor.event.GroupMemberDecreasedType
         * @enum {number}
         * @property {number} KICK=0 KICK value
         * @property {number} LEAVE=1 LEAVE value
         * @property {number} KICK_ME=2 KICK_ME value
         */
        event.GroupMemberDecreasedType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "KICK"] = 0;
            values[valuesById[1] = "LEAVE"] = 1;
            values[valuesById[2] = "KICK_ME"] = 2;
            return values;
        })();

        event.GroupMemberDecreasedNotice = (function() {

            /**
             * Properties of a GroupMemberDecreasedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberDecreasedNotice
             * @property {number|Long|null} [groupId] GroupMemberDecreasedNotice groupId
             * @property {string|null} [operatorUid] GroupMemberDecreasedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupMemberDecreasedNotice operatorUin
             * @property {string|null} [targetUid] GroupMemberDecreasedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupMemberDecreasedNotice targetUin
             * @property {kritor.event.GroupMemberDecreasedType|null} [type] GroupMemberDecreasedNotice type
             */

            /**
             * Constructs a new GroupMemberDecreasedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberDecreasedNotice.
             * @implements IGroupMemberDecreasedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberDecreasedNotice=} [properties] Properties to set
             */
            function GroupMemberDecreasedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberDecreasedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberDecreasedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.operatorUid = "";

            /**
             * GroupMemberDecreasedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberDecreasedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.targetUid = "";

            /**
             * GroupMemberDecreasedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberDecreasedNotice type.
             * @member {kritor.event.GroupMemberDecreasedType} type
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberDecreasedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice instance
             */
            GroupMemberDecreasedNotice.create = function create(properties) {
                return new GroupMemberDecreasedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberDecreasedNotice message. Does not implicitly {@link kritor.event.GroupMemberDecreasedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice} message GroupMemberDecreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberDecreasedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberDecreasedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberDecreasedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice} message GroupMemberDecreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberDecreasedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberDecreasedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberDecreasedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberDecreasedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberDecreasedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberDecreasedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberDecreasedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberDecreasedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberDecreasedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             */
            GroupMemberDecreasedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberDecreasedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberDecreasedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "KICK":
                case 0:
                    message.type = 0;
                    break;
                case "LEAVE":
                case 1:
                    message.type = 1;
                    break;
                case "KICK_ME":
                case 2:
                    message.type = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberDecreasedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.GroupMemberDecreasedNotice} message GroupMemberDecreasedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberDecreasedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "KICK" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberDecreasedType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberDecreasedType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberDecreasedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberDecreasedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberDecreasedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberDecreasedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberDecreasedNotice";
            };

            return GroupMemberDecreasedNotice;
        })();

        event.GroupAdminChangedNotice = (function() {

            /**
             * Properties of a GroupAdminChangedNotice.
             * @memberof kritor.event
             * @interface IGroupAdminChangedNotice
             * @property {number|Long|null} [groupId] GroupAdminChangedNotice groupId
             * @property {string|null} [targetUid] GroupAdminChangedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupAdminChangedNotice targetUin
             * @property {boolean|null} [isAdmin] GroupAdminChangedNotice isAdmin
             */

            /**
             * Constructs a new GroupAdminChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupAdminChangedNotice.
             * @implements IGroupAdminChangedNotice
             * @constructor
             * @param {kritor.event.IGroupAdminChangedNotice=} [properties] Properties to set
             */
            function GroupAdminChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupAdminChangedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupAdminChangedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.targetUid = "";

            /**
             * GroupAdminChangedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupAdminChangedNotice isAdmin.
             * @member {boolean} isAdmin
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.isAdmin = false;

            /**
             * Creates a new GroupAdminChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice instance
             */
            GroupAdminChangedNotice.create = function create(properties) {
                return new GroupAdminChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupAdminChangedNotice message. Does not implicitly {@link kritor.event.GroupAdminChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice} message GroupAdminChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupAdminChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.isAdmin != null && Object.hasOwnProperty.call(message, "isAdmin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isAdmin);
                return writer;
            };

            /**
             * Encodes the specified GroupAdminChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupAdminChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice} message GroupAdminChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupAdminChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupAdminChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupAdminChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupAdminChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.isAdmin = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupAdminChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupAdminChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupAdminChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupAdminChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    if (typeof message.isAdmin !== "boolean")
                        return "isAdmin: boolean expected";
                return null;
            };

            /**
             * Creates a GroupAdminChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             */
            GroupAdminChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupAdminChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupAdminChangedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.isAdmin != null)
                    message.isAdmin = Boolean(object.isAdmin);
                return message;
            };

            /**
             * Creates a plain object from a GroupAdminChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.GroupAdminChangedNotice} message GroupAdminChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupAdminChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.isAdmin = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    object.isAdmin = message.isAdmin;
                return object;
            };

            /**
             * Converts this GroupAdminChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupAdminChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupAdminChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupAdminChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupAdminChangedNotice";
            };

            return GroupAdminChangedNotice;
        })();

        /**
         * GroupMemberBanType enum.
         * @name kritor.event.GroupMemberBanType
         * @enum {number}
         * @property {number} LIFT_BAN=0 LIFT_BAN value
         * @property {number} BAN=1 BAN value
         */
        event.GroupMemberBanType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LIFT_BAN"] = 0;
            values[valuesById[1] = "BAN"] = 1;
            return values;
        })();

        event.GroupMemberBannedNotice = (function() {

            /**
             * Properties of a GroupMemberBannedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberBannedNotice
             * @property {number|Long|null} [groupId] GroupMemberBannedNotice groupId
             * @property {string|null} [operatorUid] GroupMemberBannedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupMemberBannedNotice operatorUin
             * @property {string|null} [targetUid] GroupMemberBannedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupMemberBannedNotice targetUin
             * @property {number|null} [duration] GroupMemberBannedNotice duration
             * @property {kritor.event.GroupMemberBanType|null} [type] GroupMemberBannedNotice type
             */

            /**
             * Constructs a new GroupMemberBannedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberBannedNotice.
             * @implements IGroupMemberBannedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberBannedNotice=} [properties] Properties to set
             */
            function GroupMemberBannedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberBannedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBannedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.operatorUid = "";

            /**
             * GroupMemberBannedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBannedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.targetUid = "";

            /**
             * GroupMemberBannedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBannedNotice duration.
             * @member {number} duration
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.duration = 0;

            /**
             * GroupMemberBannedNotice type.
             * @member {kritor.event.GroupMemberBanType} type
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             */
            GroupMemberBannedNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberBannedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {kritor.event.IGroupMemberBannedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberBannedNotice} GroupMemberBannedNotice instance
             */
            GroupMemberBannedNotice.create = function create(properties) {
                return new GroupMemberBannedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberBannedNotice message. Does not implicitly {@link kritor.event.GroupMemberBannedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {kritor.event.IGroupMemberBannedNotice} message GroupMemberBannedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberBannedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.duration);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberBannedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberBannedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {kritor.event.IGroupMemberBannedNotice} message GroupMemberBannedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberBannedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberBannedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberBannedNotice} GroupMemberBannedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberBannedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberBannedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.duration = reader.int32();
                            break;
                        }
                    case 7: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberBannedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberBannedNotice} GroupMemberBannedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberBannedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberBannedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberBannedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (!$util.isInteger(message.duration))
                        return "duration: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberBannedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberBannedNotice} GroupMemberBannedNotice
             */
            GroupMemberBannedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberBannedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberBannedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.duration != null)
                    message.duration = object.duration | 0;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "LIFT_BAN":
                case 0:
                    message.type = 0;
                    break;
                case "BAN":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberBannedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {kritor.event.GroupMemberBannedNotice} message GroupMemberBannedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberBannedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.duration = 0;
                    object.type = options.enums === String ? "LIFT_BAN" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = message.duration;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberBanType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberBanType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberBannedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberBannedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberBannedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberBannedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberBannedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberBannedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberBannedNotice";
            };

            return GroupMemberBannedNotice;
        })();

        event.GroupRecallNotice = (function() {

            /**
             * Properties of a GroupRecallNotice.
             * @memberof kritor.event
             * @interface IGroupRecallNotice
             * @property {number|Long|null} [groupId] GroupRecallNotice groupId
             * @property {number|Long|null} [messageId] GroupRecallNotice messageId
             * @property {string|null} [tipText] GroupRecallNotice tipText
             * @property {number|Long|null} [operatorUin] GroupRecallNotice operatorUin
             * @property {string|null} [operatorUid] GroupRecallNotice operatorUid
             * @property {number|Long|null} [targetUin] GroupRecallNotice targetUin
             * @property {string|null} [targetUid] GroupRecallNotice targetUid
             * @property {number|Long|null} [messageSeq] GroupRecallNotice messageSeq
             */

            /**
             * Constructs a new GroupRecallNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupRecallNotice.
             * @implements IGroupRecallNotice
             * @constructor
             * @param {kritor.event.IGroupRecallNotice=} [properties] Properties to set
             */
            function GroupRecallNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupRecallNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice messageId.
             * @member {number|Long} messageId
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice tipText.
             * @member {string} tipText
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.tipText = "";

            /**
             * GroupRecallNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.operatorUid = "";

            /**
             * GroupRecallNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.targetUid = "";

            /**
             * GroupRecallNotice messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupRecallNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice instance
             */
            GroupRecallNotice.create = function create(properties) {
                return new GroupRecallNotice(properties);
            };

            /**
             * Encodes the specified GroupRecallNotice message. Does not implicitly {@link kritor.event.GroupRecallNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice} message GroupRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupRecallNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                if (message.tipText != null && Object.hasOwnProperty.call(message, "tipText"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tipText);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.operatorUin);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.operatorUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.targetUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.targetUid);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.messageSeq);
                return writer;
            };

            /**
             * Encodes the specified GroupRecallNotice message, length delimited. Does not implicitly {@link kritor.event.GroupRecallNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice} message GroupRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupRecallNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupRecallNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupRecallNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupRecallNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.tipText = reader.string();
                            break;
                        }
                    case 4: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 6: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 8: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupRecallNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupRecallNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupRecallNotice message.
             * @function verify
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupRecallNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    if (!$util.isString(message.tipText))
                        return "tipText: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupRecallNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             */
            GroupRecallNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupRecallNotice)
                    return object;
                let message = new $root.kritor.event.GroupRecallNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.tipText != null)
                    message.tipText = String(object.tipText);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupRecallNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.GroupRecallNotice} message GroupRecallNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupRecallNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.tipText = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    object.tipText = message.tipText;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                return object;
            };

            /**
             * Converts this GroupRecallNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupRecallNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupRecallNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupRecallNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupRecallNotice";
            };

            return GroupRecallNotice;
        })();

        event.GroupSignNotice = (function() {

            /**
             * Properties of a GroupSignNotice.
             * @memberof kritor.event
             * @interface IGroupSignNotice
             * @property {number|Long|null} [groupId] GroupSignNotice groupId
             * @property {number|Long|null} [targetUin] GroupSignNotice targetUin
             * @property {string|null} [action] GroupSignNotice action
             * @property {string|null} [suffix] GroupSignNotice suffix
             * @property {string|null} [rankImage] GroupSignNotice rankImage
             */

            /**
             * Constructs a new GroupSignNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupSignNotice.
             * @implements IGroupSignNotice
             * @constructor
             * @param {kritor.event.IGroupSignNotice=} [properties] Properties to set
             */
            function GroupSignNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupSignNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupSignNotice
             * @instance
             */
            GroupSignNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupSignNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupSignNotice
             * @instance
             */
            GroupSignNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupSignNotice action.
             * @member {string} action
             * @memberof kritor.event.GroupSignNotice
             * @instance
             */
            GroupSignNotice.prototype.action = "";

            /**
             * GroupSignNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.GroupSignNotice
             * @instance
             */
            GroupSignNotice.prototype.suffix = "";

            /**
             * GroupSignNotice rankImage.
             * @member {string} rankImage
             * @memberof kritor.event.GroupSignNotice
             * @instance
             */
            GroupSignNotice.prototype.rankImage = "";

            /**
             * Creates a new GroupSignNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {kritor.event.IGroupSignNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupSignNotice} GroupSignNotice instance
             */
            GroupSignNotice.create = function create(properties) {
                return new GroupSignNotice(properties);
            };

            /**
             * Encodes the specified GroupSignNotice message. Does not implicitly {@link kritor.event.GroupSignNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {kritor.event.IGroupSignNotice} message GroupSignNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupSignNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.suffix);
                if (message.rankImage != null && Object.hasOwnProperty.call(message, "rankImage"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.rankImage);
                return writer;
            };

            /**
             * Encodes the specified GroupSignNotice message, length delimited. Does not implicitly {@link kritor.event.GroupSignNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {kritor.event.IGroupSignNotice} message GroupSignNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupSignNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupSignNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupSignNotice} GroupSignNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupSignNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupSignNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.action = reader.string();
                            break;
                        }
                    case 7: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 8: {
                            message.rankImage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupSignNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupSignNotice} GroupSignNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupSignNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupSignNotice message.
             * @function verify
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupSignNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.rankImage != null && message.hasOwnProperty("rankImage"))
                    if (!$util.isString(message.rankImage))
                        return "rankImage: string expected";
                return null;
            };

            /**
             * Creates a GroupSignNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupSignNotice} GroupSignNotice
             */
            GroupSignNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupSignNotice)
                    return object;
                let message = new $root.kritor.event.GroupSignNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.rankImage != null)
                    message.rankImage = String(object.rankImage);
                return message;
            };

            /**
             * Creates a plain object from a GroupSignNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {kritor.event.GroupSignNotice} message GroupSignNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupSignNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.rankImage = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.rankImage != null && message.hasOwnProperty("rankImage"))
                    object.rankImage = message.rankImage;
                return object;
            };

            /**
             * Converts this GroupSignNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupSignNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupSignNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupSignNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupSignNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupSignNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupSignNotice";
            };

            return GroupSignNotice;
        })();

        event.GroupWholeBanNotice = (function() {

            /**
             * Properties of a GroupWholeBanNotice.
             * @memberof kritor.event
             * @interface IGroupWholeBanNotice
             * @property {number|Long|null} [groupId] GroupWholeBanNotice groupId
             * @property {number|Long|null} [operator] GroupWholeBanNotice operator
             * @property {boolean|null} [isWholeBan] GroupWholeBanNotice isWholeBan
             */

            /**
             * Constructs a new GroupWholeBanNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupWholeBanNotice.
             * @implements IGroupWholeBanNotice
             * @constructor
             * @param {kritor.event.IGroupWholeBanNotice=} [properties] Properties to set
             */
            function GroupWholeBanNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupWholeBanNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupWholeBanNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupWholeBanNotice isWholeBan.
             * @member {boolean} isWholeBan
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.isWholeBan = false;

            /**
             * Creates a new GroupWholeBanNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice instance
             */
            GroupWholeBanNotice.create = function create(properties) {
                return new GroupWholeBanNotice(properties);
            };

            /**
             * Encodes the specified GroupWholeBanNotice message. Does not implicitly {@link kritor.event.GroupWholeBanNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice} message GroupWholeBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupWholeBanNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.isWholeBan != null && Object.hasOwnProperty.call(message, "isWholeBan"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isWholeBan);
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operator);
                return writer;
            };

            /**
             * Encodes the specified GroupWholeBanNotice message, length delimited. Does not implicitly {@link kritor.event.GroupWholeBanNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice} message GroupWholeBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupWholeBanNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupWholeBanNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupWholeBanNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupWholeBanNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.isWholeBan = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupWholeBanNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupWholeBanNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupWholeBanNotice message.
             * @function verify
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupWholeBanNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.isWholeBan != null && message.hasOwnProperty("isWholeBan"))
                    if (typeof message.isWholeBan !== "boolean")
                        return "isWholeBan: boolean expected";
                return null;
            };

            /**
             * Creates a GroupWholeBanNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             */
            GroupWholeBanNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupWholeBanNotice)
                    return object;
                let message = new $root.kritor.event.GroupWholeBanNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.isWholeBan != null)
                    message.isWholeBan = Boolean(object.isWholeBan);
                return message;
            };

            /**
             * Creates a plain object from a GroupWholeBanNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.GroupWholeBanNotice} message GroupWholeBanNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupWholeBanNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.isWholeBan = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.isWholeBan != null && message.hasOwnProperty("isWholeBan"))
                    object.isWholeBan = message.isWholeBan;
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                return object;
            };

            /**
             * Converts this GroupWholeBanNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupWholeBanNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupWholeBanNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupWholeBanNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupWholeBanNotice";
            };

            return GroupWholeBanNotice;
        })();

        event.FriendFileComeNotice = (function() {

            /**
             * Properties of a FriendFileComeNotice.
             * @memberof kritor.event
             * @interface IFriendFileComeNotice
             * @property {number|Long|null} [operator] FriendFileComeNotice operator
             * @property {string|null} [fileId] FriendFileComeNotice fileId
             * @property {string|null} [fileSubId] FriendFileComeNotice fileSubId
             * @property {string|null} [fileName] FriendFileComeNotice fileName
             * @property {number|Long|null} [fileSize] FriendFileComeNotice fileSize
             * @property {number|null} [expireTime] FriendFileComeNotice expireTime
             * @property {string|null} [url] FriendFileComeNotice url
             */

            /**
             * Constructs a new FriendFileComeNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendFileComeNotice.
             * @implements IFriendFileComeNotice
             * @constructor
             * @param {kritor.event.IFriendFileComeNotice=} [properties] Properties to set
             */
            function FriendFileComeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendFileComeNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendFileComeNotice fileId.
             * @member {string} fileId
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.fileId = "";

            /**
             * FriendFileComeNotice fileSubId.
             * @member {string} fileSubId
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.fileSubId = "";

            /**
             * FriendFileComeNotice fileName.
             * @member {string} fileName
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.fileName = "";

            /**
             * FriendFileComeNotice fileSize.
             * @member {number|Long} fileSize
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendFileComeNotice expireTime.
             * @member {number} expireTime
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.expireTime = 0;

            /**
             * FriendFileComeNotice url.
             * @member {string} url
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             */
            FriendFileComeNotice.prototype.url = "";

            /**
             * Creates a new FriendFileComeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {kritor.event.IFriendFileComeNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendFileComeNotice} FriendFileComeNotice instance
             */
            FriendFileComeNotice.create = function create(properties) {
                return new FriendFileComeNotice(properties);
            };

            /**
             * Encodes the specified FriendFileComeNotice message. Does not implicitly {@link kritor.event.FriendFileComeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {kritor.event.IFriendFileComeNotice} message FriendFileComeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendFileComeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.operator);
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileId);
                if (message.fileSubId != null && Object.hasOwnProperty.call(message, "fileSubId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.fileSubId);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fileSize);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.expireTime);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified FriendFileComeNotice message, length delimited. Does not implicitly {@link kritor.event.FriendFileComeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {kritor.event.IFriendFileComeNotice} message FriendFileComeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendFileComeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendFileComeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendFileComeNotice} FriendFileComeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendFileComeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendFileComeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 3: {
                            message.fileSubId = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.expireTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendFileComeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendFileComeNotice} FriendFileComeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendFileComeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendFileComeNotice message.
             * @function verify
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendFileComeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    if (!$util.isString(message.fileSubId))
                        return "fileSubId: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime))
                        return "expireTime: integer expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a FriendFileComeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendFileComeNotice} FriendFileComeNotice
             */
            FriendFileComeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendFileComeNotice)
                    return object;
                let message = new $root.kritor.event.FriendFileComeNotice();
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.fileSubId != null)
                    message.fileSubId = String(object.fileSubId);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    message.expireTime = object.expireTime >>> 0;
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a FriendFileComeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {kritor.event.FriendFileComeNotice} message FriendFileComeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendFileComeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                    object.fileId = "";
                    object.fileSubId = "";
                    object.fileName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                    object.expireTime = 0;
                    object.url = "";
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    object.fileSubId = message.fileSubId;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    object.expireTime = message.expireTime;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this FriendFileComeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendFileComeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendFileComeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendFileComeNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendFileComeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendFileComeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendFileComeNotice";
            };

            return FriendFileComeNotice;
        })();

        event.GroupFileComeNotice = (function() {

            /**
             * Properties of a GroupFileComeNotice.
             * @memberof kritor.event
             * @interface IGroupFileComeNotice
             * @property {number|Long|null} [groupId] GroupFileComeNotice groupId
             * @property {number|Long|null} [operator] GroupFileComeNotice operator
             * @property {string|null} [fileId] GroupFileComeNotice fileId
             * @property {string|null} [fileSubId] GroupFileComeNotice fileSubId
             * @property {string|null} [fileName] GroupFileComeNotice fileName
             * @property {number|Long|null} [fileSize] GroupFileComeNotice fileSize
             * @property {number|null} [expireTime] GroupFileComeNotice expireTime
             * @property {number|null} [biz] GroupFileComeNotice biz
             * @property {string|null} [url] GroupFileComeNotice url
             */

            /**
             * Constructs a new GroupFileComeNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupFileComeNotice.
             * @implements IGroupFileComeNotice
             * @constructor
             * @param {kritor.event.IGroupFileComeNotice=} [properties] Properties to set
             */
            function GroupFileComeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupFileComeNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileComeNotice operator.
             * @member {number|Long} operator
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.operator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileComeNotice fileId.
             * @member {string} fileId
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.fileId = "";

            /**
             * GroupFileComeNotice fileSubId.
             * @member {string} fileSubId
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.fileSubId = "";

            /**
             * GroupFileComeNotice fileName.
             * @member {string} fileName
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.fileName = "";

            /**
             * GroupFileComeNotice fileSize.
             * @member {number|Long} fileSize
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileComeNotice expireTime.
             * @member {number} expireTime
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.expireTime = 0;

            /**
             * GroupFileComeNotice biz.
             * @member {number} biz
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.biz = 0;

            /**
             * GroupFileComeNotice url.
             * @member {string} url
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             */
            GroupFileComeNotice.prototype.url = "";

            /**
             * Creates a new GroupFileComeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {kritor.event.IGroupFileComeNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupFileComeNotice} GroupFileComeNotice instance
             */
            GroupFileComeNotice.create = function create(properties) {
                return new GroupFileComeNotice(properties);
            };

            /**
             * Encodes the specified GroupFileComeNotice message. Does not implicitly {@link kritor.event.GroupFileComeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {kritor.event.IGroupFileComeNotice} message GroupFileComeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupFileComeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.operator);
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileId);
                if (message.fileSubId != null && Object.hasOwnProperty.call(message, "fileSubId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.fileSubId);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fileSize);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.expireTime);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.biz);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.groupId);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified GroupFileComeNotice message, length delimited. Does not implicitly {@link kritor.event.GroupFileComeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {kritor.event.IGroupFileComeNotice} message GroupFileComeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupFileComeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupFileComeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupFileComeNotice} GroupFileComeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupFileComeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupFileComeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 8: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 1: {
                            message.operator = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 3: {
                            message.fileSubId = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.expireTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 9: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupFileComeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupFileComeNotice} GroupFileComeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupFileComeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupFileComeNotice message.
             * @function verify
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupFileComeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isInteger(message.operator) && !(message.operator && $util.isInteger(message.operator.low) && $util.isInteger(message.operator.high)))
                        return "operator: integer|Long expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    if (!$util.isString(message.fileSubId))
                        return "fileSubId: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime))
                        return "expireTime: integer expected";
                if (message.biz != null && message.hasOwnProperty("biz"))
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a GroupFileComeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupFileComeNotice} GroupFileComeNotice
             */
            GroupFileComeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupFileComeNotice)
                    return object;
                let message = new $root.kritor.event.GroupFileComeNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operator != null)
                    if ($util.Long)
                        (message.operator = $util.Long.fromValue(object.operator)).unsigned = true;
                    else if (typeof object.operator === "string")
                        message.operator = parseInt(object.operator, 10);
                    else if (typeof object.operator === "number")
                        message.operator = object.operator;
                    else if (typeof object.operator === "object")
                        message.operator = new $util.LongBits(object.operator.low >>> 0, object.operator.high >>> 0).toNumber(true);
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.fileSubId != null)
                    message.fileSubId = String(object.fileSubId);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    message.expireTime = object.expireTime >>> 0;
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a GroupFileComeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {kritor.event.GroupFileComeNotice} message GroupFileComeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupFileComeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operator = options.longs === String ? "0" : 0;
                    object.fileId = "";
                    object.fileSubId = "";
                    object.fileName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                    object.expireTime = 0;
                    object.biz = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.url = "";
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (typeof message.operator === "number")
                        object.operator = options.longs === String ? String(message.operator) : message.operator;
                    else
                        object.operator = options.longs === String ? $util.Long.prototype.toString.call(message.operator) : options.longs === Number ? new $util.LongBits(message.operator.low >>> 0, message.operator.high >>> 0).toNumber(true) : message.operator;
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    object.fileSubId = message.fileSubId;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    object.expireTime = message.expireTime;
                if (message.biz != null && message.hasOwnProperty("biz"))
                    object.biz = message.biz;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this GroupFileComeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupFileComeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupFileComeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupFileComeNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupFileComeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupFileComeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupFileComeNotice";
            };

            return GroupFileComeNotice;
        })();

        event.FriendApplyRequest = (function() {

            /**
             * Properties of a FriendApplyRequest.
             * @memberof kritor.event
             * @interface IFriendApplyRequest
             * @property {string|null} [applierUid] FriendApplyRequest applierUid
             * @property {number|Long|null} [applierUin] FriendApplyRequest applierUin
             * @property {string|null} [flag] FriendApplyRequest flag
             * @property {string|null} [message] FriendApplyRequest message
             */

            /**
             * Constructs a new FriendApplyRequest.
             * @memberof kritor.event
             * @classdesc Represents a FriendApplyRequest.
             * @implements IFriendApplyRequest
             * @constructor
             * @param {kritor.event.IFriendApplyRequest=} [properties] Properties to set
             */
            function FriendApplyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendApplyRequest applierUid.
             * @member {string} applierUid
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.applierUid = "";

            /**
             * FriendApplyRequest applierUin.
             * @member {number|Long} applierUin
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.applierUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendApplyRequest flag.
             * @member {string} flag
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.flag = "";

            /**
             * FriendApplyRequest message.
             * @member {string} message
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.message = "";

            /**
             * Creates a new FriendApplyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest=} [properties] Properties to set
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest instance
             */
            FriendApplyRequest.create = function create(properties) {
                return new FriendApplyRequest(properties);
            };

            /**
             * Encodes the specified FriendApplyRequest message. Does not implicitly {@link kritor.event.FriendApplyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest} message FriendApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendApplyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.applierUid != null && Object.hasOwnProperty.call(message, "applierUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.applierUid);
                if (message.applierUin != null && Object.hasOwnProperty.call(message, "applierUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.applierUin);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.flag);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified FriendApplyRequest message, length delimited. Does not implicitly {@link kritor.event.FriendApplyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest} message FriendApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendApplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendApplyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendApplyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendApplyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.applierUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.applierUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.flag = reader.string();
                            break;
                        }
                    case 4: {
                            message.message = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendApplyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendApplyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendApplyRequest message.
             * @function verify
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendApplyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    if (!$util.isString(message.applierUid))
                        return "applierUid: string expected";
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (!$util.isInteger(message.applierUin) && !(message.applierUin && $util.isInteger(message.applierUin.low) && $util.isInteger(message.applierUin.high)))
                        return "applierUin: integer|Long expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates a FriendApplyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             */
            FriendApplyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendApplyRequest)
                    return object;
                let message = new $root.kritor.event.FriendApplyRequest();
                if (object.applierUid != null)
                    message.applierUid = String(object.applierUid);
                if (object.applierUin != null)
                    if ($util.Long)
                        (message.applierUin = $util.Long.fromValue(object.applierUin)).unsigned = true;
                    else if (typeof object.applierUin === "string")
                        message.applierUin = parseInt(object.applierUin, 10);
                    else if (typeof object.applierUin === "number")
                        message.applierUin = object.applierUin;
                    else if (typeof object.applierUin === "object")
                        message.applierUin = new $util.LongBits(object.applierUin.low >>> 0, object.applierUin.high >>> 0).toNumber(true);
                if (object.flag != null)
                    message.flag = String(object.flag);
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from a FriendApplyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.FriendApplyRequest} message FriendApplyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendApplyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.applierUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.applierUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.applierUin = options.longs === String ? "0" : 0;
                    object.flag = "";
                    object.message = "";
                }
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    object.applierUid = message.applierUid;
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (typeof message.applierUin === "number")
                        object.applierUin = options.longs === String ? String(message.applierUin) : message.applierUin;
                    else
                        object.applierUin = options.longs === String ? $util.Long.prototype.toString.call(message.applierUin) : options.longs === Number ? new $util.LongBits(message.applierUin.low >>> 0, message.applierUin.high >>> 0).toNumber(true) : message.applierUin;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this FriendApplyRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendApplyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendApplyRequest
             * @function getTypeUrl
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendApplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendApplyRequest";
            };

            return FriendApplyRequest;
        })();

        /**
         * GroupApplyType enum.
         * @name kritor.event.GroupApplyType
         * @enum {number}
         * @property {number} GROUP_APPLY_ADD=0 GROUP_APPLY_ADD value
         * @property {number} GROUP_APPLY_INVITE=1 GROUP_APPLY_INVITE value
         */
        event.GroupApplyType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GROUP_APPLY_ADD"] = 0;
            values[valuesById[1] = "GROUP_APPLY_INVITE"] = 1;
            return values;
        })();

        event.GroupApplyRequest = (function() {

            /**
             * Properties of a GroupApplyRequest.
             * @memberof kritor.event
             * @interface IGroupApplyRequest
             * @property {number|Long|null} [groupId] GroupApplyRequest groupId
             * @property {string|null} [applierUid] GroupApplyRequest applierUid
             * @property {number|Long|null} [applierUin] GroupApplyRequest applierUin
             * @property {string|null} [reason] GroupApplyRequest reason
             * @property {string|null} [flag] GroupApplyRequest flag
             * @property {kritor.event.GroupApplyType|null} [type] GroupApplyRequest type
             */

            /**
             * Constructs a new GroupApplyRequest.
             * @memberof kritor.event
             * @classdesc Represents a GroupApplyRequest.
             * @implements IGroupApplyRequest
             * @constructor
             * @param {kritor.event.IGroupApplyRequest=} [properties] Properties to set
             */
            function GroupApplyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupApplyRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest applierUid.
             * @member {string} applierUid
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.applierUid = "";

            /**
             * GroupApplyRequest applierUin.
             * @member {number|Long} applierUin
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.applierUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest reason.
             * @member {string} reason
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.reason = "";

            /**
             * GroupApplyRequest flag.
             * @member {string} flag
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.flag = "";

            /**
             * GroupApplyRequest type.
             * @member {kritor.event.GroupApplyType} type
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.type = 0;

            /**
             * Creates a new GroupApplyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest=} [properties] Properties to set
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest instance
             */
            GroupApplyRequest.create = function create(properties) {
                return new GroupApplyRequest(properties);
            };

            /**
             * Encodes the specified GroupApplyRequest message. Does not implicitly {@link kritor.event.GroupApplyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest} message GroupApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupApplyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.applierUid != null && Object.hasOwnProperty.call(message, "applierUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.applierUid);
                if (message.applierUin != null && Object.hasOwnProperty.call(message, "applierUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.applierUin);
                if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.flag);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupApplyRequest message, length delimited. Does not implicitly {@link kritor.event.GroupApplyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest} message GroupApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupApplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupApplyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupApplyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupApplyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.applierUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.applierUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.reason = reader.string();
                            break;
                        }
                    case 5: {
                            message.flag = reader.string();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupApplyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupApplyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupApplyRequest message.
             * @function verify
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupApplyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    if (!$util.isString(message.applierUid))
                        return "applierUid: string expected";
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (!$util.isInteger(message.applierUin) && !(message.applierUin && $util.isInteger(message.applierUin.low) && $util.isInteger(message.applierUin.high)))
                        return "applierUin: integer|Long expected";
                if (message.reason != null && message.hasOwnProperty("reason"))
                    if (!$util.isString(message.reason))
                        return "reason: string expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupApplyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             */
            GroupApplyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupApplyRequest)
                    return object;
                let message = new $root.kritor.event.GroupApplyRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.applierUid != null)
                    message.applierUid = String(object.applierUid);
                if (object.applierUin != null)
                    if ($util.Long)
                        (message.applierUin = $util.Long.fromValue(object.applierUin)).unsigned = true;
                    else if (typeof object.applierUin === "string")
                        message.applierUin = parseInt(object.applierUin, 10);
                    else if (typeof object.applierUin === "number")
                        message.applierUin = object.applierUin;
                    else if (typeof object.applierUin === "object")
                        message.applierUin = new $util.LongBits(object.applierUin.low >>> 0, object.applierUin.high >>> 0).toNumber(true);
                if (object.reason != null)
                    message.reason = String(object.reason);
                if (object.flag != null)
                    message.flag = String(object.flag);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "GROUP_APPLY_ADD":
                case 0:
                    message.type = 0;
                    break;
                case "GROUP_APPLY_INVITE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupApplyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.GroupApplyRequest} message GroupApplyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupApplyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.applierUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.applierUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.applierUin = options.longs === String ? "0" : 0;
                    object.reason = "";
                    object.flag = "";
                    object.type = options.enums === String ? "GROUP_APPLY_ADD" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    object.applierUid = message.applierUid;
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (typeof message.applierUin === "number")
                        object.applierUin = options.longs === String ? String(message.applierUin) : message.applierUin;
                    else
                        object.applierUin = options.longs === String ? $util.Long.prototype.toString.call(message.applierUin) : options.longs === Number ? new $util.LongBits(message.applierUin.low >>> 0, message.applierUin.high >>> 0).toNumber(true) : message.applierUin;
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupApplyType[message.type] === undefined ? message.type : $root.kritor.event.GroupApplyType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupApplyRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupApplyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupApplyRequest
             * @function getTypeUrl
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupApplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupApplyRequest";
            };

            return GroupApplyRequest;
        })();

        event.InvitedGroupRequest = (function() {

            /**
             * Properties of an InvitedGroupRequest.
             * @memberof kritor.event
             * @interface IInvitedGroupRequest
             * @property {number|Long|null} [groupId] InvitedGroupRequest groupId
             * @property {string|null} [inviterUid] InvitedGroupRequest inviterUid
             * @property {number|Long|null} [inviterUin] InvitedGroupRequest inviterUin
             * @property {string|null} [flag] InvitedGroupRequest flag
             */

            /**
             * Constructs a new InvitedGroupRequest.
             * @memberof kritor.event
             * @classdesc Represents an InvitedGroupRequest.
             * @implements IInvitedGroupRequest
             * @constructor
             * @param {kritor.event.IInvitedGroupRequest=} [properties] Properties to set
             */
            function InvitedGroupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InvitedGroupRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.InvitedGroupRequest
             * @instance
             */
            InvitedGroupRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * InvitedGroupRequest inviterUid.
             * @member {string} inviterUid
             * @memberof kritor.event.InvitedGroupRequest
             * @instance
             */
            InvitedGroupRequest.prototype.inviterUid = "";

            /**
             * InvitedGroupRequest inviterUin.
             * @member {number|Long} inviterUin
             * @memberof kritor.event.InvitedGroupRequest
             * @instance
             */
            InvitedGroupRequest.prototype.inviterUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * InvitedGroupRequest flag.
             * @member {string} flag
             * @memberof kritor.event.InvitedGroupRequest
             * @instance
             */
            InvitedGroupRequest.prototype.flag = "";

            /**
             * Creates a new InvitedGroupRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {kritor.event.IInvitedGroupRequest=} [properties] Properties to set
             * @returns {kritor.event.InvitedGroupRequest} InvitedGroupRequest instance
             */
            InvitedGroupRequest.create = function create(properties) {
                return new InvitedGroupRequest(properties);
            };

            /**
             * Encodes the specified InvitedGroupRequest message. Does not implicitly {@link kritor.event.InvitedGroupRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {kritor.event.IInvitedGroupRequest} message InvitedGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvitedGroupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.inviterUid != null && Object.hasOwnProperty.call(message, "inviterUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviterUid);
                if (message.inviterUin != null && Object.hasOwnProperty.call(message, "inviterUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.inviterUin);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.flag);
                return writer;
            };

            /**
             * Encodes the specified InvitedGroupRequest message, length delimited. Does not implicitly {@link kritor.event.InvitedGroupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {kritor.event.IInvitedGroupRequest} message InvitedGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvitedGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InvitedGroupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.InvitedGroupRequest} InvitedGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvitedGroupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.InvitedGroupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.inviterUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.inviterUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.flag = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InvitedGroupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.InvitedGroupRequest} InvitedGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvitedGroupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InvitedGroupRequest message.
             * @function verify
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InvitedGroupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.inviterUid != null && message.hasOwnProperty("inviterUid"))
                    if (!$util.isString(message.inviterUid))
                        return "inviterUid: string expected";
                if (message.inviterUin != null && message.hasOwnProperty("inviterUin"))
                    if (!$util.isInteger(message.inviterUin) && !(message.inviterUin && $util.isInteger(message.inviterUin.low) && $util.isInteger(message.inviterUin.high)))
                        return "inviterUin: integer|Long expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                return null;
            };

            /**
             * Creates an InvitedGroupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.InvitedGroupRequest} InvitedGroupRequest
             */
            InvitedGroupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.InvitedGroupRequest)
                    return object;
                let message = new $root.kritor.event.InvitedGroupRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.inviterUid != null)
                    message.inviterUid = String(object.inviterUid);
                if (object.inviterUin != null)
                    if ($util.Long)
                        (message.inviterUin = $util.Long.fromValue(object.inviterUin)).unsigned = true;
                    else if (typeof object.inviterUin === "string")
                        message.inviterUin = parseInt(object.inviterUin, 10);
                    else if (typeof object.inviterUin === "number")
                        message.inviterUin = object.inviterUin;
                    else if (typeof object.inviterUin === "object")
                        message.inviterUin = new $util.LongBits(object.inviterUin.low >>> 0, object.inviterUin.high >>> 0).toNumber(true);
                if (object.flag != null)
                    message.flag = String(object.flag);
                return message;
            };

            /**
             * Creates a plain object from an InvitedGroupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {kritor.event.InvitedGroupRequest} message InvitedGroupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InvitedGroupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.inviterUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.inviterUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inviterUin = options.longs === String ? "0" : 0;
                    object.flag = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.inviterUid != null && message.hasOwnProperty("inviterUid"))
                    object.inviterUid = message.inviterUid;
                if (message.inviterUin != null && message.hasOwnProperty("inviterUin"))
                    if (typeof message.inviterUin === "number")
                        object.inviterUin = options.longs === String ? String(message.inviterUin) : message.inviterUin;
                    else
                        object.inviterUin = options.longs === String ? $util.Long.prototype.toString.call(message.inviterUin) : options.longs === Number ? new $util.LongBits(message.inviterUin.low >>> 0, message.inviterUin.high >>> 0).toNumber(true) : message.inviterUin;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this InvitedGroupRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.InvitedGroupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InvitedGroupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InvitedGroupRequest
             * @function getTypeUrl
             * @memberof kritor.event.InvitedGroupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InvitedGroupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.InvitedGroupRequest";
            };

            return InvitedGroupRequest;
        })();

        /**
         * EventType enum.
         * @name kritor.event.EventType
         * @enum {number}
         * @property {number} EVENT_TYPE_CORE_EVENT=0 EVENT_TYPE_CORE_EVENT value
         * @property {number} EVENT_TYPE_MESSAGE=1 EVENT_TYPE_MESSAGE value
         * @property {number} EVENT_TYPE_NOTICE=2 EVENT_TYPE_NOTICE value
         * @property {number} EVENT_TYPE_REQUEST=3 EVENT_TYPE_REQUEST value
         */
        event.EventType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EVENT_TYPE_CORE_EVENT"] = 0;
            values[valuesById[1] = "EVENT_TYPE_MESSAGE"] = 1;
            values[valuesById[2] = "EVENT_TYPE_NOTICE"] = 2;
            values[valuesById[3] = "EVENT_TYPE_REQUEST"] = 3;
            return values;
        })();

        event.RequestPushEvent = (function() {

            /**
             * Properties of a RequestPushEvent.
             * @memberof kritor.event
             * @interface IRequestPushEvent
             * @property {kritor.event.EventType|null} [type] RequestPushEvent type
             */

            /**
             * Constructs a new RequestPushEvent.
             * @memberof kritor.event
             * @classdesc Represents a RequestPushEvent.
             * @implements IRequestPushEvent
             * @constructor
             * @param {kritor.event.IRequestPushEvent=} [properties] Properties to set
             */
            function RequestPushEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestPushEvent type.
             * @member {kritor.event.EventType} type
             * @memberof kritor.event.RequestPushEvent
             * @instance
             */
            RequestPushEvent.prototype.type = 0;

            /**
             * Creates a new RequestPushEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent=} [properties] Properties to set
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent instance
             */
            RequestPushEvent.create = function create(properties) {
                return new RequestPushEvent(properties);
            };

            /**
             * Encodes the specified RequestPushEvent message. Does not implicitly {@link kritor.event.RequestPushEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent} message RequestPushEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPushEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified RequestPushEvent message, length delimited. Does not implicitly {@link kritor.event.RequestPushEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent} message RequestPushEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPushEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestPushEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPushEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RequestPushEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestPushEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPushEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestPushEvent message.
             * @function verify
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestPushEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a RequestPushEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             */
            RequestPushEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RequestPushEvent)
                    return object;
                let message = new $root.kritor.event.RequestPushEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "EVENT_TYPE_CORE_EVENT":
                case 0:
                    message.type = 0;
                    break;
                case "EVENT_TYPE_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "EVENT_TYPE_NOTICE":
                case 2:
                    message.type = 2;
                    break;
                case "EVENT_TYPE_REQUEST":
                case 3:
                    message.type = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestPushEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.RequestPushEvent} message RequestPushEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestPushEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "EVENT_TYPE_CORE_EVENT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.EventType[message.type] === undefined ? message.type : $root.kritor.event.EventType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this RequestPushEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.RequestPushEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestPushEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestPushEvent
             * @function getTypeUrl
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestPushEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RequestPushEvent";
            };

            return RequestPushEvent;
        })();

        event.EventStructure = (function() {

            /**
             * Properties of an EventStructure.
             * @memberof kritor.event
             * @interface IEventStructure
             * @property {kritor.event.EventType|null} [type] EventStructure type
             * @property {kritor.event.IMessageEvent|null} [message] EventStructure message
             * @property {kritor.event.IRequestsEvent|null} [request] EventStructure request
             * @property {kritor.event.INoticeEvent|null} [notice] EventStructure notice
             */

            /**
             * Constructs a new EventStructure.
             * @memberof kritor.event
             * @classdesc Represents an EventStructure.
             * @implements IEventStructure
             * @constructor
             * @param {kritor.event.IEventStructure=} [properties] Properties to set
             */
            function EventStructure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EventStructure type.
             * @member {kritor.event.EventType} type
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.type = 0;

            /**
             * EventStructure message.
             * @member {kritor.event.IMessageEvent|null|undefined} message
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.message = null;

            /**
             * EventStructure request.
             * @member {kritor.event.IRequestsEvent|null|undefined} request
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.request = null;

            /**
             * EventStructure notice.
             * @member {kritor.event.INoticeEvent|null|undefined} notice
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.notice = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * EventStructure event.
             * @member {"message"|"request"|"notice"|undefined} event
             * @memberof kritor.event.EventStructure
             * @instance
             */
            Object.defineProperty(EventStructure.prototype, "event", {
                get: $util.oneOfGetter($oneOfFields = ["message", "request", "notice"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new EventStructure instance using the specified properties.
             * @function create
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure=} [properties] Properties to set
             * @returns {kritor.event.EventStructure} EventStructure instance
             */
            EventStructure.create = function create(properties) {
                return new EventStructure(properties);
            };

            /**
             * Encodes the specified EventStructure message. Does not implicitly {@link kritor.event.EventStructure.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure} message EventStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventStructure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.event.MessageEvent.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                    $root.kritor.event.RequestsEvent.encode(message.request, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.notice != null && Object.hasOwnProperty.call(message, "notice"))
                    $root.kritor.event.NoticeEvent.encode(message.notice, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EventStructure message, length delimited. Does not implicitly {@link kritor.event.EventStructure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure} message EventStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventStructure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EventStructure message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.EventStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.EventStructure} EventStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventStructure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.EventStructure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.message = $root.kritor.event.MessageEvent.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.request = $root.kritor.event.RequestsEvent.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.notice = $root.kritor.event.NoticeEvent.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EventStructure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.EventStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.EventStructure} EventStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventStructure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EventStructure message.
             * @function verify
             * @memberof kritor.event.EventStructure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EventStructure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message")) {
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.MessageEvent.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    if (properties.event === 1)
                        return "event: multiple values";
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.RequestsEvent.verify(message.request);
                        if (error)
                            return "request." + error;
                    }
                }
                if (message.notice != null && message.hasOwnProperty("notice")) {
                    if (properties.event === 1)
                        return "event: multiple values";
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.NoticeEvent.verify(message.notice);
                        if (error)
                            return "notice." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EventStructure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.EventStructure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.EventStructure} EventStructure
             */
            EventStructure.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.EventStructure)
                    return object;
                let message = new $root.kritor.event.EventStructure();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "EVENT_TYPE_CORE_EVENT":
                case 0:
                    message.type = 0;
                    break;
                case "EVENT_TYPE_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "EVENT_TYPE_NOTICE":
                case 2:
                    message.type = 2;
                    break;
                case "EVENT_TYPE_REQUEST":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.event.EventStructure.message: object expected");
                    message.message = $root.kritor.event.MessageEvent.fromObject(object.message);
                }
                if (object.request != null) {
                    if (typeof object.request !== "object")
                        throw TypeError(".kritor.event.EventStructure.request: object expected");
                    message.request = $root.kritor.event.RequestsEvent.fromObject(object.request);
                }
                if (object.notice != null) {
                    if (typeof object.notice !== "object")
                        throw TypeError(".kritor.event.EventStructure.notice: object expected");
                    message.notice = $root.kritor.event.NoticeEvent.fromObject(object.notice);
                }
                return message;
            };

            /**
             * Creates a plain object from an EventStructure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.EventStructure} message EventStructure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EventStructure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "EVENT_TYPE_CORE_EVENT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.EventType[message.type] === undefined ? message.type : $root.kritor.event.EventType[message.type] : message.type;
                if (message.message != null && message.hasOwnProperty("message")) {
                    object.message = $root.kritor.event.MessageEvent.toObject(message.message, options);
                    if (options.oneofs)
                        object.event = "message";
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    object.request = $root.kritor.event.RequestsEvent.toObject(message.request, options);
                    if (options.oneofs)
                        object.event = "request";
                }
                if (message.notice != null && message.hasOwnProperty("notice")) {
                    object.notice = $root.kritor.event.NoticeEvent.toObject(message.notice, options);
                    if (options.oneofs)
                        object.event = "notice";
                }
                return object;
            };

            /**
             * Converts this EventStructure to JSON.
             * @function toJSON
             * @memberof kritor.event.EventStructure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EventStructure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EventStructure
             * @function getTypeUrl
             * @memberof kritor.event.EventStructure
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EventStructure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.EventStructure";
            };

            return EventStructure;
        })();

        event.MessageEvent = (function() {

            /**
             * Properties of a MessageEvent.
             * @memberof kritor.event
             * @interface IMessageEvent
             * @property {number|null} [time] MessageEvent time
             * @property {kritor.event.Scene|null} [scene] MessageEvent scene
             * @property {number|Long|null} [messageId] MessageEvent messageId
             * @property {number|Long|null} [messageSeq] MessageEvent messageSeq
             * @property {kritor.event.IContact|null} [contact] MessageEvent contact
             * @property {kritor.event.ISender|null} [sender] MessageEvent sender
             * @property {Array.<kritor.event.IElement>|null} [elements] MessageEvent elements
             * @property {number|null} [tempSource] MessageEvent tempSource
             */

            /**
             * Constructs a new MessageEvent.
             * @memberof kritor.event
             * @classdesc Represents a MessageEvent.
             * @implements IMessageEvent
             * @constructor
             * @param {kritor.event.IMessageEvent=} [properties] Properties to set
             */
            function MessageEvent(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageEvent time.
             * @member {number} time
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.time = 0;

            /**
             * MessageEvent scene.
             * @member {kritor.event.Scene} scene
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.scene = 0;

            /**
             * MessageEvent messageId.
             * @member {number|Long} messageId
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MessageEvent messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MessageEvent contact.
             * @member {kritor.event.IContact|null|undefined} contact
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.contact = null;

            /**
             * MessageEvent sender.
             * @member {kritor.event.ISender|null|undefined} sender
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.sender = null;

            /**
             * MessageEvent elements.
             * @member {Array.<kritor.event.IElement>} elements
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.elements = $util.emptyArray;

            /**
             * MessageEvent tempSource.
             * @member {number|null|undefined} tempSource
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            MessageEvent.prototype.tempSource = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MessageEvent _tempSource.
             * @member {"tempSource"|undefined} _tempSource
             * @memberof kritor.event.MessageEvent
             * @instance
             */
            Object.defineProperty(MessageEvent.prototype, "_tempSource", {
                get: $util.oneOfGetter($oneOfFields = ["tempSource"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MessageEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {kritor.event.IMessageEvent=} [properties] Properties to set
             * @returns {kritor.event.MessageEvent} MessageEvent instance
             */
            MessageEvent.create = function create(properties) {
                return new MessageEvent(properties);
            };

            /**
             * Encodes the specified MessageEvent message. Does not implicitly {@link kritor.event.MessageEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {kritor.event.IMessageEvent} message MessageEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.time);
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.scene);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.messageSeq);
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.event.Contact.encode(message.contact, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    $root.kritor.event.Sender.encode(message.sender, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.event.Element.encode(message.elements[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.tempSource != null && Object.hasOwnProperty.call(message, "tempSource"))
                    writer.uint32(/* id 50, wireType 0 =*/400).int32(message.tempSource);
                return writer;
            };

            /**
             * Encodes the specified MessageEvent message, length delimited. Does not implicitly {@link kritor.event.MessageEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {kritor.event.IMessageEvent} message MessageEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.MessageEvent} MessageEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.MessageEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 3: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.contact = $root.kritor.event.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.sender = $root.kritor.event.Sender.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.event.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    case 50: {
                            message.tempSource = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.MessageEvent} MessageEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageEvent message.
             * @function verify
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.event.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.sender != null && message.hasOwnProperty("sender")) {
                    let error = $root.kritor.event.Sender.verify(message.sender);
                    if (error)
                        return "sender." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.event.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                if (message.tempSource != null && message.hasOwnProperty("tempSource")) {
                    properties._tempSource = 1;
                    if (!$util.isInteger(message.tempSource))
                        return "tempSource: integer expected";
                }
                return null;
            };

            /**
             * Creates a MessageEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.MessageEvent} MessageEvent
             */
            MessageEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.MessageEvent)
                    return object;
                let message = new $root.kritor.event.MessageEvent();
                if (object.time != null)
                    message.time = object.time >>> 0;
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.event.MessageEvent.contact: object expected");
                    message.contact = $root.kritor.event.Contact.fromObject(object.contact);
                }
                if (object.sender != null) {
                    if (typeof object.sender !== "object")
                        throw TypeError(".kritor.event.MessageEvent.sender: object expected");
                    message.sender = $root.kritor.event.Sender.fromObject(object.sender);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.event.MessageEvent.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.event.MessageEvent.elements: object expected");
                        message.elements[i] = $root.kritor.event.Element.fromObject(object.elements[i]);
                    }
                }
                if (object.tempSource != null)
                    message.tempSource = object.tempSource | 0;
                return message;
            };

            /**
             * Creates a plain object from a MessageEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {kritor.event.MessageEvent} message MessageEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults) {
                    object.time = 0;
                    object.scene = options.enums === String ? "GROUP" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                    object.contact = null;
                    object.sender = null;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.event.Scene[message.scene] === undefined ? message.scene : $root.kritor.event.Scene[message.scene] : message.scene;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.event.Contact.toObject(message.contact, options);
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = $root.kritor.event.Sender.toObject(message.sender, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.event.Element.toObject(message.elements[j], options);
                }
                if (message.tempSource != null && message.hasOwnProperty("tempSource")) {
                    object.tempSource = message.tempSource;
                    if (options.oneofs)
                        object._tempSource = "tempSource";
                }
                return object;
            };

            /**
             * Converts this MessageEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.MessageEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageEvent
             * @function getTypeUrl
             * @memberof kritor.event.MessageEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.MessageEvent";
            };

            return MessageEvent;
        })();

        /**
         * RequestType enum.
         * @name kritor.event.RequestType
         * @enum {number}
         * @property {number} FRIEND_APPLY=0 FRIEND_APPLY value
         * @property {number} GROUP_APPLY=1 GROUP_APPLY value
         * @property {number} INVITED_GROUP=2 INVITED_GROUP value
         */
        event.RequestType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FRIEND_APPLY"] = 0;
            values[valuesById[1] = "GROUP_APPLY"] = 1;
            values[valuesById[2] = "INVITED_GROUP"] = 2;
            return values;
        })();

        event.RequestsEvent = (function() {

            /**
             * Properties of a RequestsEvent.
             * @memberof kritor.event
             * @interface IRequestsEvent
             * @property {kritor.event.RequestType|null} [type] RequestsEvent type
             * @property {number|null} [time] RequestsEvent time
             * @property {kritor.event.IFriendApplyRequest|null} [friendApply] RequestsEvent friendApply
             * @property {kritor.event.IGroupApplyRequest|null} [groupApply] RequestsEvent groupApply
             * @property {kritor.event.IInvitedGroupRequest|null} [invitedGroup] RequestsEvent invitedGroup
             */

            /**
             * Constructs a new RequestsEvent.
             * @memberof kritor.event
             * @classdesc Represents a RequestsEvent.
             * @implements IRequestsEvent
             * @constructor
             * @param {kritor.event.IRequestsEvent=} [properties] Properties to set
             */
            function RequestsEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestsEvent type.
             * @member {kritor.event.RequestType} type
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.type = 0;

            /**
             * RequestsEvent time.
             * @member {number} time
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.time = 0;

            /**
             * RequestsEvent friendApply.
             * @member {kritor.event.IFriendApplyRequest|null|undefined} friendApply
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.friendApply = null;

            /**
             * RequestsEvent groupApply.
             * @member {kritor.event.IGroupApplyRequest|null|undefined} groupApply
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.groupApply = null;

            /**
             * RequestsEvent invitedGroup.
             * @member {kritor.event.IInvitedGroupRequest|null|undefined} invitedGroup
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.invitedGroup = null;

            /**
             * Creates a new RequestsEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.IRequestsEvent=} [properties] Properties to set
             * @returns {kritor.event.RequestsEvent} RequestsEvent instance
             */
            RequestsEvent.create = function create(properties) {
                return new RequestsEvent(properties);
            };

            /**
             * Encodes the specified RequestsEvent message. Does not implicitly {@link kritor.event.RequestsEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.IRequestsEvent} message RequestsEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestsEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                if (message.friendApply != null && Object.hasOwnProperty.call(message, "friendApply"))
                    $root.kritor.event.FriendApplyRequest.encode(message.friendApply, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.groupApply != null && Object.hasOwnProperty.call(message, "groupApply"))
                    $root.kritor.event.GroupApplyRequest.encode(message.groupApply, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.invitedGroup != null && Object.hasOwnProperty.call(message, "invitedGroup"))
                    $root.kritor.event.InvitedGroupRequest.encode(message.invitedGroup, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RequestsEvent message, length delimited. Does not implicitly {@link kritor.event.RequestsEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.IRequestsEvent} message RequestsEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestsEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestsEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RequestsEvent} RequestsEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestsEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RequestsEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.friendApply = $root.kritor.event.FriendApplyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.groupApply = $root.kritor.event.GroupApplyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.invitedGroup = $root.kritor.event.InvitedGroupRequest.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestsEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RequestsEvent} RequestsEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestsEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestsEvent message.
             * @function verify
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestsEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.friendApply != null && message.hasOwnProperty("friendApply")) {
                    let error = $root.kritor.event.FriendApplyRequest.verify(message.friendApply);
                    if (error)
                        return "friendApply." + error;
                }
                if (message.groupApply != null && message.hasOwnProperty("groupApply")) {
                    let error = $root.kritor.event.GroupApplyRequest.verify(message.groupApply);
                    if (error)
                        return "groupApply." + error;
                }
                if (message.invitedGroup != null && message.hasOwnProperty("invitedGroup")) {
                    let error = $root.kritor.event.InvitedGroupRequest.verify(message.invitedGroup);
                    if (error)
                        return "invitedGroup." + error;
                }
                return null;
            };

            /**
             * Creates a RequestsEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RequestsEvent} RequestsEvent
             */
            RequestsEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RequestsEvent)
                    return object;
                let message = new $root.kritor.event.RequestsEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "FRIEND_APPLY":
                case 0:
                    message.type = 0;
                    break;
                case "GROUP_APPLY":
                case 1:
                    message.type = 1;
                    break;
                case "INVITED_GROUP":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.friendApply != null) {
                    if (typeof object.friendApply !== "object")
                        throw TypeError(".kritor.event.RequestsEvent.friendApply: object expected");
                    message.friendApply = $root.kritor.event.FriendApplyRequest.fromObject(object.friendApply);
                }
                if (object.groupApply != null) {
                    if (typeof object.groupApply !== "object")
                        throw TypeError(".kritor.event.RequestsEvent.groupApply: object expected");
                    message.groupApply = $root.kritor.event.GroupApplyRequest.fromObject(object.groupApply);
                }
                if (object.invitedGroup != null) {
                    if (typeof object.invitedGroup !== "object")
                        throw TypeError(".kritor.event.RequestsEvent.invitedGroup: object expected");
                    message.invitedGroup = $root.kritor.event.InvitedGroupRequest.fromObject(object.invitedGroup);
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestsEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.RequestsEvent} message RequestsEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestsEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "FRIEND_APPLY" : 0;
                    object.time = 0;
                    object.friendApply = null;
                    object.groupApply = null;
                    object.invitedGroup = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.RequestType[message.type] === undefined ? message.type : $root.kritor.event.RequestType[message.type] : message.type;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.friendApply != null && message.hasOwnProperty("friendApply"))
                    object.friendApply = $root.kritor.event.FriendApplyRequest.toObject(message.friendApply, options);
                if (message.groupApply != null && message.hasOwnProperty("groupApply"))
                    object.groupApply = $root.kritor.event.GroupApplyRequest.toObject(message.groupApply, options);
                if (message.invitedGroup != null && message.hasOwnProperty("invitedGroup"))
                    object.invitedGroup = $root.kritor.event.InvitedGroupRequest.toObject(message.invitedGroup, options);
                return object;
            };

            /**
             * Converts this RequestsEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.RequestsEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestsEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestsEvent
             * @function getTypeUrl
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestsEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RequestsEvent";
            };

            return RequestsEvent;
        })();

        /**
         * NoticeType enum.
         * @name kritor.event.NoticeType
         * @enum {number}
         * @property {number} FRIEND_POKE=0 FRIEND_POKE value
         * @property {number} FRIEND_RECALL=1 FRIEND_RECALL value
         * @property {number} FRIEND_FILE_COME=2 FRIEND_FILE_COME value
         * @property {number} GROUP_POKE=12 GROUP_POKE value
         * @property {number} GROUP_CARD_CHANGED=13 GROUP_CARD_CHANGED value
         * @property {number} GROUP_MEMBER_UNIQUE_TITLE_CHANGED=14 GROUP_MEMBER_UNIQUE_TITLE_CHANGED value
         * @property {number} GROUP_ESSENCE_CHANGED=15 GROUP_ESSENCE_CHANGED value
         * @property {number} GROUP_RECALL=16 GROUP_RECALL value
         * @property {number} GROUP_MEMBER_INCREASE=17 GROUP_MEMBER_INCREASE value
         * @property {number} GROUP_MEMBER_DECREASE=18 GROUP_MEMBER_DECREASE value
         * @property {number} GROUP_ADMIN_CHANGED=19 GROUP_ADMIN_CHANGED value
         * @property {number} GROUP_MEMBER_BANNED=20 GROUP_MEMBER_BANNED value
         * @property {number} GROUP_SIGN=21 GROUP_SIGN value
         * @property {number} GROUP_WHOLE_BAN=22 GROUP_WHOLE_BAN value
         * @property {number} GROUP_FILE_COME=23 GROUP_FILE_COME value
         */
        event.NoticeType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FRIEND_POKE"] = 0;
            values[valuesById[1] = "FRIEND_RECALL"] = 1;
            values[valuesById[2] = "FRIEND_FILE_COME"] = 2;
            values[valuesById[12] = "GROUP_POKE"] = 12;
            values[valuesById[13] = "GROUP_CARD_CHANGED"] = 13;
            values[valuesById[14] = "GROUP_MEMBER_UNIQUE_TITLE_CHANGED"] = 14;
            values[valuesById[15] = "GROUP_ESSENCE_CHANGED"] = 15;
            values[valuesById[16] = "GROUP_RECALL"] = 16;
            values[valuesById[17] = "GROUP_MEMBER_INCREASE"] = 17;
            values[valuesById[18] = "GROUP_MEMBER_DECREASE"] = 18;
            values[valuesById[19] = "GROUP_ADMIN_CHANGED"] = 19;
            values[valuesById[20] = "GROUP_MEMBER_BANNED"] = 20;
            values[valuesById[21] = "GROUP_SIGN"] = 21;
            values[valuesById[22] = "GROUP_WHOLE_BAN"] = 22;
            values[valuesById[23] = "GROUP_FILE_COME"] = 23;
            return values;
        })();

        event.NoticeEvent = (function() {

            /**
             * Properties of a NoticeEvent.
             * @memberof kritor.event
             * @interface INoticeEvent
             * @property {kritor.event.NoticeType|null} [type] NoticeEvent type
             * @property {number|null} [time] NoticeEvent time
             * @property {kritor.event.IFriendPokeNotice|null} [friendPoke] NoticeEvent friendPoke
             * @property {kritor.event.IFriendRecallNotice|null} [friendRecall] NoticeEvent friendRecall
             * @property {kritor.event.IFriendFileComeNotice|null} [friendFileCome] NoticeEvent friendFileCome
             * @property {kritor.event.IGroupPokeNotice|null} [groupPoke] NoticeEvent groupPoke
             * @property {kritor.event.IGroupUniqueTitleChangedNotice|null} [groupMemberUniqueTitleChanged] NoticeEvent groupMemberUniqueTitleChanged
             * @property {kritor.event.IEssenceMessageNotice|null} [groupEssenceChanged] NoticeEvent groupEssenceChanged
             * @property {kritor.event.IGroupRecallNotice|null} [groupRecall] NoticeEvent groupRecall
             * @property {kritor.event.IGroupMemberIncreasedNotice|null} [groupMemberIncrease] NoticeEvent groupMemberIncrease
             * @property {kritor.event.IGroupMemberDecreasedNotice|null} [groupMemberDecrease] NoticeEvent groupMemberDecrease
             * @property {kritor.event.IGroupAdminChangedNotice|null} [groupAdminChanged] NoticeEvent groupAdminChanged
             * @property {kritor.event.IGroupMemberBannedNotice|null} [groupMemberBanned] NoticeEvent groupMemberBanned
             * @property {kritor.event.IGroupSignNotice|null} [groupSign] NoticeEvent groupSign
             * @property {kritor.event.IGroupWholeBanNotice|null} [groupWholeBan] NoticeEvent groupWholeBan
             * @property {kritor.event.IGroupFileComeNotice|null} [groupFileCome] NoticeEvent groupFileCome
             */

            /**
             * Constructs a new NoticeEvent.
             * @memberof kritor.event
             * @classdesc Represents a NoticeEvent.
             * @implements INoticeEvent
             * @constructor
             * @param {kritor.event.INoticeEvent=} [properties] Properties to set
             */
            function NoticeEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NoticeEvent type.
             * @member {kritor.event.NoticeType} type
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.type = 0;

            /**
             * NoticeEvent time.
             * @member {number} time
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.time = 0;

            /**
             * NoticeEvent friendPoke.
             * @member {kritor.event.IFriendPokeNotice|null|undefined} friendPoke
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friendPoke = null;

            /**
             * NoticeEvent friendRecall.
             * @member {kritor.event.IFriendRecallNotice|null|undefined} friendRecall
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friendRecall = null;

            /**
             * NoticeEvent friendFileCome.
             * @member {kritor.event.IFriendFileComeNotice|null|undefined} friendFileCome
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friendFileCome = null;

            /**
             * NoticeEvent groupPoke.
             * @member {kritor.event.IGroupPokeNotice|null|undefined} groupPoke
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupPoke = null;

            /**
             * NoticeEvent groupMemberUniqueTitleChanged.
             * @member {kritor.event.IGroupUniqueTitleChangedNotice|null|undefined} groupMemberUniqueTitleChanged
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberUniqueTitleChanged = null;

            /**
             * NoticeEvent groupEssenceChanged.
             * @member {kritor.event.IEssenceMessageNotice|null|undefined} groupEssenceChanged
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupEssenceChanged = null;

            /**
             * NoticeEvent groupRecall.
             * @member {kritor.event.IGroupRecallNotice|null|undefined} groupRecall
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupRecall = null;

            /**
             * NoticeEvent groupMemberIncrease.
             * @member {kritor.event.IGroupMemberIncreasedNotice|null|undefined} groupMemberIncrease
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberIncrease = null;

            /**
             * NoticeEvent groupMemberDecrease.
             * @member {kritor.event.IGroupMemberDecreasedNotice|null|undefined} groupMemberDecrease
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberDecrease = null;

            /**
             * NoticeEvent groupAdminChanged.
             * @member {kritor.event.IGroupAdminChangedNotice|null|undefined} groupAdminChanged
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupAdminChanged = null;

            /**
             * NoticeEvent groupMemberBanned.
             * @member {kritor.event.IGroupMemberBannedNotice|null|undefined} groupMemberBanned
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberBanned = null;

            /**
             * NoticeEvent groupSign.
             * @member {kritor.event.IGroupSignNotice|null|undefined} groupSign
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupSign = null;

            /**
             * NoticeEvent groupWholeBan.
             * @member {kritor.event.IGroupWholeBanNotice|null|undefined} groupWholeBan
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupWholeBan = null;

            /**
             * NoticeEvent groupFileCome.
             * @member {kritor.event.IGroupFileComeNotice|null|undefined} groupFileCome
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupFileCome = null;

            /**
             * Creates a new NoticeEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent=} [properties] Properties to set
             * @returns {kritor.event.NoticeEvent} NoticeEvent instance
             */
            NoticeEvent.create = function create(properties) {
                return new NoticeEvent(properties);
            };

            /**
             * Encodes the specified NoticeEvent message. Does not implicitly {@link kritor.event.NoticeEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent} message NoticeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticeEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                if (message.friendPoke != null && Object.hasOwnProperty.call(message, "friendPoke"))
                    $root.kritor.event.FriendPokeNotice.encode(message.friendPoke, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.friendRecall != null && Object.hasOwnProperty.call(message, "friendRecall"))
                    $root.kritor.event.FriendRecallNotice.encode(message.friendRecall, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.friendFileCome != null && Object.hasOwnProperty.call(message, "friendFileCome"))
                    $root.kritor.event.FriendFileComeNotice.encode(message.friendFileCome, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.groupPoke != null && Object.hasOwnProperty.call(message, "groupPoke"))
                    $root.kritor.event.GroupPokeNotice.encode(message.groupPoke, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.groupMemberUniqueTitleChanged != null && Object.hasOwnProperty.call(message, "groupMemberUniqueTitleChanged"))
                    $root.kritor.event.GroupUniqueTitleChangedNotice.encode(message.groupMemberUniqueTitleChanged, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.groupEssenceChanged != null && Object.hasOwnProperty.call(message, "groupEssenceChanged"))
                    $root.kritor.event.EssenceMessageNotice.encode(message.groupEssenceChanged, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.groupRecall != null && Object.hasOwnProperty.call(message, "groupRecall"))
                    $root.kritor.event.GroupRecallNotice.encode(message.groupRecall, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.groupMemberIncrease != null && Object.hasOwnProperty.call(message, "groupMemberIncrease"))
                    $root.kritor.event.GroupMemberIncreasedNotice.encode(message.groupMemberIncrease, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.groupMemberDecrease != null && Object.hasOwnProperty.call(message, "groupMemberDecrease"))
                    $root.kritor.event.GroupMemberDecreasedNotice.encode(message.groupMemberDecrease, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.groupAdminChanged != null && Object.hasOwnProperty.call(message, "groupAdminChanged"))
                    $root.kritor.event.GroupAdminChangedNotice.encode(message.groupAdminChanged, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.groupMemberBanned != null && Object.hasOwnProperty.call(message, "groupMemberBanned"))
                    $root.kritor.event.GroupMemberBannedNotice.encode(message.groupMemberBanned, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.groupSign != null && Object.hasOwnProperty.call(message, "groupSign"))
                    $root.kritor.event.GroupSignNotice.encode(message.groupSign, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.groupWholeBan != null && Object.hasOwnProperty.call(message, "groupWholeBan"))
                    $root.kritor.event.GroupWholeBanNotice.encode(message.groupWholeBan, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.groupFileCome != null && Object.hasOwnProperty.call(message, "groupFileCome"))
                    $root.kritor.event.GroupFileComeNotice.encode(message.groupFileCome, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NoticeEvent message, length delimited. Does not implicitly {@link kritor.event.NoticeEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent} message NoticeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticeEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NoticeEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticeEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.NoticeEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.friendPoke = $root.kritor.event.FriendPokeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.friendRecall = $root.kritor.event.FriendRecallNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.friendFileCome = $root.kritor.event.FriendFileComeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.groupPoke = $root.kritor.event.GroupPokeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.groupMemberUniqueTitleChanged = $root.kritor.event.GroupUniqueTitleChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.groupEssenceChanged = $root.kritor.event.EssenceMessageNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.groupRecall = $root.kritor.event.GroupRecallNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.groupMemberIncrease = $root.kritor.event.GroupMemberIncreasedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.groupMemberDecrease = $root.kritor.event.GroupMemberDecreasedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.groupAdminChanged = $root.kritor.event.GroupAdminChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.groupMemberBanned = $root.kritor.event.GroupMemberBannedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.groupSign = $root.kritor.event.GroupSignNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.groupWholeBan = $root.kritor.event.GroupWholeBanNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.groupFileCome = $root.kritor.event.GroupFileComeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NoticeEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticeEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NoticeEvent message.
             * @function verify
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoticeEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.friendPoke != null && message.hasOwnProperty("friendPoke")) {
                    let error = $root.kritor.event.FriendPokeNotice.verify(message.friendPoke);
                    if (error)
                        return "friendPoke." + error;
                }
                if (message.friendRecall != null && message.hasOwnProperty("friendRecall")) {
                    let error = $root.kritor.event.FriendRecallNotice.verify(message.friendRecall);
                    if (error)
                        return "friendRecall." + error;
                }
                if (message.friendFileCome != null && message.hasOwnProperty("friendFileCome")) {
                    let error = $root.kritor.event.FriendFileComeNotice.verify(message.friendFileCome);
                    if (error)
                        return "friendFileCome." + error;
                }
                if (message.groupPoke != null && message.hasOwnProperty("groupPoke")) {
                    let error = $root.kritor.event.GroupPokeNotice.verify(message.groupPoke);
                    if (error)
                        return "groupPoke." + error;
                }
                if (message.groupMemberUniqueTitleChanged != null && message.hasOwnProperty("groupMemberUniqueTitleChanged")) {
                    let error = $root.kritor.event.GroupUniqueTitleChangedNotice.verify(message.groupMemberUniqueTitleChanged);
                    if (error)
                        return "groupMemberUniqueTitleChanged." + error;
                }
                if (message.groupEssenceChanged != null && message.hasOwnProperty("groupEssenceChanged")) {
                    let error = $root.kritor.event.EssenceMessageNotice.verify(message.groupEssenceChanged);
                    if (error)
                        return "groupEssenceChanged." + error;
                }
                if (message.groupRecall != null && message.hasOwnProperty("groupRecall")) {
                    let error = $root.kritor.event.GroupRecallNotice.verify(message.groupRecall);
                    if (error)
                        return "groupRecall." + error;
                }
                if (message.groupMemberIncrease != null && message.hasOwnProperty("groupMemberIncrease")) {
                    let error = $root.kritor.event.GroupMemberIncreasedNotice.verify(message.groupMemberIncrease);
                    if (error)
                        return "groupMemberIncrease." + error;
                }
                if (message.groupMemberDecrease != null && message.hasOwnProperty("groupMemberDecrease")) {
                    let error = $root.kritor.event.GroupMemberDecreasedNotice.verify(message.groupMemberDecrease);
                    if (error)
                        return "groupMemberDecrease." + error;
                }
                if (message.groupAdminChanged != null && message.hasOwnProperty("groupAdminChanged")) {
                    let error = $root.kritor.event.GroupAdminChangedNotice.verify(message.groupAdminChanged);
                    if (error)
                        return "groupAdminChanged." + error;
                }
                if (message.groupMemberBanned != null && message.hasOwnProperty("groupMemberBanned")) {
                    let error = $root.kritor.event.GroupMemberBannedNotice.verify(message.groupMemberBanned);
                    if (error)
                        return "groupMemberBanned." + error;
                }
                if (message.groupSign != null && message.hasOwnProperty("groupSign")) {
                    let error = $root.kritor.event.GroupSignNotice.verify(message.groupSign);
                    if (error)
                        return "groupSign." + error;
                }
                if (message.groupWholeBan != null && message.hasOwnProperty("groupWholeBan")) {
                    let error = $root.kritor.event.GroupWholeBanNotice.verify(message.groupWholeBan);
                    if (error)
                        return "groupWholeBan." + error;
                }
                if (message.groupFileCome != null && message.hasOwnProperty("groupFileCome")) {
                    let error = $root.kritor.event.GroupFileComeNotice.verify(message.groupFileCome);
                    if (error)
                        return "groupFileCome." + error;
                }
                return null;
            };

            /**
             * Creates a NoticeEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             */
            NoticeEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.NoticeEvent)
                    return object;
                let message = new $root.kritor.event.NoticeEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "FRIEND_POKE":
                case 0:
                    message.type = 0;
                    break;
                case "FRIEND_RECALL":
                case 1:
                    message.type = 1;
                    break;
                case "FRIEND_FILE_COME":
                case 2:
                    message.type = 2;
                    break;
                case "GROUP_POKE":
                case 12:
                    message.type = 12;
                    break;
                case "GROUP_CARD_CHANGED":
                case 13:
                    message.type = 13;
                    break;
                case "GROUP_MEMBER_UNIQUE_TITLE_CHANGED":
                case 14:
                    message.type = 14;
                    break;
                case "GROUP_ESSENCE_CHANGED":
                case 15:
                    message.type = 15;
                    break;
                case "GROUP_RECALL":
                case 16:
                    message.type = 16;
                    break;
                case "GROUP_MEMBER_INCREASE":
                case 17:
                    message.type = 17;
                    break;
                case "GROUP_MEMBER_DECREASE":
                case 18:
                    message.type = 18;
                    break;
                case "GROUP_ADMIN_CHANGED":
                case 19:
                    message.type = 19;
                    break;
                case "GROUP_MEMBER_BANNED":
                case 20:
                    message.type = 20;
                    break;
                case "GROUP_SIGN":
                case 21:
                    message.type = 21;
                    break;
                case "GROUP_WHOLE_BAN":
                case 22:
                    message.type = 22;
                    break;
                case "GROUP_FILE_COME":
                case 23:
                    message.type = 23;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.friendPoke != null) {
                    if (typeof object.friendPoke !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friendPoke: object expected");
                    message.friendPoke = $root.kritor.event.FriendPokeNotice.fromObject(object.friendPoke);
                }
                if (object.friendRecall != null) {
                    if (typeof object.friendRecall !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friendRecall: object expected");
                    message.friendRecall = $root.kritor.event.FriendRecallNotice.fromObject(object.friendRecall);
                }
                if (object.friendFileCome != null) {
                    if (typeof object.friendFileCome !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friendFileCome: object expected");
                    message.friendFileCome = $root.kritor.event.FriendFileComeNotice.fromObject(object.friendFileCome);
                }
                if (object.groupPoke != null) {
                    if (typeof object.groupPoke !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupPoke: object expected");
                    message.groupPoke = $root.kritor.event.GroupPokeNotice.fromObject(object.groupPoke);
                }
                if (object.groupMemberUniqueTitleChanged != null) {
                    if (typeof object.groupMemberUniqueTitleChanged !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberUniqueTitleChanged: object expected");
                    message.groupMemberUniqueTitleChanged = $root.kritor.event.GroupUniqueTitleChangedNotice.fromObject(object.groupMemberUniqueTitleChanged);
                }
                if (object.groupEssenceChanged != null) {
                    if (typeof object.groupEssenceChanged !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupEssenceChanged: object expected");
                    message.groupEssenceChanged = $root.kritor.event.EssenceMessageNotice.fromObject(object.groupEssenceChanged);
                }
                if (object.groupRecall != null) {
                    if (typeof object.groupRecall !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupRecall: object expected");
                    message.groupRecall = $root.kritor.event.GroupRecallNotice.fromObject(object.groupRecall);
                }
                if (object.groupMemberIncrease != null) {
                    if (typeof object.groupMemberIncrease !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberIncrease: object expected");
                    message.groupMemberIncrease = $root.kritor.event.GroupMemberIncreasedNotice.fromObject(object.groupMemberIncrease);
                }
                if (object.groupMemberDecrease != null) {
                    if (typeof object.groupMemberDecrease !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberDecrease: object expected");
                    message.groupMemberDecrease = $root.kritor.event.GroupMemberDecreasedNotice.fromObject(object.groupMemberDecrease);
                }
                if (object.groupAdminChanged != null) {
                    if (typeof object.groupAdminChanged !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupAdminChanged: object expected");
                    message.groupAdminChanged = $root.kritor.event.GroupAdminChangedNotice.fromObject(object.groupAdminChanged);
                }
                if (object.groupMemberBanned != null) {
                    if (typeof object.groupMemberBanned !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberBanned: object expected");
                    message.groupMemberBanned = $root.kritor.event.GroupMemberBannedNotice.fromObject(object.groupMemberBanned);
                }
                if (object.groupSign != null) {
                    if (typeof object.groupSign !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupSign: object expected");
                    message.groupSign = $root.kritor.event.GroupSignNotice.fromObject(object.groupSign);
                }
                if (object.groupWholeBan != null) {
                    if (typeof object.groupWholeBan !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupWholeBan: object expected");
                    message.groupWholeBan = $root.kritor.event.GroupWholeBanNotice.fromObject(object.groupWholeBan);
                }
                if (object.groupFileCome != null) {
                    if (typeof object.groupFileCome !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupFileCome: object expected");
                    message.groupFileCome = $root.kritor.event.GroupFileComeNotice.fromObject(object.groupFileCome);
                }
                return message;
            };

            /**
             * Creates a plain object from a NoticeEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.NoticeEvent} message NoticeEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NoticeEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "FRIEND_POKE" : 0;
                    object.time = 0;
                    object.friendPoke = null;
                    object.friendRecall = null;
                    object.friendFileCome = null;
                    object.groupPoke = null;
                    object.groupMemberUniqueTitleChanged = null;
                    object.groupEssenceChanged = null;
                    object.groupRecall = null;
                    object.groupMemberIncrease = null;
                    object.groupMemberDecrease = null;
                    object.groupAdminChanged = null;
                    object.groupMemberBanned = null;
                    object.groupSign = null;
                    object.groupWholeBan = null;
                    object.groupFileCome = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.NoticeType[message.type] === undefined ? message.type : $root.kritor.event.NoticeType[message.type] : message.type;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.friendPoke != null && message.hasOwnProperty("friendPoke"))
                    object.friendPoke = $root.kritor.event.FriendPokeNotice.toObject(message.friendPoke, options);
                if (message.friendRecall != null && message.hasOwnProperty("friendRecall"))
                    object.friendRecall = $root.kritor.event.FriendRecallNotice.toObject(message.friendRecall, options);
                if (message.friendFileCome != null && message.hasOwnProperty("friendFileCome"))
                    object.friendFileCome = $root.kritor.event.FriendFileComeNotice.toObject(message.friendFileCome, options);
                if (message.groupPoke != null && message.hasOwnProperty("groupPoke"))
                    object.groupPoke = $root.kritor.event.GroupPokeNotice.toObject(message.groupPoke, options);
                if (message.groupMemberUniqueTitleChanged != null && message.hasOwnProperty("groupMemberUniqueTitleChanged"))
                    object.groupMemberUniqueTitleChanged = $root.kritor.event.GroupUniqueTitleChangedNotice.toObject(message.groupMemberUniqueTitleChanged, options);
                if (message.groupEssenceChanged != null && message.hasOwnProperty("groupEssenceChanged"))
                    object.groupEssenceChanged = $root.kritor.event.EssenceMessageNotice.toObject(message.groupEssenceChanged, options);
                if (message.groupRecall != null && message.hasOwnProperty("groupRecall"))
                    object.groupRecall = $root.kritor.event.GroupRecallNotice.toObject(message.groupRecall, options);
                if (message.groupMemberIncrease != null && message.hasOwnProperty("groupMemberIncrease"))
                    object.groupMemberIncrease = $root.kritor.event.GroupMemberIncreasedNotice.toObject(message.groupMemberIncrease, options);
                if (message.groupMemberDecrease != null && message.hasOwnProperty("groupMemberDecrease"))
                    object.groupMemberDecrease = $root.kritor.event.GroupMemberDecreasedNotice.toObject(message.groupMemberDecrease, options);
                if (message.groupAdminChanged != null && message.hasOwnProperty("groupAdminChanged"))
                    object.groupAdminChanged = $root.kritor.event.GroupAdminChangedNotice.toObject(message.groupAdminChanged, options);
                if (message.groupMemberBanned != null && message.hasOwnProperty("groupMemberBanned"))
                    object.groupMemberBanned = $root.kritor.event.GroupMemberBannedNotice.toObject(message.groupMemberBanned, options);
                if (message.groupSign != null && message.hasOwnProperty("groupSign"))
                    object.groupSign = $root.kritor.event.GroupSignNotice.toObject(message.groupSign, options);
                if (message.groupWholeBan != null && message.hasOwnProperty("groupWholeBan"))
                    object.groupWholeBan = $root.kritor.event.GroupWholeBanNotice.toObject(message.groupWholeBan, options);
                if (message.groupFileCome != null && message.hasOwnProperty("groupFileCome"))
                    object.groupFileCome = $root.kritor.event.GroupFileComeNotice.toObject(message.groupFileCome, options);
                return object;
            };

            /**
             * Converts this NoticeEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.NoticeEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NoticeEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NoticeEvent
             * @function getTypeUrl
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NoticeEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.NoticeEvent";
            };

            return NoticeEvent;
        })();

        event.EventService = (function() {

            /**
             * Constructs a new EventService service.
             * @memberof kritor.event
             * @classdesc Represents an EventService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function EventService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (EventService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EventService;

            /**
             * Creates new EventService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.event.EventService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {EventService} RPC service. Useful where requests and/or responses are streamed.
             */
            EventService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.event.EventService#registerActiveListener}.
             * @memberof kritor.event.EventService
             * @typedef RegisterActiveListenerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.event.EventStructure} [response] EventStructure
             */

            /**
             * Calls RegisterActiveListener.
             * @function registerActiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IRequestPushEvent} request RequestPushEvent message or plain object
             * @param {kritor.event.EventService.RegisterActiveListenerCallback} callback Node-style callback called with the error, if any, and EventStructure
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(EventService.prototype.registerActiveListener = function registerActiveListener(request, callback) {
                return this.rpcCall(registerActiveListener, $root.kritor.event.RequestPushEvent, $root.kritor.event.EventStructure, request, callback);
            }, "name", { value: "RegisterActiveListener" });

            /**
             * Calls RegisterActiveListener.
             * @function registerActiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IRequestPushEvent} request RequestPushEvent message or plain object
             * @returns {Promise<kritor.event.EventStructure>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.event.EventService#registerPassiveListener}.
             * @memberof kritor.event.EventService
             * @typedef RegisterPassiveListenerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.event.RequestPushEvent} [response] RequestPushEvent
             */

            /**
             * Calls RegisterPassiveListener.
             * @function registerPassiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IEventStructure} request EventStructure message or plain object
             * @param {kritor.event.EventService.RegisterPassiveListenerCallback} callback Node-style callback called with the error, if any, and RequestPushEvent
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(EventService.prototype.registerPassiveListener = function registerPassiveListener(request, callback) {
                return this.rpcCall(registerPassiveListener, $root.kritor.event.EventStructure, $root.kritor.event.RequestPushEvent, request, callback);
            }, "name", { value: "RegisterPassiveListener" });

            /**
             * Calls RegisterPassiveListener.
             * @function registerPassiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IEventStructure} request EventStructure message or plain object
             * @returns {Promise<kritor.event.RequestPushEvent>} Promise
             * @variation 2
             */

            return EventService;
        })();

        return event;
    })();

    kritor.group = (function() {

        /**
         * Namespace group.
         * @memberof kritor
         * @namespace
         */
        const group = {};

        group.File = (function() {

            /**
             * Properties of a File.
             * @memberof kritor.group
             * @interface IFile
             * @property {string|null} [fileId] File fileId
             * @property {string|null} [fileName] File fileName
             * @property {number|Long|null} [fileSize] File fileSize
             * @property {number|null} [busId] File busId
             * @property {number|null} [uploadTime] File uploadTime
             * @property {number|null} [deadTime] File deadTime
             * @property {number|null} [modifyTime] File modifyTime
             * @property {number|null} [downloadTimes] File downloadTimes
             * @property {number|Long|null} [uploader] File uploader
             * @property {string|null} [uploaderName] File uploaderName
             * @property {string|null} [sha] File sha
             * @property {string|null} [sha3] File sha3
             * @property {string|null} [md5] File md5
             */

            /**
             * Constructs a new File.
             * @memberof kritor.group
             * @classdesc Represents a File.
             * @implements IFile
             * @constructor
             * @param {kritor.group.IFile=} [properties] Properties to set
             */
            function File(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * File fileId.
             * @member {string} fileId
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.fileId = "";

            /**
             * File fileName.
             * @member {string} fileName
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.fileName = "";

            /**
             * File fileSize.
             * @member {number|Long} fileSize
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * File busId.
             * @member {number} busId
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.busId = 0;

            /**
             * File uploadTime.
             * @member {number} uploadTime
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.uploadTime = 0;

            /**
             * File deadTime.
             * @member {number} deadTime
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.deadTime = 0;

            /**
             * File modifyTime.
             * @member {number} modifyTime
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.modifyTime = 0;

            /**
             * File downloadTimes.
             * @member {number} downloadTimes
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.downloadTimes = 0;

            /**
             * File uploader.
             * @member {number|Long} uploader
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.uploader = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * File uploaderName.
             * @member {string} uploaderName
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.uploaderName = "";

            /**
             * File sha.
             * @member {string} sha
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.sha = "";

            /**
             * File sha3.
             * @member {string} sha3
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.sha3 = "";

            /**
             * File md5.
             * @member {string} md5
             * @memberof kritor.group.File
             * @instance
             */
            File.prototype.md5 = "";

            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof kritor.group.File
             * @static
             * @param {kritor.group.IFile=} [properties] Properties to set
             * @returns {kritor.group.File} File instance
             */
            File.create = function create(properties) {
                return new File(properties);
            };

            /**
             * Encodes the specified File message. Does not implicitly {@link kritor.group.File.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.File
             * @static
             * @param {kritor.group.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fileSize);
                if (message.busId != null && Object.hasOwnProperty.call(message, "busId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.busId);
                if (message.uploadTime != null && Object.hasOwnProperty.call(message, "uploadTime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.uploadTime);
                if (message.deadTime != null && Object.hasOwnProperty.call(message, "deadTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.deadTime);
                if (message.modifyTime != null && Object.hasOwnProperty.call(message, "modifyTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.modifyTime);
                if (message.downloadTimes != null && Object.hasOwnProperty.call(message, "downloadTimes"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.downloadTimes);
                if (message.uploader != null && Object.hasOwnProperty.call(message, "uploader"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.uploader);
                if (message.uploaderName != null && Object.hasOwnProperty.call(message, "uploaderName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.uploaderName);
                if (message.sha != null && Object.hasOwnProperty.call(message, "sha"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.sha);
                if (message.sha3 != null && Object.hasOwnProperty.call(message, "sha3"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.sha3);
                if (message.md5 != null && Object.hasOwnProperty.call(message, "md5"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.md5);
                return writer;
            };

            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link kritor.group.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.File
             * @static
             * @param {kritor.group.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.File();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 2: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.busId = reader.int32();
                            break;
                        }
                    case 5: {
                            message.uploadTime = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.deadTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.modifyTime = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.downloadTimes = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.uploader = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.uploaderName = reader.string();
                            break;
                        }
                    case 11: {
                            message.sha = reader.string();
                            break;
                        }
                    case 12: {
                            message.sha3 = reader.string();
                            break;
                        }
                    case 13: {
                            message.md5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a File message.
             * @function verify
             * @memberof kritor.group.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                if (message.busId != null && message.hasOwnProperty("busId"))
                    if (!$util.isInteger(message.busId))
                        return "busId: integer expected";
                if (message.uploadTime != null && message.hasOwnProperty("uploadTime"))
                    if (!$util.isInteger(message.uploadTime))
                        return "uploadTime: integer expected";
                if (message.deadTime != null && message.hasOwnProperty("deadTime"))
                    if (!$util.isInteger(message.deadTime))
                        return "deadTime: integer expected";
                if (message.modifyTime != null && message.hasOwnProperty("modifyTime"))
                    if (!$util.isInteger(message.modifyTime))
                        return "modifyTime: integer expected";
                if (message.downloadTimes != null && message.hasOwnProperty("downloadTimes"))
                    if (!$util.isInteger(message.downloadTimes))
                        return "downloadTimes: integer expected";
                if (message.uploader != null && message.hasOwnProperty("uploader"))
                    if (!$util.isInteger(message.uploader) && !(message.uploader && $util.isInteger(message.uploader.low) && $util.isInteger(message.uploader.high)))
                        return "uploader: integer|Long expected";
                if (message.uploaderName != null && message.hasOwnProperty("uploaderName"))
                    if (!$util.isString(message.uploaderName))
                        return "uploaderName: string expected";
                if (message.sha != null && message.hasOwnProperty("sha"))
                    if (!$util.isString(message.sha))
                        return "sha: string expected";
                if (message.sha3 != null && message.hasOwnProperty("sha3"))
                    if (!$util.isString(message.sha3))
                        return "sha3: string expected";
                if (message.md5 != null && message.hasOwnProperty("md5"))
                    if (!$util.isString(message.md5))
                        return "md5: string expected";
                return null;
            };

            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.File} File
             */
            File.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.File)
                    return object;
                let message = new $root.kritor.group.File();
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                if (object.busId != null)
                    message.busId = object.busId | 0;
                if (object.uploadTime != null)
                    message.uploadTime = object.uploadTime >>> 0;
                if (object.deadTime != null)
                    message.deadTime = object.deadTime >>> 0;
                if (object.modifyTime != null)
                    message.modifyTime = object.modifyTime >>> 0;
                if (object.downloadTimes != null)
                    message.downloadTimes = object.downloadTimes >>> 0;
                if (object.uploader != null)
                    if ($util.Long)
                        (message.uploader = $util.Long.fromValue(object.uploader)).unsigned = true;
                    else if (typeof object.uploader === "string")
                        message.uploader = parseInt(object.uploader, 10);
                    else if (typeof object.uploader === "number")
                        message.uploader = object.uploader;
                    else if (typeof object.uploader === "object")
                        message.uploader = new $util.LongBits(object.uploader.low >>> 0, object.uploader.high >>> 0).toNumber(true);
                if (object.uploaderName != null)
                    message.uploaderName = String(object.uploaderName);
                if (object.sha != null)
                    message.sha = String(object.sha);
                if (object.sha3 != null)
                    message.sha3 = String(object.sha3);
                if (object.md5 != null)
                    message.md5 = String(object.md5);
                return message;
            };

            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.File
             * @static
             * @param {kritor.group.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fileId = "";
                    object.fileName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                    object.busId = 0;
                    object.uploadTime = 0;
                    object.deadTime = 0;
                    object.modifyTime = 0;
                    object.downloadTimes = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uploader = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uploader = options.longs === String ? "0" : 0;
                    object.uploaderName = "";
                    object.sha = "";
                    object.sha3 = "";
                    object.md5 = "";
                }
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                if (message.busId != null && message.hasOwnProperty("busId"))
                    object.busId = message.busId;
                if (message.uploadTime != null && message.hasOwnProperty("uploadTime"))
                    object.uploadTime = message.uploadTime;
                if (message.deadTime != null && message.hasOwnProperty("deadTime"))
                    object.deadTime = message.deadTime;
                if (message.modifyTime != null && message.hasOwnProperty("modifyTime"))
                    object.modifyTime = message.modifyTime;
                if (message.downloadTimes != null && message.hasOwnProperty("downloadTimes"))
                    object.downloadTimes = message.downloadTimes;
                if (message.uploader != null && message.hasOwnProperty("uploader"))
                    if (typeof message.uploader === "number")
                        object.uploader = options.longs === String ? String(message.uploader) : message.uploader;
                    else
                        object.uploader = options.longs === String ? $util.Long.prototype.toString.call(message.uploader) : options.longs === Number ? new $util.LongBits(message.uploader.low >>> 0, message.uploader.high >>> 0).toNumber(true) : message.uploader;
                if (message.uploaderName != null && message.hasOwnProperty("uploaderName"))
                    object.uploaderName = message.uploaderName;
                if (message.sha != null && message.hasOwnProperty("sha"))
                    object.sha = message.sha;
                if (message.sha3 != null && message.hasOwnProperty("sha3"))
                    object.sha3 = message.sha3;
                if (message.md5 != null && message.hasOwnProperty("md5"))
                    object.md5 = message.md5;
                return object;
            };

            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof kritor.group.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for File
             * @function getTypeUrl
             * @memberof kritor.group.File
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            File.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.File";
            };

            return File;
        })();

        group.Folder = (function() {

            /**
             * Properties of a Folder.
             * @memberof kritor.group
             * @interface IFolder
             * @property {string|null} [folderId] Folder folderId
             * @property {string|null} [folderName] Folder folderName
             * @property {number|null} [totalFileCount] Folder totalFileCount
             * @property {number|null} [createTime] Folder createTime
             * @property {number|Long|null} [creator] Folder creator
             * @property {string|null} [creatorName] Folder creatorName
             */

            /**
             * Constructs a new Folder.
             * @memberof kritor.group
             * @classdesc Represents a Folder.
             * @implements IFolder
             * @constructor
             * @param {kritor.group.IFolder=} [properties] Properties to set
             */
            function Folder(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Folder folderId.
             * @member {string} folderId
             * @memberof kritor.group.Folder
             * @instance
             */
            Folder.prototype.folderId = "";

            /**
             * Folder folderName.
             * @member {string} folderName
             * @memberof kritor.group.Folder
             * @instance
             */
            Folder.prototype.folderName = "";

            /**
             * Folder totalFileCount.
             * @member {number} totalFileCount
             * @memberof kritor.group.Folder
             * @instance
             */
            Folder.prototype.totalFileCount = 0;

            /**
             * Folder createTime.
             * @member {number} createTime
             * @memberof kritor.group.Folder
             * @instance
             */
            Folder.prototype.createTime = 0;

            /**
             * Folder creator.
             * @member {number|Long} creator
             * @memberof kritor.group.Folder
             * @instance
             */
            Folder.prototype.creator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Folder creatorName.
             * @member {string} creatorName
             * @memberof kritor.group.Folder
             * @instance
             */
            Folder.prototype.creatorName = "";

            /**
             * Creates a new Folder instance using the specified properties.
             * @function create
             * @memberof kritor.group.Folder
             * @static
             * @param {kritor.group.IFolder=} [properties] Properties to set
             * @returns {kritor.group.Folder} Folder instance
             */
            Folder.create = function create(properties) {
                return new Folder(properties);
            };

            /**
             * Encodes the specified Folder message. Does not implicitly {@link kritor.group.Folder.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.Folder
             * @static
             * @param {kritor.group.IFolder} message Folder message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Folder.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.folderId);
                if (message.folderName != null && Object.hasOwnProperty.call(message, "folderName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderName);
                if (message.totalFileCount != null && Object.hasOwnProperty.call(message, "totalFileCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.totalFileCount);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.createTime);
                if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.creator);
                if (message.creatorName != null && Object.hasOwnProperty.call(message, "creatorName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.creatorName);
                return writer;
            };

            /**
             * Encodes the specified Folder message, length delimited. Does not implicitly {@link kritor.group.Folder.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.Folder
             * @static
             * @param {kritor.group.IFolder} message Folder message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Folder.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Folder message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.Folder
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.Folder} Folder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Folder.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.Folder();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.folderId = reader.string();
                            break;
                        }
                    case 2: {
                            message.folderName = reader.string();
                            break;
                        }
                    case 3: {
                            message.totalFileCount = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.createTime = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.creator = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.creatorName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Folder message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.Folder
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.Folder} Folder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Folder.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Folder message.
             * @function verify
             * @memberof kritor.group.Folder
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Folder.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                if (message.folderName != null && message.hasOwnProperty("folderName"))
                    if (!$util.isString(message.folderName))
                        return "folderName: string expected";
                if (message.totalFileCount != null && message.hasOwnProperty("totalFileCount"))
                    if (!$util.isInteger(message.totalFileCount))
                        return "totalFileCount: integer expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime))
                        return "createTime: integer expected";
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (!$util.isInteger(message.creator) && !(message.creator && $util.isInteger(message.creator.low) && $util.isInteger(message.creator.high)))
                        return "creator: integer|Long expected";
                if (message.creatorName != null && message.hasOwnProperty("creatorName"))
                    if (!$util.isString(message.creatorName))
                        return "creatorName: string expected";
                return null;
            };

            /**
             * Creates a Folder message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.Folder
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.Folder} Folder
             */
            Folder.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.Folder)
                    return object;
                let message = new $root.kritor.group.Folder();
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                if (object.folderName != null)
                    message.folderName = String(object.folderName);
                if (object.totalFileCount != null)
                    message.totalFileCount = object.totalFileCount >>> 0;
                if (object.createTime != null)
                    message.createTime = object.createTime >>> 0;
                if (object.creator != null)
                    if ($util.Long)
                        (message.creator = $util.Long.fromValue(object.creator)).unsigned = true;
                    else if (typeof object.creator === "string")
                        message.creator = parseInt(object.creator, 10);
                    else if (typeof object.creator === "number")
                        message.creator = object.creator;
                    else if (typeof object.creator === "object")
                        message.creator = new $util.LongBits(object.creator.low >>> 0, object.creator.high >>> 0).toNumber(true);
                if (object.creatorName != null)
                    message.creatorName = String(object.creatorName);
                return message;
            };

            /**
             * Creates a plain object from a Folder message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.Folder
             * @static
             * @param {kritor.group.Folder} message Folder
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Folder.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.folderId = "";
                    object.folderName = "";
                    object.totalFileCount = 0;
                    object.createTime = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.creator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creator = options.longs === String ? "0" : 0;
                    object.creatorName = "";
                }
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                if (message.folderName != null && message.hasOwnProperty("folderName"))
                    object.folderName = message.folderName;
                if (message.totalFileCount != null && message.hasOwnProperty("totalFileCount"))
                    object.totalFileCount = message.totalFileCount;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    object.createTime = message.createTime;
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (typeof message.creator === "number")
                        object.creator = options.longs === String ? String(message.creator) : message.creator;
                    else
                        object.creator = options.longs === String ? $util.Long.prototype.toString.call(message.creator) : options.longs === Number ? new $util.LongBits(message.creator.low >>> 0, message.creator.high >>> 0).toNumber(true) : message.creator;
                if (message.creatorName != null && message.hasOwnProperty("creatorName"))
                    object.creatorName = message.creatorName;
                return object;
            };

            /**
             * Converts this Folder to JSON.
             * @function toJSON
             * @memberof kritor.group.Folder
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Folder.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Folder
             * @function getTypeUrl
             * @memberof kritor.group.Folder
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Folder.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.Folder";
            };

            return Folder;
        })();

        group.GroupFileService = (function() {

            /**
             * Constructs a new GroupFileService service.
             * @memberof kritor.group
             * @classdesc Represents a GroupFileService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GroupFileService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GroupFileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroupFileService;

            /**
             * Creates new GroupFileService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.group.GroupFileService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GroupFileService} RPC service. Useful where requests and/or responses are streamed.
             */
            GroupFileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.group.GroupFileService#createFolder}.
             * @memberof kritor.group.GroupFileService
             * @typedef CreateFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.CreateFolderResponse} [response] CreateFolderResponse
             */

            /**
             * Calls CreateFolder.
             * @function createFolder
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.ICreateFolderRequest} request CreateFolderRequest message or plain object
             * @param {kritor.group.GroupFileService.CreateFolderCallback} callback Node-style callback called with the error, if any, and CreateFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.createFolder = function createFolder(request, callback) {
                return this.rpcCall(createFolder, $root.kritor.group.CreateFolderRequest, $root.kritor.group.CreateFolderResponse, request, callback);
            }, "name", { value: "CreateFolder" });

            /**
             * Calls CreateFolder.
             * @function createFolder
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.ICreateFolderRequest} request CreateFolderRequest message or plain object
             * @returns {Promise<kritor.group.CreateFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupFileService#deleteFolder}.
             * @memberof kritor.group.GroupFileService
             * @typedef DeleteFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.DeleteFolderResponse} [response] DeleteFolderResponse
             */

            /**
             * Calls DeleteFolder.
             * @function deleteFolder
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IDeleteFolderRequest} request DeleteFolderRequest message or plain object
             * @param {kritor.group.GroupFileService.DeleteFolderCallback} callback Node-style callback called with the error, if any, and DeleteFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.deleteFolder = function deleteFolder(request, callback) {
                return this.rpcCall(deleteFolder, $root.kritor.group.DeleteFolderRequest, $root.kritor.group.DeleteFolderResponse, request, callback);
            }, "name", { value: "DeleteFolder" });

            /**
             * Calls DeleteFolder.
             * @function deleteFolder
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IDeleteFolderRequest} request DeleteFolderRequest message or plain object
             * @returns {Promise<kritor.group.DeleteFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupFileService#deleteFile}.
             * @memberof kritor.group.GroupFileService
             * @typedef DeleteFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.DeleteFileResponse} [response] DeleteFileResponse
             */

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @param {kritor.group.GroupFileService.DeleteFileCallback} callback Node-style callback called with the error, if any, and DeleteFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.deleteFile = function deleteFile(request, callback) {
                return this.rpcCall(deleteFile, $root.kritor.group.DeleteFileRequest, $root.kritor.group.DeleteFileResponse, request, callback);
            }, "name", { value: "DeleteFile" });

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @returns {Promise<kritor.group.DeleteFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupFileService#renameFolder}.
             * @memberof kritor.group.GroupFileService
             * @typedef RenameFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.RenameFolderResponse} [response] RenameFolderResponse
             */

            /**
             * Calls RenameFolder.
             * @function renameFolder
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IRenameFolderRequest} request RenameFolderRequest message or plain object
             * @param {kritor.group.GroupFileService.RenameFolderCallback} callback Node-style callback called with the error, if any, and RenameFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.renameFolder = function renameFolder(request, callback) {
                return this.rpcCall(renameFolder, $root.kritor.group.RenameFolderRequest, $root.kritor.group.RenameFolderResponse, request, callback);
            }, "name", { value: "RenameFolder" });

            /**
             * Calls RenameFolder.
             * @function renameFolder
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IRenameFolderRequest} request RenameFolderRequest message or plain object
             * @returns {Promise<kritor.group.RenameFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupFileService#getFileSystemInfo}.
             * @memberof kritor.group.GroupFileService
             * @typedef GetFileSystemInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetFileSystemInfoResponse} [response] GetFileSystemInfoResponse
             */

            /**
             * Calls GetFileSystemInfo.
             * @function getFileSystemInfo
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IGetFileSystemInfoRequest} request GetFileSystemInfoRequest message or plain object
             * @param {kritor.group.GroupFileService.GetFileSystemInfoCallback} callback Node-style callback called with the error, if any, and GetFileSystemInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getFileSystemInfo = function getFileSystemInfo(request, callback) {
                return this.rpcCall(getFileSystemInfo, $root.kritor.group.GetFileSystemInfoRequest, $root.kritor.group.GetFileSystemInfoResponse, request, callback);
            }, "name", { value: "GetFileSystemInfo" });

            /**
             * Calls GetFileSystemInfo.
             * @function getFileSystemInfo
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IGetFileSystemInfoRequest} request GetFileSystemInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetFileSystemInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupFileService#getRootFiles}.
             * @memberof kritor.group.GroupFileService
             * @typedef GetRootFilesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetRootFilesResponse} [response] GetRootFilesResponse
             */

            /**
             * Calls GetRootFiles.
             * @function getRootFiles
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IGetRootFilesRequest} request GetRootFilesRequest message or plain object
             * @param {kritor.group.GroupFileService.GetRootFilesCallback} callback Node-style callback called with the error, if any, and GetRootFilesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getRootFiles = function getRootFiles(request, callback) {
                return this.rpcCall(getRootFiles, $root.kritor.group.GetRootFilesRequest, $root.kritor.group.GetRootFilesResponse, request, callback);
            }, "name", { value: "GetRootFiles" });

            /**
             * Calls GetRootFiles.
             * @function getRootFiles
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IGetRootFilesRequest} request GetRootFilesRequest message or plain object
             * @returns {Promise<kritor.group.GetRootFilesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupFileService#getFiles}.
             * @memberof kritor.group.GroupFileService
             * @typedef GetFilesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetFilesResponse} [response] GetFilesResponse
             */

            /**
             * Calls GetFiles.
             * @function getFiles
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IGetFilesRequest} request GetFilesRequest message or plain object
             * @param {kritor.group.GroupFileService.GetFilesCallback} callback Node-style callback called with the error, if any, and GetFilesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getFiles = function getFiles(request, callback) {
                return this.rpcCall(getFiles, $root.kritor.group.GetFilesRequest, $root.kritor.group.GetFilesResponse, request, callback);
            }, "name", { value: "GetFiles" });

            /**
             * Calls GetFiles.
             * @function getFiles
             * @memberof kritor.group.GroupFileService
             * @instance
             * @param {kritor.group.IGetFilesRequest} request GetFilesRequest message or plain object
             * @returns {Promise<kritor.group.GetFilesResponse>} Promise
             * @variation 2
             */

            return GroupFileService;
        })();

        group.CreateFolderRequest = (function() {

            /**
             * Properties of a CreateFolderRequest.
             * @memberof kritor.group
             * @interface ICreateFolderRequest
             * @property {number|Long|null} [groupId] CreateFolderRequest groupId
             * @property {string|null} [name] CreateFolderRequest name
             */

            /**
             * Constructs a new CreateFolderRequest.
             * @memberof kritor.group
             * @classdesc Represents a CreateFolderRequest.
             * @implements ICreateFolderRequest
             * @constructor
             * @param {kritor.group.ICreateFolderRequest=} [properties] Properties to set
             */
            function CreateFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateFolderRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.CreateFolderRequest
             * @instance
             */
            CreateFolderRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CreateFolderRequest name.
             * @member {string} name
             * @memberof kritor.group.CreateFolderRequest
             * @instance
             */
            CreateFolderRequest.prototype.name = "";

            /**
             * Creates a new CreateFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {kritor.group.ICreateFolderRequest=} [properties] Properties to set
             * @returns {kritor.group.CreateFolderRequest} CreateFolderRequest instance
             */
            CreateFolderRequest.create = function create(properties) {
                return new CreateFolderRequest(properties);
            };

            /**
             * Encodes the specified CreateFolderRequest message. Does not implicitly {@link kritor.group.CreateFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {kritor.group.ICreateFolderRequest} message CreateFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified CreateFolderRequest message, length delimited. Does not implicitly {@link kritor.group.CreateFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {kritor.group.ICreateFolderRequest} message CreateFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.CreateFolderRequest} CreateFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.CreateFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.CreateFolderRequest} CreateFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateFolderRequest message.
             * @function verify
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a CreateFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.CreateFolderRequest} CreateFolderRequest
             */
            CreateFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.CreateFolderRequest)
                    return object;
                let message = new $root.kritor.group.CreateFolderRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a CreateFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {kritor.group.CreateFolderRequest} message CreateFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.name = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this CreateFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.CreateFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateFolderRequest
             * @function getTypeUrl
             * @memberof kritor.group.CreateFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.CreateFolderRequest";
            };

            return CreateFolderRequest;
        })();

        group.CreateFolderResponse = (function() {

            /**
             * Properties of a CreateFolderResponse.
             * @memberof kritor.group
             * @interface ICreateFolderResponse
             * @property {string|null} [id] CreateFolderResponse id
             * @property {number|Long|null} [usedSpace] CreateFolderResponse usedSpace
             */

            /**
             * Constructs a new CreateFolderResponse.
             * @memberof kritor.group
             * @classdesc Represents a CreateFolderResponse.
             * @implements ICreateFolderResponse
             * @constructor
             * @param {kritor.group.ICreateFolderResponse=} [properties] Properties to set
             */
            function CreateFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateFolderResponse id.
             * @member {string} id
             * @memberof kritor.group.CreateFolderResponse
             * @instance
             */
            CreateFolderResponse.prototype.id = "";

            /**
             * CreateFolderResponse usedSpace.
             * @member {number|Long} usedSpace
             * @memberof kritor.group.CreateFolderResponse
             * @instance
             */
            CreateFolderResponse.prototype.usedSpace = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CreateFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {kritor.group.ICreateFolderResponse=} [properties] Properties to set
             * @returns {kritor.group.CreateFolderResponse} CreateFolderResponse instance
             */
            CreateFolderResponse.create = function create(properties) {
                return new CreateFolderResponse(properties);
            };

            /**
             * Encodes the specified CreateFolderResponse message. Does not implicitly {@link kritor.group.CreateFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {kritor.group.ICreateFolderResponse} message CreateFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.usedSpace != null && Object.hasOwnProperty.call(message, "usedSpace"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.usedSpace);
                return writer;
            };

            /**
             * Encodes the specified CreateFolderResponse message, length delimited. Does not implicitly {@link kritor.group.CreateFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {kritor.group.ICreateFolderResponse} message CreateFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.CreateFolderResponse} CreateFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.CreateFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.usedSpace = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.CreateFolderResponse} CreateFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateFolderResponse message.
             * @function verify
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    if (!$util.isInteger(message.usedSpace) && !(message.usedSpace && $util.isInteger(message.usedSpace.low) && $util.isInteger(message.usedSpace.high)))
                        return "usedSpace: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.CreateFolderResponse} CreateFolderResponse
             */
            CreateFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.CreateFolderResponse)
                    return object;
                let message = new $root.kritor.group.CreateFolderResponse();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.usedSpace != null)
                    if ($util.Long)
                        (message.usedSpace = $util.Long.fromValue(object.usedSpace)).unsigned = true;
                    else if (typeof object.usedSpace === "string")
                        message.usedSpace = parseInt(object.usedSpace, 10);
                    else if (typeof object.usedSpace === "number")
                        message.usedSpace = object.usedSpace;
                    else if (typeof object.usedSpace === "object")
                        message.usedSpace = new $util.LongBits(object.usedSpace.low >>> 0, object.usedSpace.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CreateFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {kritor.group.CreateFolderResponse} message CreateFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateFolderResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.usedSpace = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.usedSpace = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    if (typeof message.usedSpace === "number")
                        object.usedSpace = options.longs === String ? String(message.usedSpace) : message.usedSpace;
                    else
                        object.usedSpace = options.longs === String ? $util.Long.prototype.toString.call(message.usedSpace) : options.longs === Number ? new $util.LongBits(message.usedSpace.low >>> 0, message.usedSpace.high >>> 0).toNumber(true) : message.usedSpace;
                return object;
            };

            /**
             * Converts this CreateFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.CreateFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateFolderResponse
             * @function getTypeUrl
             * @memberof kritor.group.CreateFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.CreateFolderResponse";
            };

            return CreateFolderResponse;
        })();

        group.DeleteFolderRequest = (function() {

            /**
             * Properties of a DeleteFolderRequest.
             * @memberof kritor.group
             * @interface IDeleteFolderRequest
             * @property {number|Long|null} [groupId] DeleteFolderRequest groupId
             * @property {string|null} [folderId] DeleteFolderRequest folderId
             */

            /**
             * Constructs a new DeleteFolderRequest.
             * @memberof kritor.group
             * @classdesc Represents a DeleteFolderRequest.
             * @implements IDeleteFolderRequest
             * @constructor
             * @param {kritor.group.IDeleteFolderRequest=} [properties] Properties to set
             */
            function DeleteFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFolderRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.DeleteFolderRequest
             * @instance
             */
            DeleteFolderRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteFolderRequest folderId.
             * @member {string} folderId
             * @memberof kritor.group.DeleteFolderRequest
             * @instance
             */
            DeleteFolderRequest.prototype.folderId = "";

            /**
             * Creates a new DeleteFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {kritor.group.IDeleteFolderRequest=} [properties] Properties to set
             * @returns {kritor.group.DeleteFolderRequest} DeleteFolderRequest instance
             */
            DeleteFolderRequest.create = function create(properties) {
                return new DeleteFolderRequest(properties);
            };

            /**
             * Encodes the specified DeleteFolderRequest message. Does not implicitly {@link kritor.group.DeleteFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {kritor.group.IDeleteFolderRequest} message DeleteFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderId);
                return writer;
            };

            /**
             * Encodes the specified DeleteFolderRequest message, length delimited. Does not implicitly {@link kritor.group.DeleteFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {kritor.group.IDeleteFolderRequest} message DeleteFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.DeleteFolderRequest} DeleteFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.DeleteFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folderId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.DeleteFolderRequest} DeleteFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFolderRequest message.
             * @function verify
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                return null;
            };

            /**
             * Creates a DeleteFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.DeleteFolderRequest} DeleteFolderRequest
             */
            DeleteFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.DeleteFolderRequest)
                    return object;
                let message = new $root.kritor.group.DeleteFolderRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                return message;
            };

            /**
             * Creates a plain object from a DeleteFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {kritor.group.DeleteFolderRequest} message DeleteFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.folderId = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                return object;
            };

            /**
             * Converts this DeleteFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.DeleteFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFolderRequest
             * @function getTypeUrl
             * @memberof kritor.group.DeleteFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.DeleteFolderRequest";
            };

            return DeleteFolderRequest;
        })();

        group.DeleteFolderResponse = (function() {

            /**
             * Properties of a DeleteFolderResponse.
             * @memberof kritor.group
             * @interface IDeleteFolderResponse
             */

            /**
             * Constructs a new DeleteFolderResponse.
             * @memberof kritor.group
             * @classdesc Represents a DeleteFolderResponse.
             * @implements IDeleteFolderResponse
             * @constructor
             * @param {kritor.group.IDeleteFolderResponse=} [properties] Properties to set
             */
            function DeleteFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {kritor.group.IDeleteFolderResponse=} [properties] Properties to set
             * @returns {kritor.group.DeleteFolderResponse} DeleteFolderResponse instance
             */
            DeleteFolderResponse.create = function create(properties) {
                return new DeleteFolderResponse(properties);
            };

            /**
             * Encodes the specified DeleteFolderResponse message. Does not implicitly {@link kritor.group.DeleteFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {kritor.group.IDeleteFolderResponse} message DeleteFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteFolderResponse message, length delimited. Does not implicitly {@link kritor.group.DeleteFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {kritor.group.IDeleteFolderResponse} message DeleteFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.DeleteFolderResponse} DeleteFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.DeleteFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.DeleteFolderResponse} DeleteFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFolderResponse message.
             * @function verify
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.DeleteFolderResponse} DeleteFolderResponse
             */
            DeleteFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.DeleteFolderResponse)
                    return object;
                return new $root.kritor.group.DeleteFolderResponse();
            };

            /**
             * Creates a plain object from a DeleteFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {kritor.group.DeleteFolderResponse} message DeleteFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFolderResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.DeleteFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFolderResponse
             * @function getTypeUrl
             * @memberof kritor.group.DeleteFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.DeleteFolderResponse";
            };

            return DeleteFolderResponse;
        })();

        group.DeleteFileRequest = (function() {

            /**
             * Properties of a DeleteFileRequest.
             * @memberof kritor.group
             * @interface IDeleteFileRequest
             * @property {number|Long|null} [groupId] DeleteFileRequest groupId
             * @property {string|null} [fileId] DeleteFileRequest fileId
             * @property {number|null} [busId] DeleteFileRequest busId
             */

            /**
             * Constructs a new DeleteFileRequest.
             * @memberof kritor.group
             * @classdesc Represents a DeleteFileRequest.
             * @implements IDeleteFileRequest
             * @constructor
             * @param {kritor.group.IDeleteFileRequest=} [properties] Properties to set
             */
            function DeleteFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFileRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteFileRequest fileId.
             * @member {string} fileId
             * @memberof kritor.group.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.fileId = "";

            /**
             * DeleteFileRequest busId.
             * @member {number} busId
             * @memberof kritor.group.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.busId = 0;

            /**
             * Creates a new DeleteFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {kritor.group.IDeleteFileRequest=} [properties] Properties to set
             * @returns {kritor.group.DeleteFileRequest} DeleteFileRequest instance
             */
            DeleteFileRequest.create = function create(properties) {
                return new DeleteFileRequest(properties);
            };

            /**
             * Encodes the specified DeleteFileRequest message. Does not implicitly {@link kritor.group.DeleteFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {kritor.group.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileId);
                if (message.busId != null && Object.hasOwnProperty.call(message, "busId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.busId);
                return writer;
            };

            /**
             * Encodes the specified DeleteFileRequest message, length delimited. Does not implicitly {@link kritor.group.DeleteFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {kritor.group.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.DeleteFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 3: {
                            message.busId = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileRequest message.
             * @function verify
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.busId != null && message.hasOwnProperty("busId"))
                    if (!$util.isInteger(message.busId))
                        return "busId: integer expected";
                return null;
            };

            /**
             * Creates a DeleteFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.DeleteFileRequest} DeleteFileRequest
             */
            DeleteFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.DeleteFileRequest)
                    return object;
                let message = new $root.kritor.group.DeleteFileRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.busId != null)
                    message.busId = object.busId | 0;
                return message;
            };

            /**
             * Creates a plain object from a DeleteFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {kritor.group.DeleteFileRequest} message DeleteFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.fileId = "";
                    object.busId = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.busId != null && message.hasOwnProperty("busId"))
                    object.busId = message.busId;
                return object;
            };

            /**
             * Converts this DeleteFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.DeleteFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileRequest
             * @function getTypeUrl
             * @memberof kritor.group.DeleteFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.DeleteFileRequest";
            };

            return DeleteFileRequest;
        })();

        group.DeleteFileResponse = (function() {

            /**
             * Properties of a DeleteFileResponse.
             * @memberof kritor.group
             * @interface IDeleteFileResponse
             */

            /**
             * Constructs a new DeleteFileResponse.
             * @memberof kritor.group
             * @classdesc Represents a DeleteFileResponse.
             * @implements IDeleteFileResponse
             * @constructor
             * @param {kritor.group.IDeleteFileResponse=} [properties] Properties to set
             */
            function DeleteFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {kritor.group.IDeleteFileResponse=} [properties] Properties to set
             * @returns {kritor.group.DeleteFileResponse} DeleteFileResponse instance
             */
            DeleteFileResponse.create = function create(properties) {
                return new DeleteFileResponse(properties);
            };

            /**
             * Encodes the specified DeleteFileResponse message. Does not implicitly {@link kritor.group.DeleteFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {kritor.group.IDeleteFileResponse} message DeleteFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteFileResponse message, length delimited. Does not implicitly {@link kritor.group.DeleteFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {kritor.group.IDeleteFileResponse} message DeleteFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.DeleteFileResponse} DeleteFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.DeleteFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.DeleteFileResponse} DeleteFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileResponse message.
             * @function verify
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.DeleteFileResponse} DeleteFileResponse
             */
            DeleteFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.DeleteFileResponse)
                    return object;
                return new $root.kritor.group.DeleteFileResponse();
            };

            /**
             * Creates a plain object from a DeleteFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {kritor.group.DeleteFileResponse} message DeleteFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.DeleteFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileResponse
             * @function getTypeUrl
             * @memberof kritor.group.DeleteFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.DeleteFileResponse";
            };

            return DeleteFileResponse;
        })();

        group.RenameFolderRequest = (function() {

            /**
             * Properties of a RenameFolderRequest.
             * @memberof kritor.group
             * @interface IRenameFolderRequest
             * @property {number|Long|null} [groupId] RenameFolderRequest groupId
             * @property {string|null} [folderId] RenameFolderRequest folderId
             * @property {string|null} [name] RenameFolderRequest name
             */

            /**
             * Constructs a new RenameFolderRequest.
             * @memberof kritor.group
             * @classdesc Represents a RenameFolderRequest.
             * @implements IRenameFolderRequest
             * @constructor
             * @param {kritor.group.IRenameFolderRequest=} [properties] Properties to set
             */
            function RenameFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameFolderRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RenameFolderRequest folderId.
             * @member {string} folderId
             * @memberof kritor.group.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.folderId = "";

            /**
             * RenameFolderRequest name.
             * @member {string} name
             * @memberof kritor.group.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.name = "";

            /**
             * Creates a new RenameFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {kritor.group.IRenameFolderRequest=} [properties] Properties to set
             * @returns {kritor.group.RenameFolderRequest} RenameFolderRequest instance
             */
            RenameFolderRequest.create = function create(properties) {
                return new RenameFolderRequest(properties);
            };

            /**
             * Encodes the specified RenameFolderRequest message. Does not implicitly {@link kritor.group.RenameFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {kritor.group.IRenameFolderRequest} message RenameFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified RenameFolderRequest message, length delimited. Does not implicitly {@link kritor.group.RenameFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {kritor.group.IRenameFolderRequest} message RenameFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.RenameFolderRequest} RenameFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.RenameFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folderId = reader.string();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.RenameFolderRequest} RenameFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFolderRequest message.
             * @function verify
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a RenameFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.RenameFolderRequest} RenameFolderRequest
             */
            RenameFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.RenameFolderRequest)
                    return object;
                let message = new $root.kritor.group.RenameFolderRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a RenameFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {kritor.group.RenameFolderRequest} message RenameFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.folderId = "";
                    object.name = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this RenameFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.RenameFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFolderRequest
             * @function getTypeUrl
             * @memberof kritor.group.RenameFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.RenameFolderRequest";
            };

            return RenameFolderRequest;
        })();

        group.RenameFolderResponse = (function() {

            /**
             * Properties of a RenameFolderResponse.
             * @memberof kritor.group
             * @interface IRenameFolderResponse
             */

            /**
             * Constructs a new RenameFolderResponse.
             * @memberof kritor.group
             * @classdesc Represents a RenameFolderResponse.
             * @implements IRenameFolderResponse
             * @constructor
             * @param {kritor.group.IRenameFolderResponse=} [properties] Properties to set
             */
            function RenameFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RenameFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {kritor.group.IRenameFolderResponse=} [properties] Properties to set
             * @returns {kritor.group.RenameFolderResponse} RenameFolderResponse instance
             */
            RenameFolderResponse.create = function create(properties) {
                return new RenameFolderResponse(properties);
            };

            /**
             * Encodes the specified RenameFolderResponse message. Does not implicitly {@link kritor.group.RenameFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {kritor.group.IRenameFolderResponse} message RenameFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RenameFolderResponse message, length delimited. Does not implicitly {@link kritor.group.RenameFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {kritor.group.IRenameFolderResponse} message RenameFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.RenameFolderResponse} RenameFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.RenameFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.RenameFolderResponse} RenameFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFolderResponse message.
             * @function verify
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RenameFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.RenameFolderResponse} RenameFolderResponse
             */
            RenameFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.RenameFolderResponse)
                    return object;
                return new $root.kritor.group.RenameFolderResponse();
            };

            /**
             * Creates a plain object from a RenameFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {kritor.group.RenameFolderResponse} message RenameFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFolderResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RenameFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.RenameFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFolderResponse
             * @function getTypeUrl
             * @memberof kritor.group.RenameFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.RenameFolderResponse";
            };

            return RenameFolderResponse;
        })();

        group.GetFileSystemInfoRequest = (function() {

            /**
             * Properties of a GetFileSystemInfoRequest.
             * @memberof kritor.group
             * @interface IGetFileSystemInfoRequest
             * @property {number|Long|null} [groupId] GetFileSystemInfoRequest groupId
             */

            /**
             * Constructs a new GetFileSystemInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetFileSystemInfoRequest.
             * @implements IGetFileSystemInfoRequest
             * @constructor
             * @param {kritor.group.IGetFileSystemInfoRequest=} [properties] Properties to set
             */
            function GetFileSystemInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileSystemInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @instance
             */
            GetFileSystemInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetFileSystemInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {kritor.group.IGetFileSystemInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetFileSystemInfoRequest} GetFileSystemInfoRequest instance
             */
            GetFileSystemInfoRequest.create = function create(properties) {
                return new GetFileSystemInfoRequest(properties);
            };

            /**
             * Encodes the specified GetFileSystemInfoRequest message. Does not implicitly {@link kritor.group.GetFileSystemInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {kritor.group.IGetFileSystemInfoRequest} message GetFileSystemInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetFileSystemInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetFileSystemInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {kritor.group.IGetFileSystemInfoRequest} message GetFileSystemInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileSystemInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetFileSystemInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileSystemInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileSystemInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileSystemInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetFileSystemInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             */
            GetFileSystemInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetFileSystemInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetFileSystemInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetFileSystemInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {kritor.group.GetFileSystemInfoRequest} message GetFileSystemInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileSystemInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetFileSystemInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileSystemInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileSystemInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetFileSystemInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileSystemInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetFileSystemInfoRequest";
            };

            return GetFileSystemInfoRequest;
        })();

        group.GetFileSystemInfoResponse = (function() {

            /**
             * Properties of a GetFileSystemInfoResponse.
             * @memberof kritor.group
             * @interface IGetFileSystemInfoResponse
             * @property {number|null} [fileCount] GetFileSystemInfoResponse fileCount
             * @property {number|null} [totalCount] GetFileSystemInfoResponse totalCount
             * @property {number|null} [usedSpace] GetFileSystemInfoResponse usedSpace
             * @property {number|null} [totalSpace] GetFileSystemInfoResponse totalSpace
             */

            /**
             * Constructs a new GetFileSystemInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetFileSystemInfoResponse.
             * @implements IGetFileSystemInfoResponse
             * @constructor
             * @param {kritor.group.IGetFileSystemInfoResponse=} [properties] Properties to set
             */
            function GetFileSystemInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileSystemInfoResponse fileCount.
             * @member {number} fileCount
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.fileCount = 0;

            /**
             * GetFileSystemInfoResponse totalCount.
             * @member {number} totalCount
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.totalCount = 0;

            /**
             * GetFileSystemInfoResponse usedSpace.
             * @member {number} usedSpace
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.usedSpace = 0;

            /**
             * GetFileSystemInfoResponse totalSpace.
             * @member {number} totalSpace
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.totalSpace = 0;

            /**
             * Creates a new GetFileSystemInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {kritor.group.IGetFileSystemInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetFileSystemInfoResponse} GetFileSystemInfoResponse instance
             */
            GetFileSystemInfoResponse.create = function create(properties) {
                return new GetFileSystemInfoResponse(properties);
            };

            /**
             * Encodes the specified GetFileSystemInfoResponse message. Does not implicitly {@link kritor.group.GetFileSystemInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {kritor.group.IGetFileSystemInfoResponse} message GetFileSystemInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileCount != null && Object.hasOwnProperty.call(message, "fileCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fileCount);
                if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalCount);
                if (message.usedSpace != null && Object.hasOwnProperty.call(message, "usedSpace"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.usedSpace);
                if (message.totalSpace != null && Object.hasOwnProperty.call(message, "totalSpace"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.totalSpace);
                return writer;
            };

            /**
             * Encodes the specified GetFileSystemInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetFileSystemInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {kritor.group.IGetFileSystemInfoResponse} message GetFileSystemInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileSystemInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetFileSystemInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileCount = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.totalCount = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.usedSpace = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.totalSpace = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileSystemInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileSystemInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileSystemInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileCount != null && message.hasOwnProperty("fileCount"))
                    if (!$util.isInteger(message.fileCount))
                        return "fileCount: integer expected";
                if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                    if (!$util.isInteger(message.totalCount))
                        return "totalCount: integer expected";
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    if (!$util.isInteger(message.usedSpace))
                        return "usedSpace: integer expected";
                if (message.totalSpace != null && message.hasOwnProperty("totalSpace"))
                    if (!$util.isInteger(message.totalSpace))
                        return "totalSpace: integer expected";
                return null;
            };

            /**
             * Creates a GetFileSystemInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             */
            GetFileSystemInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetFileSystemInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetFileSystemInfoResponse();
                if (object.fileCount != null)
                    message.fileCount = object.fileCount >>> 0;
                if (object.totalCount != null)
                    message.totalCount = object.totalCount >>> 0;
                if (object.usedSpace != null)
                    message.usedSpace = object.usedSpace >>> 0;
                if (object.totalSpace != null)
                    message.totalSpace = object.totalSpace >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetFileSystemInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {kritor.group.GetFileSystemInfoResponse} message GetFileSystemInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileSystemInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fileCount = 0;
                    object.totalCount = 0;
                    object.usedSpace = 0;
                    object.totalSpace = 0;
                }
                if (message.fileCount != null && message.hasOwnProperty("fileCount"))
                    object.fileCount = message.fileCount;
                if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                    object.totalCount = message.totalCount;
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    object.usedSpace = message.usedSpace;
                if (message.totalSpace != null && message.hasOwnProperty("totalSpace"))
                    object.totalSpace = message.totalSpace;
                return object;
            };

            /**
             * Converts this GetFileSystemInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileSystemInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileSystemInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetFileSystemInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileSystemInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetFileSystemInfoResponse";
            };

            return GetFileSystemInfoResponse;
        })();

        group.GetRootFilesRequest = (function() {

            /**
             * Properties of a GetRootFilesRequest.
             * @memberof kritor.group
             * @interface IGetRootFilesRequest
             * @property {number|Long|null} [groupId] GetRootFilesRequest groupId
             */

            /**
             * Constructs a new GetRootFilesRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetRootFilesRequest.
             * @implements IGetRootFilesRequest
             * @constructor
             * @param {kritor.group.IGetRootFilesRequest=} [properties] Properties to set
             */
            function GetRootFilesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRootFilesRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetRootFilesRequest
             * @instance
             */
            GetRootFilesRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetRootFilesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {kritor.group.IGetRootFilesRequest=} [properties] Properties to set
             * @returns {kritor.group.GetRootFilesRequest} GetRootFilesRequest instance
             */
            GetRootFilesRequest.create = function create(properties) {
                return new GetRootFilesRequest(properties);
            };

            /**
             * Encodes the specified GetRootFilesRequest message. Does not implicitly {@link kritor.group.GetRootFilesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {kritor.group.IGetRootFilesRequest} message GetRootFilesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRootFilesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetRootFilesRequest message, length delimited. Does not implicitly {@link kritor.group.GetRootFilesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {kritor.group.IGetRootFilesRequest} message GetRootFilesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRootFilesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRootFilesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRootFilesRequest} GetRootFilesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRootFilesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRootFilesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRootFilesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRootFilesRequest} GetRootFilesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRootFilesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRootFilesRequest message.
             * @function verify
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRootFilesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetRootFilesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRootFilesRequest} GetRootFilesRequest
             */
            GetRootFilesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRootFilesRequest)
                    return object;
                let message = new $root.kritor.group.GetRootFilesRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetRootFilesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {kritor.group.GetRootFilesRequest} message GetRootFilesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRootFilesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetRootFilesRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRootFilesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRootFilesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRootFilesRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetRootFilesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRootFilesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRootFilesRequest";
            };

            return GetRootFilesRequest;
        })();

        group.GetRootFilesResponse = (function() {

            /**
             * Properties of a GetRootFilesResponse.
             * @memberof kritor.group
             * @interface IGetRootFilesResponse
             * @property {Array.<kritor.group.IFile>|null} [files] GetRootFilesResponse files
             * @property {Array.<kritor.group.IFolder>|null} [folders] GetRootFilesResponse folders
             */

            /**
             * Constructs a new GetRootFilesResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetRootFilesResponse.
             * @implements IGetRootFilesResponse
             * @constructor
             * @param {kritor.group.IGetRootFilesResponse=} [properties] Properties to set
             */
            function GetRootFilesResponse(properties) {
                this.files = [];
                this.folders = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRootFilesResponse files.
             * @member {Array.<kritor.group.IFile>} files
             * @memberof kritor.group.GetRootFilesResponse
             * @instance
             */
            GetRootFilesResponse.prototype.files = $util.emptyArray;

            /**
             * GetRootFilesResponse folders.
             * @member {Array.<kritor.group.IFolder>} folders
             * @memberof kritor.group.GetRootFilesResponse
             * @instance
             */
            GetRootFilesResponse.prototype.folders = $util.emptyArray;

            /**
             * Creates a new GetRootFilesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {kritor.group.IGetRootFilesResponse=} [properties] Properties to set
             * @returns {kritor.group.GetRootFilesResponse} GetRootFilesResponse instance
             */
            GetRootFilesResponse.create = function create(properties) {
                return new GetRootFilesResponse(properties);
            };

            /**
             * Encodes the specified GetRootFilesResponse message. Does not implicitly {@link kritor.group.GetRootFilesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {kritor.group.IGetRootFilesResponse} message GetRootFilesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRootFilesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (let i = 0; i < message.files.length; ++i)
                        $root.kritor.group.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.folders != null && message.folders.length)
                    for (let i = 0; i < message.folders.length; ++i)
                        $root.kritor.group.Folder.encode(message.folders[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetRootFilesResponse message, length delimited. Does not implicitly {@link kritor.group.GetRootFilesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {kritor.group.IGetRootFilesResponse} message GetRootFilesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRootFilesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRootFilesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRootFilesResponse} GetRootFilesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRootFilesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRootFilesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.kritor.group.File.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.folders && message.folders.length))
                                message.folders = [];
                            message.folders.push($root.kritor.group.Folder.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRootFilesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRootFilesResponse} GetRootFilesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRootFilesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRootFilesResponse message.
             * @function verify
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRootFilesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (let i = 0; i < message.files.length; ++i) {
                        let error = $root.kritor.group.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                if (message.folders != null && message.hasOwnProperty("folders")) {
                    if (!Array.isArray(message.folders))
                        return "folders: array expected";
                    for (let i = 0; i < message.folders.length; ++i) {
                        let error = $root.kritor.group.Folder.verify(message.folders[i]);
                        if (error)
                            return "folders." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetRootFilesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRootFilesResponse} GetRootFilesResponse
             */
            GetRootFilesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRootFilesResponse)
                    return object;
                let message = new $root.kritor.group.GetRootFilesResponse();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".kritor.group.GetRootFilesResponse.files: array expected");
                    message.files = [];
                    for (let i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".kritor.group.GetRootFilesResponse.files: object expected");
                        message.files[i] = $root.kritor.group.File.fromObject(object.files[i]);
                    }
                }
                if (object.folders) {
                    if (!Array.isArray(object.folders))
                        throw TypeError(".kritor.group.GetRootFilesResponse.folders: array expected");
                    message.folders = [];
                    for (let i = 0; i < object.folders.length; ++i) {
                        if (typeof object.folders[i] !== "object")
                            throw TypeError(".kritor.group.GetRootFilesResponse.folders: object expected");
                        message.folders[i] = $root.kritor.group.Folder.fromObject(object.folders[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetRootFilesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {kritor.group.GetRootFilesResponse} message GetRootFilesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRootFilesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.files = [];
                    object.folders = [];
                }
                if (message.files && message.files.length) {
                    object.files = [];
                    for (let j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.kritor.group.File.toObject(message.files[j], options);
                }
                if (message.folders && message.folders.length) {
                    object.folders = [];
                    for (let j = 0; j < message.folders.length; ++j)
                        object.folders[j] = $root.kritor.group.Folder.toObject(message.folders[j], options);
                }
                return object;
            };

            /**
             * Converts this GetRootFilesResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRootFilesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRootFilesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRootFilesResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetRootFilesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRootFilesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRootFilesResponse";
            };

            return GetRootFilesResponse;
        })();

        group.GetFilesRequest = (function() {

            /**
             * Properties of a GetFilesRequest.
             * @memberof kritor.group
             * @interface IGetFilesRequest
             * @property {number|Long|null} [groupId] GetFilesRequest groupId
             * @property {string|null} [folderId] GetFilesRequest folderId
             */

            /**
             * Constructs a new GetFilesRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetFilesRequest.
             * @implements IGetFilesRequest
             * @constructor
             * @param {kritor.group.IGetFilesRequest=} [properties] Properties to set
             */
            function GetFilesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFilesRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetFilesRequest
             * @instance
             */
            GetFilesRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetFilesRequest folderId.
             * @member {string} folderId
             * @memberof kritor.group.GetFilesRequest
             * @instance
             */
            GetFilesRequest.prototype.folderId = "";

            /**
             * Creates a new GetFilesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {kritor.group.IGetFilesRequest=} [properties] Properties to set
             * @returns {kritor.group.GetFilesRequest} GetFilesRequest instance
             */
            GetFilesRequest.create = function create(properties) {
                return new GetFilesRequest(properties);
            };

            /**
             * Encodes the specified GetFilesRequest message. Does not implicitly {@link kritor.group.GetFilesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {kritor.group.IGetFilesRequest} message GetFilesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFilesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderId);
                return writer;
            };

            /**
             * Encodes the specified GetFilesRequest message, length delimited. Does not implicitly {@link kritor.group.GetFilesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {kritor.group.IGetFilesRequest} message GetFilesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFilesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFilesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetFilesRequest} GetFilesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFilesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetFilesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folderId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFilesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetFilesRequest} GetFilesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFilesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFilesRequest message.
             * @function verify
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFilesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                return null;
            };

            /**
             * Creates a GetFilesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetFilesRequest} GetFilesRequest
             */
            GetFilesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetFilesRequest)
                    return object;
                let message = new $root.kritor.group.GetFilesRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                return message;
            };

            /**
             * Creates a plain object from a GetFilesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {kritor.group.GetFilesRequest} message GetFilesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFilesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.folderId = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                return object;
            };

            /**
             * Converts this GetFilesRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetFilesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFilesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFilesRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetFilesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFilesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetFilesRequest";
            };

            return GetFilesRequest;
        })();

        group.GetFilesResponse = (function() {

            /**
             * Properties of a GetFilesResponse.
             * @memberof kritor.group
             * @interface IGetFilesResponse
             * @property {Array.<kritor.group.IFile>|null} [files] GetFilesResponse files
             * @property {Array.<kritor.group.IFolder>|null} [folders] GetFilesResponse folders
             */

            /**
             * Constructs a new GetFilesResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetFilesResponse.
             * @implements IGetFilesResponse
             * @constructor
             * @param {kritor.group.IGetFilesResponse=} [properties] Properties to set
             */
            function GetFilesResponse(properties) {
                this.files = [];
                this.folders = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFilesResponse files.
             * @member {Array.<kritor.group.IFile>} files
             * @memberof kritor.group.GetFilesResponse
             * @instance
             */
            GetFilesResponse.prototype.files = $util.emptyArray;

            /**
             * GetFilesResponse folders.
             * @member {Array.<kritor.group.IFolder>} folders
             * @memberof kritor.group.GetFilesResponse
             * @instance
             */
            GetFilesResponse.prototype.folders = $util.emptyArray;

            /**
             * Creates a new GetFilesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {kritor.group.IGetFilesResponse=} [properties] Properties to set
             * @returns {kritor.group.GetFilesResponse} GetFilesResponse instance
             */
            GetFilesResponse.create = function create(properties) {
                return new GetFilesResponse(properties);
            };

            /**
             * Encodes the specified GetFilesResponse message. Does not implicitly {@link kritor.group.GetFilesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {kritor.group.IGetFilesResponse} message GetFilesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFilesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (let i = 0; i < message.files.length; ++i)
                        $root.kritor.group.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.folders != null && message.folders.length)
                    for (let i = 0; i < message.folders.length; ++i)
                        $root.kritor.group.Folder.encode(message.folders[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFilesResponse message, length delimited. Does not implicitly {@link kritor.group.GetFilesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {kritor.group.IGetFilesResponse} message GetFilesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFilesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFilesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetFilesResponse} GetFilesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFilesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetFilesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.kritor.group.File.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.folders && message.folders.length))
                                message.folders = [];
                            message.folders.push($root.kritor.group.Folder.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFilesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetFilesResponse} GetFilesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFilesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFilesResponse message.
             * @function verify
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFilesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (let i = 0; i < message.files.length; ++i) {
                        let error = $root.kritor.group.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                if (message.folders != null && message.hasOwnProperty("folders")) {
                    if (!Array.isArray(message.folders))
                        return "folders: array expected";
                    for (let i = 0; i < message.folders.length; ++i) {
                        let error = $root.kritor.group.Folder.verify(message.folders[i]);
                        if (error)
                            return "folders." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFilesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetFilesResponse} GetFilesResponse
             */
            GetFilesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetFilesResponse)
                    return object;
                let message = new $root.kritor.group.GetFilesResponse();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".kritor.group.GetFilesResponse.files: array expected");
                    message.files = [];
                    for (let i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".kritor.group.GetFilesResponse.files: object expected");
                        message.files[i] = $root.kritor.group.File.fromObject(object.files[i]);
                    }
                }
                if (object.folders) {
                    if (!Array.isArray(object.folders))
                        throw TypeError(".kritor.group.GetFilesResponse.folders: array expected");
                    message.folders = [];
                    for (let i = 0; i < object.folders.length; ++i) {
                        if (typeof object.folders[i] !== "object")
                            throw TypeError(".kritor.group.GetFilesResponse.folders: object expected");
                        message.folders[i] = $root.kritor.group.Folder.fromObject(object.folders[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFilesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {kritor.group.GetFilesResponse} message GetFilesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFilesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.files = [];
                    object.folders = [];
                }
                if (message.files && message.files.length) {
                    object.files = [];
                    for (let j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.kritor.group.File.toObject(message.files[j], options);
                }
                if (message.folders && message.folders.length) {
                    object.folders = [];
                    for (let j = 0; j < message.folders.length; ++j)
                        object.folders[j] = $root.kritor.group.Folder.toObject(message.folders[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFilesResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetFilesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFilesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFilesResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetFilesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFilesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetFilesResponse";
            };

            return GetFilesResponse;
        })();

        group.GroupInfo = (function() {

            /**
             * Properties of a GroupInfo.
             * @memberof kritor.group
             * @interface IGroupInfo
             * @property {number|Long|null} [groupId] GroupInfo groupId
             * @property {string|null} [groupName] GroupInfo groupName
             * @property {string|null} [groupRemark] GroupInfo groupRemark
             * @property {number|Long|null} [owner] GroupInfo owner
             * @property {Array.<number|Long>|null} [admins] GroupInfo admins
             * @property {number|null} [maxMemberCount] GroupInfo maxMemberCount
             * @property {number|null} [memberCount] GroupInfo memberCount
             * @property {number|Long|null} [groupUin] GroupInfo groupUin
             */

            /**
             * Constructs a new GroupInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupInfo.
             * @implements IGroupInfo
             * @constructor
             * @param {kritor.group.IGroupInfo=} [properties] Properties to set
             */
            function GroupInfo(properties) {
                this.admins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupInfo groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupInfo groupName.
             * @member {string} groupName
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupName = "";

            /**
             * GroupInfo groupRemark.
             * @member {string} groupRemark
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupRemark = "";

            /**
             * GroupInfo owner.
             * @member {number|Long} owner
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupInfo admins.
             * @member {Array.<number|Long>} admins
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.admins = $util.emptyArray;

            /**
             * GroupInfo maxMemberCount.
             * @member {number} maxMemberCount
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.maxMemberCount = 0;

            /**
             * GroupInfo memberCount.
             * @member {number} memberCount
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.memberCount = 0;

            /**
             * GroupInfo groupUin.
             * @member {number|Long} groupUin
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupInfo} GroupInfo instance
             */
            GroupInfo.create = function create(properties) {
                return new GroupInfo(properties);
            };

            /**
             * Encodes the specified GroupInfo message. Does not implicitly {@link kritor.group.GroupInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
                if (message.groupRemark != null && Object.hasOwnProperty.call(message, "groupRemark"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.groupRemark);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.owner);
                if (message.admins != null && message.admins.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (let i = 0; i < message.admins.length; ++i)
                        writer.uint64(message.admins[i]);
                    writer.ldelim();
                }
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.maxMemberCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.memberCount);
                if (message.groupUin != null && Object.hasOwnProperty.call(message, "groupUin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.groupUin);
                return writer;
            };

            /**
             * Encodes the specified GroupInfo message, length delimited. Does not implicitly {@link kritor.group.GroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.groupName = reader.string();
                            break;
                        }
                    case 3: {
                            message.groupRemark = reader.string();
                            break;
                        }
                    case 4: {
                            message.owner = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.admins && message.admins.length))
                                message.admins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.admins.push(reader.uint64());
                            } else
                                message.admins.push(reader.uint64());
                            break;
                        }
                    case 6: {
                            message.maxMemberCount = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.memberCount = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.groupUin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupInfo message.
             * @function verify
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                if (message.groupRemark != null && message.hasOwnProperty("groupRemark"))
                    if (!$util.isString(message.groupRemark))
                        return "groupRemark: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isInteger(message.owner) && !(message.owner && $util.isInteger(message.owner.low) && $util.isInteger(message.owner.high)))
                        return "owner: integer|Long expected";
                if (message.admins != null && message.hasOwnProperty("admins")) {
                    if (!Array.isArray(message.admins))
                        return "admins: array expected";
                    for (let i = 0; i < message.admins.length; ++i)
                        if (!$util.isInteger(message.admins[i]) && !(message.admins[i] && $util.isInteger(message.admins[i].low) && $util.isInteger(message.admins[i].high)))
                            return "admins: integer|Long[] expected";
                }
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount))
                        return "maxMemberCount: integer expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount))
                        return "memberCount: integer expected";
                if (message.groupUin != null && message.hasOwnProperty("groupUin"))
                    if (!$util.isInteger(message.groupUin) && !(message.groupUin && $util.isInteger(message.groupUin.low) && $util.isInteger(message.groupUin.high)))
                        return "groupUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupInfo} GroupInfo
             */
            GroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupInfo)
                    return object;
                let message = new $root.kritor.group.GroupInfo();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                if (object.groupRemark != null)
                    message.groupRemark = String(object.groupRemark);
                if (object.owner != null)
                    if ($util.Long)
                        (message.owner = $util.Long.fromValue(object.owner)).unsigned = true;
                    else if (typeof object.owner === "string")
                        message.owner = parseInt(object.owner, 10);
                    else if (typeof object.owner === "number")
                        message.owner = object.owner;
                    else if (typeof object.owner === "object")
                        message.owner = new $util.LongBits(object.owner.low >>> 0, object.owner.high >>> 0).toNumber(true);
                if (object.admins) {
                    if (!Array.isArray(object.admins))
                        throw TypeError(".kritor.group.GroupInfo.admins: array expected");
                    message.admins = [];
                    for (let i = 0; i < object.admins.length; ++i)
                        if ($util.Long)
                            (message.admins[i] = $util.Long.fromValue(object.admins[i])).unsigned = true;
                        else if (typeof object.admins[i] === "string")
                            message.admins[i] = parseInt(object.admins[i], 10);
                        else if (typeof object.admins[i] === "number")
                            message.admins[i] = object.admins[i];
                        else if (typeof object.admins[i] === "object")
                            message.admins[i] = new $util.LongBits(object.admins[i].low >>> 0, object.admins[i].high >>> 0).toNumber(true);
                }
                if (object.maxMemberCount != null)
                    message.maxMemberCount = object.maxMemberCount >>> 0;
                if (object.memberCount != null)
                    message.memberCount = object.memberCount >>> 0;
                if (object.groupUin != null)
                    if ($util.Long)
                        (message.groupUin = $util.Long.fromValue(object.groupUin)).unsigned = true;
                    else if (typeof object.groupUin === "string")
                        message.groupUin = parseInt(object.groupUin, 10);
                    else if (typeof object.groupUin === "number")
                        message.groupUin = object.groupUin;
                    else if (typeof object.groupUin === "object")
                        message.groupUin = new $util.LongBits(object.groupUin.low >>> 0, object.groupUin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.GroupInfo} message GroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.admins = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.groupName = "";
                    object.groupRemark = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner = options.longs === String ? "0" : 0;
                    object.maxMemberCount = 0;
                    object.memberCount = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupUin = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                if (message.groupRemark != null && message.hasOwnProperty("groupRemark"))
                    object.groupRemark = message.groupRemark;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner === "number")
                        object.owner = options.longs === String ? String(message.owner) : message.owner;
                    else
                        object.owner = options.longs === String ? $util.Long.prototype.toString.call(message.owner) : options.longs === Number ? new $util.LongBits(message.owner.low >>> 0, message.owner.high >>> 0).toNumber(true) : message.owner;
                if (message.admins && message.admins.length) {
                    object.admins = [];
                    for (let j = 0; j < message.admins.length; ++j)
                        if (typeof message.admins[j] === "number")
                            object.admins[j] = options.longs === String ? String(message.admins[j]) : message.admins[j];
                        else
                            object.admins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.admins[j]) : options.longs === Number ? new $util.LongBits(message.admins[j].low >>> 0, message.admins[j].high >>> 0).toNumber(true) : message.admins[j];
                }
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    object.maxMemberCount = message.maxMemberCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    object.memberCount = message.memberCount;
                if (message.groupUin != null && message.hasOwnProperty("groupUin"))
                    if (typeof message.groupUin === "number")
                        object.groupUin = options.longs === String ? String(message.groupUin) : message.groupUin;
                    else
                        object.groupUin = options.longs === String ? $util.Long.prototype.toString.call(message.groupUin) : options.longs === Number ? new $util.LongBits(message.groupUin.low >>> 0, message.groupUin.high >>> 0).toNumber(true) : message.groupUin;
                return object;
            };

            /**
             * Converts this GroupInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupInfo";
            };

            return GroupInfo;
        })();

        group.NotJoinedGroupInfo = (function() {

            /**
             * Properties of a NotJoinedGroupInfo.
             * @memberof kritor.group
             * @interface INotJoinedGroupInfo
             * @property {number|Long|null} [groupId] NotJoinedGroupInfo groupId
             * @property {number|null} [maxMemberCount] NotJoinedGroupInfo maxMemberCount
             * @property {number|null} [memberCount] NotJoinedGroupInfo memberCount
             * @property {string|null} [groupName] NotJoinedGroupInfo groupName
             * @property {string|null} [groupDesc] NotJoinedGroupInfo groupDesc
             * @property {number|Long|null} [owner] NotJoinedGroupInfo owner
             * @property {number|null} [createTime] NotJoinedGroupInfo createTime
             * @property {number|null} [groupFlag] NotJoinedGroupInfo groupFlag
             * @property {number|null} [groupFlagExt] NotJoinedGroupInfo groupFlagExt
             */

            /**
             * Constructs a new NotJoinedGroupInfo.
             * @memberof kritor.group
             * @classdesc Represents a NotJoinedGroupInfo.
             * @implements INotJoinedGroupInfo
             * @constructor
             * @param {kritor.group.INotJoinedGroupInfo=} [properties] Properties to set
             */
            function NotJoinedGroupInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotJoinedGroupInfo groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * NotJoinedGroupInfo maxMemberCount.
             * @member {number} maxMemberCount
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.maxMemberCount = 0;

            /**
             * NotJoinedGroupInfo memberCount.
             * @member {number} memberCount
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.memberCount = 0;

            /**
             * NotJoinedGroupInfo groupName.
             * @member {string} groupName
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupName = "";

            /**
             * NotJoinedGroupInfo groupDesc.
             * @member {string} groupDesc
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupDesc = "";

            /**
             * NotJoinedGroupInfo owner.
             * @member {number|Long} owner
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * NotJoinedGroupInfo createTime.
             * @member {number} createTime
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.createTime = 0;

            /**
             * NotJoinedGroupInfo groupFlag.
             * @member {number} groupFlag
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupFlag = 0;

            /**
             * NotJoinedGroupInfo groupFlagExt.
             * @member {number} groupFlagExt
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupFlagExt = 0;

            /**
             * Creates a new NotJoinedGroupInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo=} [properties] Properties to set
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo instance
             */
            NotJoinedGroupInfo.create = function create(properties) {
                return new NotJoinedGroupInfo(properties);
            };

            /**
             * Encodes the specified NotJoinedGroupInfo message. Does not implicitly {@link kritor.group.NotJoinedGroupInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo} message NotJoinedGroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotJoinedGroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.maxMemberCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.memberCount);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.groupName);
                if (message.groupDesc != null && Object.hasOwnProperty.call(message, "groupDesc"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.groupDesc);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.owner);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.createTime);
                if (message.groupFlag != null && Object.hasOwnProperty.call(message, "groupFlag"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.groupFlag);
                if (message.groupFlagExt != null && Object.hasOwnProperty.call(message, "groupFlagExt"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.groupFlagExt);
                return writer;
            };

            /**
             * Encodes the specified NotJoinedGroupInfo message, length delimited. Does not implicitly {@link kritor.group.NotJoinedGroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo} message NotJoinedGroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotJoinedGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotJoinedGroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotJoinedGroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.NotJoinedGroupInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.maxMemberCount = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.memberCount = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.groupName = reader.string();
                            break;
                        }
                    case 5: {
                            message.groupDesc = reader.string();
                            break;
                        }
                    case 6: {
                            message.owner = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.createTime = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.groupFlag = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.groupFlagExt = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotJoinedGroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotJoinedGroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotJoinedGroupInfo message.
             * @function verify
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotJoinedGroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount))
                        return "maxMemberCount: integer expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount))
                        return "memberCount: integer expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                if (message.groupDesc != null && message.hasOwnProperty("groupDesc"))
                    if (!$util.isString(message.groupDesc))
                        return "groupDesc: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isInteger(message.owner) && !(message.owner && $util.isInteger(message.owner.low) && $util.isInteger(message.owner.high)))
                        return "owner: integer|Long expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime))
                        return "createTime: integer expected";
                if (message.groupFlag != null && message.hasOwnProperty("groupFlag"))
                    if (!$util.isInteger(message.groupFlag))
                        return "groupFlag: integer expected";
                if (message.groupFlagExt != null && message.hasOwnProperty("groupFlagExt"))
                    if (!$util.isInteger(message.groupFlagExt))
                        return "groupFlagExt: integer expected";
                return null;
            };

            /**
             * Creates a NotJoinedGroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             */
            NotJoinedGroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.NotJoinedGroupInfo)
                    return object;
                let message = new $root.kritor.group.NotJoinedGroupInfo();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.maxMemberCount != null)
                    message.maxMemberCount = object.maxMemberCount >>> 0;
                if (object.memberCount != null)
                    message.memberCount = object.memberCount >>> 0;
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                if (object.groupDesc != null)
                    message.groupDesc = String(object.groupDesc);
                if (object.owner != null)
                    if ($util.Long)
                        (message.owner = $util.Long.fromValue(object.owner)).unsigned = true;
                    else if (typeof object.owner === "string")
                        message.owner = parseInt(object.owner, 10);
                    else if (typeof object.owner === "number")
                        message.owner = object.owner;
                    else if (typeof object.owner === "object")
                        message.owner = new $util.LongBits(object.owner.low >>> 0, object.owner.high >>> 0).toNumber(true);
                if (object.createTime != null)
                    message.createTime = object.createTime >>> 0;
                if (object.groupFlag != null)
                    message.groupFlag = object.groupFlag >>> 0;
                if (object.groupFlagExt != null)
                    message.groupFlagExt = object.groupFlagExt >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a NotJoinedGroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.NotJoinedGroupInfo} message NotJoinedGroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotJoinedGroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.maxMemberCount = 0;
                    object.memberCount = 0;
                    object.groupName = "";
                    object.groupDesc = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner = options.longs === String ? "0" : 0;
                    object.createTime = 0;
                    object.groupFlag = 0;
                    object.groupFlagExt = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    object.maxMemberCount = message.maxMemberCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    object.memberCount = message.memberCount;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                if (message.groupDesc != null && message.hasOwnProperty("groupDesc"))
                    object.groupDesc = message.groupDesc;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner === "number")
                        object.owner = options.longs === String ? String(message.owner) : message.owner;
                    else
                        object.owner = options.longs === String ? $util.Long.prototype.toString.call(message.owner) : options.longs === Number ? new $util.LongBits(message.owner.low >>> 0, message.owner.high >>> 0).toNumber(true) : message.owner;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    object.createTime = message.createTime;
                if (message.groupFlag != null && message.hasOwnProperty("groupFlag"))
                    object.groupFlag = message.groupFlag;
                if (message.groupFlagExt != null && message.hasOwnProperty("groupFlagExt"))
                    object.groupFlagExt = message.groupFlagExt;
                return object;
            };

            /**
             * Converts this NotJoinedGroupInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotJoinedGroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NotJoinedGroupInfo
             * @function getTypeUrl
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NotJoinedGroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.NotJoinedGroupInfo";
            };

            return NotJoinedGroupInfo;
        })();

        group.ProhibitedUserInfo = (function() {

            /**
             * Properties of a ProhibitedUserInfo.
             * @memberof kritor.group
             * @interface IProhibitedUserInfo
             * @property {string|null} [uid] ProhibitedUserInfo uid
             * @property {number|Long|null} [uin] ProhibitedUserInfo uin
             * @property {number|null} [prohibitedTime] ProhibitedUserInfo prohibitedTime
             */

            /**
             * Constructs a new ProhibitedUserInfo.
             * @memberof kritor.group
             * @classdesc Represents a ProhibitedUserInfo.
             * @implements IProhibitedUserInfo
             * @constructor
             * @param {kritor.group.IProhibitedUserInfo=} [properties] Properties to set
             */
            function ProhibitedUserInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProhibitedUserInfo uid.
             * @member {string} uid
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.uid = "";

            /**
             * ProhibitedUserInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProhibitedUserInfo prohibitedTime.
             * @member {number} prohibitedTime
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.prohibitedTime = 0;

            /**
             * Creates a new ProhibitedUserInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo=} [properties] Properties to set
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo instance
             */
            ProhibitedUserInfo.create = function create(properties) {
                return new ProhibitedUserInfo(properties);
            };

            /**
             * Encodes the specified ProhibitedUserInfo message. Does not implicitly {@link kritor.group.ProhibitedUserInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo} message ProhibitedUserInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProhibitedUserInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.prohibitedTime != null && Object.hasOwnProperty.call(message, "prohibitedTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.prohibitedTime);
                return writer;
            };

            /**
             * Encodes the specified ProhibitedUserInfo message, length delimited. Does not implicitly {@link kritor.group.ProhibitedUserInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo} message ProhibitedUserInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProhibitedUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProhibitedUserInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProhibitedUserInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ProhibitedUserInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.prohibitedTime = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProhibitedUserInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProhibitedUserInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProhibitedUserInfo message.
             * @function verify
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProhibitedUserInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.prohibitedTime != null && message.hasOwnProperty("prohibitedTime"))
                    if (!$util.isInteger(message.prohibitedTime))
                        return "prohibitedTime: integer expected";
                return null;
            };

            /**
             * Creates a ProhibitedUserInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             */
            ProhibitedUserInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ProhibitedUserInfo)
                    return object;
                let message = new $root.kritor.group.ProhibitedUserInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.prohibitedTime != null)
                    message.prohibitedTime = object.prohibitedTime >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ProhibitedUserInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.ProhibitedUserInfo} message ProhibitedUserInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProhibitedUserInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.prohibitedTime = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.prohibitedTime != null && message.hasOwnProperty("prohibitedTime"))
                    object.prohibitedTime = message.prohibitedTime;
                return object;
            };

            /**
             * Converts this ProhibitedUserInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProhibitedUserInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProhibitedUserInfo
             * @function getTypeUrl
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProhibitedUserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ProhibitedUserInfo";
            };

            return ProhibitedUserInfo;
        })();

        group.GroupHonorInfo = (function() {

            /**
             * Properties of a GroupHonorInfo.
             * @memberof kritor.group
             * @interface IGroupHonorInfo
             * @property {string|null} [uid] GroupHonorInfo uid
             * @property {number|Long|null} [uin] GroupHonorInfo uin
             * @property {string|null} [nick] GroupHonorInfo nick
             * @property {string|null} [honorName] GroupHonorInfo honorName
             * @property {string|null} [avatar] GroupHonorInfo avatar
             * @property {number|null} [id] GroupHonorInfo id
             * @property {string|null} [description] GroupHonorInfo description
             */

            /**
             * Constructs a new GroupHonorInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupHonorInfo.
             * @implements IGroupHonorInfo
             * @constructor
             * @param {kritor.group.IGroupHonorInfo=} [properties] Properties to set
             */
            function GroupHonorInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupHonorInfo uid.
             * @member {string} uid
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.uid = "";

            /**
             * GroupHonorInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupHonorInfo nick.
             * @member {string} nick
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.nick = "";

            /**
             * GroupHonorInfo honorName.
             * @member {string} honorName
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.honorName = "";

            /**
             * GroupHonorInfo avatar.
             * @member {string} avatar
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.avatar = "";

            /**
             * GroupHonorInfo id.
             * @member {number} id
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.id = 0;

            /**
             * GroupHonorInfo description.
             * @member {string} description
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.description = "";

            /**
             * Creates a new GroupHonorInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo instance
             */
            GroupHonorInfo.create = function create(properties) {
                return new GroupHonorInfo(properties);
            };

            /**
             * Encodes the specified GroupHonorInfo message. Does not implicitly {@link kritor.group.GroupHonorInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo} message GroupHonorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupHonorInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                if (message.honorName != null && Object.hasOwnProperty.call(message, "honorName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.honorName);
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatar);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.id);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified GroupHonorInfo message, length delimited. Does not implicitly {@link kritor.group.GroupHonorInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo} message GroupHonorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupHonorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupHonorInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupHonorInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupHonorInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    case 4: {
                            message.honorName = reader.string();
                            break;
                        }
                    case 5: {
                            message.avatar = reader.string();
                            break;
                        }
                    case 6: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupHonorInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupHonorInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupHonorInfo message.
             * @function verify
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupHonorInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.honorName != null && message.hasOwnProperty("honorName"))
                    if (!$util.isString(message.honorName))
                        return "honorName: string expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a GroupHonorInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             */
            GroupHonorInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupHonorInfo)
                    return object;
                let message = new $root.kritor.group.GroupHonorInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.honorName != null)
                    message.honorName = String(object.honorName);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a GroupHonorInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.GroupHonorInfo} message GroupHonorInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupHonorInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.nick = "";
                    object.honorName = "";
                    object.avatar = "";
                    object.id = 0;
                    object.description = "";
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.honorName != null && message.hasOwnProperty("honorName"))
                    object.honorName = message.honorName;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this GroupHonorInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupHonorInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupHonorInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupHonorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupHonorInfo";
            };

            return GroupHonorInfo;
        })();

        /**
         * MemberRole enum.
         * @name kritor.group.MemberRole
         * @enum {number}
         * @property {number} ADMIN=0 ADMIN value
         * @property {number} MEMBER=1 MEMBER value
         * @property {number} OWNER=2 OWNER value
         * @property {number} STRANGER=3 STRANGER value
         */
        group.MemberRole = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADMIN"] = 0;
            values[valuesById[1] = "MEMBER"] = 1;
            values[valuesById[2] = "OWNER"] = 2;
            values[valuesById[3] = "STRANGER"] = 3;
            return values;
        })();

        group.GroupMemberInfo = (function() {

            /**
             * Properties of a GroupMemberInfo.
             * @memberof kritor.group
             * @interface IGroupMemberInfo
             * @property {string|null} [uid] GroupMemberInfo uid
             * @property {number|Long|null} [uin] GroupMemberInfo uin
             * @property {string|null} [nick] GroupMemberInfo nick
             * @property {number|null} [age] GroupMemberInfo age
             * @property {string|null} [uniqueTitle] GroupMemberInfo uniqueTitle
             * @property {number|null} [uniqueTitleExpireTime] GroupMemberInfo uniqueTitleExpireTime
             * @property {string|null} [card] GroupMemberInfo card
             * @property {number|Long|null} [joinTime] GroupMemberInfo joinTime
             * @property {number|Long|null} [lastActiveTime] GroupMemberInfo lastActiveTime
             * @property {number|null} [level] GroupMemberInfo level
             * @property {number|Long|null} [shutUpTimestamp] GroupMemberInfo shutUpTimestamp
             * @property {number|null} [distance] GroupMemberInfo distance
             * @property {Array.<number>|null} [honor] GroupMemberInfo honor
             * @property {boolean|null} [unfriendly] GroupMemberInfo unfriendly
             * @property {boolean|null} [cardChangeable] GroupMemberInfo cardChangeable
             */

            /**
             * Constructs a new GroupMemberInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupMemberInfo.
             * @implements IGroupMemberInfo
             * @constructor
             * @param {kritor.group.IGroupMemberInfo=} [properties] Properties to set
             */
            function GroupMemberInfo(properties) {
                this.honor = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberInfo uid.
             * @member {string} uid
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uid = "";

            /**
             * GroupMemberInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo nick.
             * @member {string} nick
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.nick = "";

            /**
             * GroupMemberInfo age.
             * @member {number} age
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.age = 0;

            /**
             * GroupMemberInfo uniqueTitle.
             * @member {string} uniqueTitle
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uniqueTitle = "";

            /**
             * GroupMemberInfo uniqueTitleExpireTime.
             * @member {number} uniqueTitleExpireTime
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uniqueTitleExpireTime = 0;

            /**
             * GroupMemberInfo card.
             * @member {string} card
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.card = "";

            /**
             * GroupMemberInfo joinTime.
             * @member {number|Long} joinTime
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo lastActiveTime.
             * @member {number|Long} lastActiveTime
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.lastActiveTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo level.
             * @member {number} level
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.level = 0;

            /**
             * GroupMemberInfo shutUpTimestamp.
             * @member {number|Long} shutUpTimestamp
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.shutUpTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo distance.
             * @member {number|null|undefined} distance
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.distance = null;

            /**
             * GroupMemberInfo honor.
             * @member {Array.<number>} honor
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.honor = $util.emptyArray;

            /**
             * GroupMemberInfo unfriendly.
             * @member {boolean|null|undefined} unfriendly
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.unfriendly = null;

            /**
             * GroupMemberInfo cardChangeable.
             * @member {boolean|null|undefined} cardChangeable
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.cardChangeable = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GroupMemberInfo _distance.
             * @member {"distance"|undefined} _distance
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_distance", {
                get: $util.oneOfGetter($oneOfFields = ["distance"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberInfo _unfriendly.
             * @member {"unfriendly"|undefined} _unfriendly
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_unfriendly", {
                get: $util.oneOfGetter($oneOfFields = ["unfriendly"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberInfo _cardChangeable.
             * @member {"cardChangeable"|undefined} _cardChangeable
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_cardChangeable", {
                get: $util.oneOfGetter($oneOfFields = ["cardChangeable"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GroupMemberInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo instance
             */
            GroupMemberInfo.create = function create(properties) {
                return new GroupMemberInfo(properties);
            };

            /**
             * Encodes the specified GroupMemberInfo message. Does not implicitly {@link kritor.group.GroupMemberInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo} message GroupMemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.age);
                if (message.uniqueTitle != null && Object.hasOwnProperty.call(message, "uniqueTitle"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.uniqueTitle);
                if (message.uniqueTitleExpireTime != null && Object.hasOwnProperty.call(message, "uniqueTitleExpireTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uniqueTitleExpireTime);
                if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.card);
                if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.joinTime);
                if (message.lastActiveTime != null && Object.hasOwnProperty.call(message, "lastActiveTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.lastActiveTime);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.level);
                if (message.shutUpTimestamp != null && Object.hasOwnProperty.call(message, "shutUpTimestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.shutUpTimestamp);
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.distance);
                if (message.honor != null && message.honor.length) {
                    writer.uint32(/* id 101, wireType 2 =*/810).fork();
                    for (let i = 0; i < message.honor.length; ++i)
                        writer.uint32(message.honor[i]);
                    writer.ldelim();
                }
                if (message.unfriendly != null && Object.hasOwnProperty.call(message, "unfriendly"))
                    writer.uint32(/* id 102, wireType 0 =*/816).bool(message.unfriendly);
                if (message.cardChangeable != null && Object.hasOwnProperty.call(message, "cardChangeable"))
                    writer.uint32(/* id 103, wireType 0 =*/824).bool(message.cardChangeable);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberInfo message, length delimited. Does not implicitly {@link kritor.group.GroupMemberInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo} message GroupMemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupMemberInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    case 4: {
                            message.age = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.uniqueTitle = reader.string();
                            break;
                        }
                    case 6: {
                            message.uniqueTitleExpireTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.card = reader.string();
                            break;
                        }
                    case 8: {
                            message.joinTime = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.lastActiveTime = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.shutUpTimestamp = reader.uint64();
                            break;
                        }
                    case 100: {
                            message.distance = reader.uint32();
                            break;
                        }
                    case 101: {
                            if (!(message.honor && message.honor.length))
                                message.honor = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.honor.push(reader.uint32());
                            } else
                                message.honor.push(reader.uint32());
                            break;
                        }
                    case 102: {
                            message.unfriendly = reader.bool();
                            break;
                        }
                    case 103: {
                            message.cardChangeable = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberInfo message.
             * @function verify
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.age != null && message.hasOwnProperty("age"))
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    if (!$util.isString(message.uniqueTitle))
                        return "uniqueTitle: string expected";
                if (message.uniqueTitleExpireTime != null && message.hasOwnProperty("uniqueTitleExpireTime"))
                    if (!$util.isInteger(message.uniqueTitleExpireTime))
                        return "uniqueTitleExpireTime: integer expected";
                if (message.card != null && message.hasOwnProperty("card"))
                    if (!$util.isString(message.card))
                        return "card: string expected";
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                        return "joinTime: integer|Long expected";
                if (message.lastActiveTime != null && message.hasOwnProperty("lastActiveTime"))
                    if (!$util.isInteger(message.lastActiveTime) && !(message.lastActiveTime && $util.isInteger(message.lastActiveTime.low) && $util.isInteger(message.lastActiveTime.high)))
                        return "lastActiveTime: integer|Long expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.shutUpTimestamp != null && message.hasOwnProperty("shutUpTimestamp"))
                    if (!$util.isInteger(message.shutUpTimestamp) && !(message.shutUpTimestamp && $util.isInteger(message.shutUpTimestamp.low) && $util.isInteger(message.shutUpTimestamp.high)))
                        return "shutUpTimestamp: integer|Long expected";
                if (message.distance != null && message.hasOwnProperty("distance")) {
                    properties._distance = 1;
                    if (!$util.isInteger(message.distance))
                        return "distance: integer expected";
                }
                if (message.honor != null && message.hasOwnProperty("honor")) {
                    if (!Array.isArray(message.honor))
                        return "honor: array expected";
                    for (let i = 0; i < message.honor.length; ++i)
                        if (!$util.isInteger(message.honor[i]))
                            return "honor: integer[] expected";
                }
                if (message.unfriendly != null && message.hasOwnProperty("unfriendly")) {
                    properties._unfriendly = 1;
                    if (typeof message.unfriendly !== "boolean")
                        return "unfriendly: boolean expected";
                }
                if (message.cardChangeable != null && message.hasOwnProperty("cardChangeable")) {
                    properties._cardChangeable = 1;
                    if (typeof message.cardChangeable !== "boolean")
                        return "cardChangeable: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GroupMemberInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             */
            GroupMemberInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupMemberInfo)
                    return object;
                let message = new $root.kritor.group.GroupMemberInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.age != null)
                    message.age = object.age >>> 0;
                if (object.uniqueTitle != null)
                    message.uniqueTitle = String(object.uniqueTitle);
                if (object.uniqueTitleExpireTime != null)
                    message.uniqueTitleExpireTime = object.uniqueTitleExpireTime >>> 0;
                if (object.card != null)
                    message.card = String(object.card);
                if (object.joinTime != null)
                    if ($util.Long)
                        (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = true;
                    else if (typeof object.joinTime === "string")
                        message.joinTime = parseInt(object.joinTime, 10);
                    else if (typeof object.joinTime === "number")
                        message.joinTime = object.joinTime;
                    else if (typeof object.joinTime === "object")
                        message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber(true);
                if (object.lastActiveTime != null)
                    if ($util.Long)
                        (message.lastActiveTime = $util.Long.fromValue(object.lastActiveTime)).unsigned = true;
                    else if (typeof object.lastActiveTime === "string")
                        message.lastActiveTime = parseInt(object.lastActiveTime, 10);
                    else if (typeof object.lastActiveTime === "number")
                        message.lastActiveTime = object.lastActiveTime;
                    else if (typeof object.lastActiveTime === "object")
                        message.lastActiveTime = new $util.LongBits(object.lastActiveTime.low >>> 0, object.lastActiveTime.high >>> 0).toNumber(true);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.shutUpTimestamp != null)
                    if ($util.Long)
                        (message.shutUpTimestamp = $util.Long.fromValue(object.shutUpTimestamp)).unsigned = true;
                    else if (typeof object.shutUpTimestamp === "string")
                        message.shutUpTimestamp = parseInt(object.shutUpTimestamp, 10);
                    else if (typeof object.shutUpTimestamp === "number")
                        message.shutUpTimestamp = object.shutUpTimestamp;
                    else if (typeof object.shutUpTimestamp === "object")
                        message.shutUpTimestamp = new $util.LongBits(object.shutUpTimestamp.low >>> 0, object.shutUpTimestamp.high >>> 0).toNumber(true);
                if (object.distance != null)
                    message.distance = object.distance >>> 0;
                if (object.honor) {
                    if (!Array.isArray(object.honor))
                        throw TypeError(".kritor.group.GroupMemberInfo.honor: array expected");
                    message.honor = [];
                    for (let i = 0; i < object.honor.length; ++i)
                        message.honor[i] = object.honor[i] >>> 0;
                }
                if (object.unfriendly != null)
                    message.unfriendly = Boolean(object.unfriendly);
                if (object.cardChangeable != null)
                    message.cardChangeable = Boolean(object.cardChangeable);
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.GroupMemberInfo} message GroupMemberInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.honor = [];
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.nick = "";
                    object.age = 0;
                    object.uniqueTitle = "";
                    object.uniqueTitleExpireTime = 0;
                    object.card = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.joinTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.lastActiveTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastActiveTime = options.longs === String ? "0" : 0;
                    object.level = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.shutUpTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.shutUpTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.age != null && message.hasOwnProperty("age"))
                    object.age = message.age;
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    object.uniqueTitle = message.uniqueTitle;
                if (message.uniqueTitleExpireTime != null && message.hasOwnProperty("uniqueTitleExpireTime"))
                    object.uniqueTitleExpireTime = message.uniqueTitleExpireTime;
                if (message.card != null && message.hasOwnProperty("card"))
                    object.card = message.card;
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (typeof message.joinTime === "number")
                        object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                    else
                        object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber(true) : message.joinTime;
                if (message.lastActiveTime != null && message.hasOwnProperty("lastActiveTime"))
                    if (typeof message.lastActiveTime === "number")
                        object.lastActiveTime = options.longs === String ? String(message.lastActiveTime) : message.lastActiveTime;
                    else
                        object.lastActiveTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastActiveTime) : options.longs === Number ? new $util.LongBits(message.lastActiveTime.low >>> 0, message.lastActiveTime.high >>> 0).toNumber(true) : message.lastActiveTime;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.shutUpTimestamp != null && message.hasOwnProperty("shutUpTimestamp"))
                    if (typeof message.shutUpTimestamp === "number")
                        object.shutUpTimestamp = options.longs === String ? String(message.shutUpTimestamp) : message.shutUpTimestamp;
                    else
                        object.shutUpTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.shutUpTimestamp) : options.longs === Number ? new $util.LongBits(message.shutUpTimestamp.low >>> 0, message.shutUpTimestamp.high >>> 0).toNumber(true) : message.shutUpTimestamp;
                if (message.distance != null && message.hasOwnProperty("distance")) {
                    object.distance = message.distance;
                    if (options.oneofs)
                        object._distance = "distance";
                }
                if (message.honor && message.honor.length) {
                    object.honor = [];
                    for (let j = 0; j < message.honor.length; ++j)
                        object.honor[j] = message.honor[j];
                }
                if (message.unfriendly != null && message.hasOwnProperty("unfriendly")) {
                    object.unfriendly = message.unfriendly;
                    if (options.oneofs)
                        object._unfriendly = "unfriendly";
                }
                if (message.cardChangeable != null && message.hasOwnProperty("cardChangeable")) {
                    object.cardChangeable = message.cardChangeable;
                    if (options.oneofs)
                        object._cardChangeable = "cardChangeable";
                }
                return object;
            };

            /**
             * Converts this GroupMemberInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupMemberInfo";
            };

            return GroupMemberInfo;
        })();

        group.GroupService = (function() {

            /**
             * Constructs a new GroupService service.
             * @memberof kritor.group
             * @classdesc Represents a GroupService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GroupService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GroupService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroupService;

            /**
             * Creates new GroupService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.group.GroupService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GroupService} RPC service. Useful where requests and/or responses are streamed.
             */
            GroupService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.group.GroupService#banMember}.
             * @memberof kritor.group.GroupService
             * @typedef BanMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.BanMemberResponse} [response] BanMemberResponse
             */

            /**
             * Calls BanMember.
             * @function banMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IBanMemberRequest} request BanMemberRequest message or plain object
             * @param {kritor.group.GroupService.BanMemberCallback} callback Node-style callback called with the error, if any, and BanMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.banMember = function banMember(request, callback) {
                return this.rpcCall(banMember, $root.kritor.group.BanMemberRequest, $root.kritor.group.BanMemberResponse, request, callback);
            }, "name", { value: "BanMember" });

            /**
             * Calls BanMember.
             * @function banMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IBanMemberRequest} request BanMemberRequest message or plain object
             * @returns {Promise<kritor.group.BanMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#pokeMember}.
             * @memberof kritor.group.GroupService
             * @typedef PokeMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.PokeMemberResponse} [response] PokeMemberResponse
             */

            /**
             * Calls PokeMember.
             * @function pokeMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IPokeMemberRequest} request PokeMemberRequest message or plain object
             * @param {kritor.group.GroupService.PokeMemberCallback} callback Node-style callback called with the error, if any, and PokeMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.pokeMember = function pokeMember(request, callback) {
                return this.rpcCall(pokeMember, $root.kritor.group.PokeMemberRequest, $root.kritor.group.PokeMemberResponse, request, callback);
            }, "name", { value: "PokeMember" });

            /**
             * Calls PokeMember.
             * @function pokeMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IPokeMemberRequest} request PokeMemberRequest message or plain object
             * @returns {Promise<kritor.group.PokeMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#kickMember}.
             * @memberof kritor.group.GroupService
             * @typedef KickMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.KickMemberResponse} [response] KickMemberResponse
             */

            /**
             * Calls KickMember.
             * @function kickMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IKickMemberRequest} request KickMemberRequest message or plain object
             * @param {kritor.group.GroupService.KickMemberCallback} callback Node-style callback called with the error, if any, and KickMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.kickMember = function kickMember(request, callback) {
                return this.rpcCall(kickMember, $root.kritor.group.KickMemberRequest, $root.kritor.group.KickMemberResponse, request, callback);
            }, "name", { value: "KickMember" });

            /**
             * Calls KickMember.
             * @function kickMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IKickMemberRequest} request KickMemberRequest message or plain object
             * @returns {Promise<kritor.group.KickMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#leaveGroup}.
             * @memberof kritor.group.GroupService
             * @typedef LeaveGroupCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.LeaveGroupResponse} [response] LeaveGroupResponse
             */

            /**
             * Calls LeaveGroup.
             * @function leaveGroup
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ILeaveGroupRequest} request LeaveGroupRequest message or plain object
             * @param {kritor.group.GroupService.LeaveGroupCallback} callback Node-style callback called with the error, if any, and LeaveGroupResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.leaveGroup = function leaveGroup(request, callback) {
                return this.rpcCall(leaveGroup, $root.kritor.group.LeaveGroupRequest, $root.kritor.group.LeaveGroupResponse, request, callback);
            }, "name", { value: "LeaveGroup" });

            /**
             * Calls LeaveGroup.
             * @function leaveGroup
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ILeaveGroupRequest} request LeaveGroupRequest message or plain object
             * @returns {Promise<kritor.group.LeaveGroupResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyMemberCard}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyMemberCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyMemberCardResponse} [response] ModifyMemberCardResponse
             */

            /**
             * Calls ModifyMemberCard.
             * @function modifyMemberCard
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyMemberCardRequest} request ModifyMemberCardRequest message or plain object
             * @param {kritor.group.GroupService.ModifyMemberCardCallback} callback Node-style callback called with the error, if any, and ModifyMemberCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyMemberCard = function modifyMemberCard(request, callback) {
                return this.rpcCall(modifyMemberCard, $root.kritor.group.ModifyMemberCardRequest, $root.kritor.group.ModifyMemberCardResponse, request, callback);
            }, "name", { value: "ModifyMemberCard" });

            /**
             * Calls ModifyMemberCard.
             * @function modifyMemberCard
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyMemberCardRequest} request ModifyMemberCardRequest message or plain object
             * @returns {Promise<kritor.group.ModifyMemberCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyGroupName}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyGroupNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyGroupNameResponse} [response] ModifyGroupNameResponse
             */

            /**
             * Calls ModifyGroupName.
             * @function modifyGroupName
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupNameRequest} request ModifyGroupNameRequest message or plain object
             * @param {kritor.group.GroupService.ModifyGroupNameCallback} callback Node-style callback called with the error, if any, and ModifyGroupNameResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyGroupName = function modifyGroupName(request, callback) {
                return this.rpcCall(modifyGroupName, $root.kritor.group.ModifyGroupNameRequest, $root.kritor.group.ModifyGroupNameResponse, request, callback);
            }, "name", { value: "ModifyGroupName" });

            /**
             * Calls ModifyGroupName.
             * @function modifyGroupName
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupNameRequest} request ModifyGroupNameRequest message or plain object
             * @returns {Promise<kritor.group.ModifyGroupNameResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyGroupRemark}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyGroupRemarkCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyGroupRemarkResponse} [response] ModifyGroupRemarkResponse
             */

            /**
             * Calls ModifyGroupRemark.
             * @function modifyGroupRemark
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupRemarkRequest} request ModifyGroupRemarkRequest message or plain object
             * @param {kritor.group.GroupService.ModifyGroupRemarkCallback} callback Node-style callback called with the error, if any, and ModifyGroupRemarkResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyGroupRemark = function modifyGroupRemark(request, callback) {
                return this.rpcCall(modifyGroupRemark, $root.kritor.group.ModifyGroupRemarkRequest, $root.kritor.group.ModifyGroupRemarkResponse, request, callback);
            }, "name", { value: "ModifyGroupRemark" });

            /**
             * Calls ModifyGroupRemark.
             * @function modifyGroupRemark
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupRemarkRequest} request ModifyGroupRemarkRequest message or plain object
             * @returns {Promise<kritor.group.ModifyGroupRemarkResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupAdmin}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupAdminCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupAdminResponse} [response] SetGroupAdminResponse
             */

            /**
             * Calls SetGroupAdmin.
             * @function setGroupAdmin
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupAdminRequest} request SetGroupAdminRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupAdminCallback} callback Node-style callback called with the error, if any, and SetGroupAdminResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupAdmin = function setGroupAdmin(request, callback) {
                return this.rpcCall(setGroupAdmin, $root.kritor.group.SetGroupAdminRequest, $root.kritor.group.SetGroupAdminResponse, request, callback);
            }, "name", { value: "SetGroupAdmin" });

            /**
             * Calls SetGroupAdmin.
             * @function setGroupAdmin
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupAdminRequest} request SetGroupAdminRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupAdminResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupUniqueTitle}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupUniqueTitleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupUniqueTitleResponse} [response] SetGroupUniqueTitleResponse
             */

            /**
             * Calls SetGroupUniqueTitle.
             * @function setGroupUniqueTitle
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupUniqueTitleRequest} request SetGroupUniqueTitleRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupUniqueTitleCallback} callback Node-style callback called with the error, if any, and SetGroupUniqueTitleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupUniqueTitle = function setGroupUniqueTitle(request, callback) {
                return this.rpcCall(setGroupUniqueTitle, $root.kritor.group.SetGroupUniqueTitleRequest, $root.kritor.group.SetGroupUniqueTitleResponse, request, callback);
            }, "name", { value: "SetGroupUniqueTitle" });

            /**
             * Calls SetGroupUniqueTitle.
             * @function setGroupUniqueTitle
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupUniqueTitleRequest} request SetGroupUniqueTitleRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupUniqueTitleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupWholeBan}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupWholeBanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupWholeBanResponse} [response] SetGroupWholeBanResponse
             */

            /**
             * Calls SetGroupWholeBan.
             * @function setGroupWholeBan
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupWholeBanRequest} request SetGroupWholeBanRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupWholeBanCallback} callback Node-style callback called with the error, if any, and SetGroupWholeBanResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupWholeBan = function setGroupWholeBan(request, callback) {
                return this.rpcCall(setGroupWholeBan, $root.kritor.group.SetGroupWholeBanRequest, $root.kritor.group.SetGroupWholeBanResponse, request, callback);
            }, "name", { value: "SetGroupWholeBan" });

            /**
             * Calls SetGroupWholeBan.
             * @function setGroupWholeBan
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupWholeBanRequest} request SetGroupWholeBanRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupWholeBanResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupInfoResponse} [response] GetGroupInfoResponse
             */

            /**
             * Calls GetGroupInfo.
             * @function getGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupInfoRequest} request GetGroupInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupInfoCallback} callback Node-style callback called with the error, if any, and GetGroupInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupInfo = function getGroupInfo(request, callback) {
                return this.rpcCall(getGroupInfo, $root.kritor.group.GetGroupInfoRequest, $root.kritor.group.GetGroupInfoResponse, request, callback);
            }, "name", { value: "GetGroupInfo" });

            /**
             * Calls GetGroupInfo.
             * @function getGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupInfoRequest} request GetGroupInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupList}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupListResponse} [response] GetGroupListResponse
             */

            /**
             * Calls GetGroupList.
             * @function getGroupList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupListRequest} request GetGroupListRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupListCallback} callback Node-style callback called with the error, if any, and GetGroupListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupList = function getGroupList(request, callback) {
                return this.rpcCall(getGroupList, $root.kritor.group.GetGroupListRequest, $root.kritor.group.GetGroupListResponse, request, callback);
            }, "name", { value: "GetGroupList" });

            /**
             * Calls GetGroupList.
             * @function getGroupList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupListRequest} request GetGroupListRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupMemberInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupMemberInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupMemberInfoResponse} [response] GetGroupMemberInfoResponse
             */

            /**
             * Calls GetGroupMemberInfo.
             * @function getGroupMemberInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberInfoRequest} request GetGroupMemberInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupMemberInfoCallback} callback Node-style callback called with the error, if any, and GetGroupMemberInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupMemberInfo = function getGroupMemberInfo(request, callback) {
                return this.rpcCall(getGroupMemberInfo, $root.kritor.group.GetGroupMemberInfoRequest, $root.kritor.group.GetGroupMemberInfoResponse, request, callback);
            }, "name", { value: "GetGroupMemberInfo" });

            /**
             * Calls GetGroupMemberInfo.
             * @function getGroupMemberInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberInfoRequest} request GetGroupMemberInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupMemberInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupMemberList}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupMemberListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupMemberListResponse} [response] GetGroupMemberListResponse
             */

            /**
             * Calls GetGroupMemberList.
             * @function getGroupMemberList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberListRequest} request GetGroupMemberListRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupMemberListCallback} callback Node-style callback called with the error, if any, and GetGroupMemberListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupMemberList = function getGroupMemberList(request, callback) {
                return this.rpcCall(getGroupMemberList, $root.kritor.group.GetGroupMemberListRequest, $root.kritor.group.GetGroupMemberListResponse, request, callback);
            }, "name", { value: "GetGroupMemberList" });

            /**
             * Calls GetGroupMemberList.
             * @function getGroupMemberList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberListRequest} request GetGroupMemberListRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupMemberListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getProhibitedUserList}.
             * @memberof kritor.group.GroupService
             * @typedef GetProhibitedUserListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetProhibitedUserListResponse} [response] GetProhibitedUserListResponse
             */

            /**
             * Calls GetProhibitedUserList.
             * @function getProhibitedUserList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetProhibitedUserListRequest} request GetProhibitedUserListRequest message or plain object
             * @param {kritor.group.GroupService.GetProhibitedUserListCallback} callback Node-style callback called with the error, if any, and GetProhibitedUserListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getProhibitedUserList = function getProhibitedUserList(request, callback) {
                return this.rpcCall(getProhibitedUserList, $root.kritor.group.GetProhibitedUserListRequest, $root.kritor.group.GetProhibitedUserListResponse, request, callback);
            }, "name", { value: "GetProhibitedUserList" });

            /**
             * Calls GetProhibitedUserList.
             * @function getProhibitedUserList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetProhibitedUserListRequest} request GetProhibitedUserListRequest message or plain object
             * @returns {Promise<kritor.group.GetProhibitedUserListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getRemainCountAtAll}.
             * @memberof kritor.group.GroupService
             * @typedef GetRemainCountAtAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetRemainCountAtAllResponse} [response] GetRemainCountAtAllResponse
             */

            /**
             * Calls GetRemainCountAtAll.
             * @function getRemainCountAtAll
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetRemainCountAtAllRequest} request GetRemainCountAtAllRequest message or plain object
             * @param {kritor.group.GroupService.GetRemainCountAtAllCallback} callback Node-style callback called with the error, if any, and GetRemainCountAtAllResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getRemainCountAtAll = function getRemainCountAtAll(request, callback) {
                return this.rpcCall(getRemainCountAtAll, $root.kritor.group.GetRemainCountAtAllRequest, $root.kritor.group.GetRemainCountAtAllResponse, request, callback);
            }, "name", { value: "GetRemainCountAtAll" });

            /**
             * Calls GetRemainCountAtAll.
             * @function getRemainCountAtAll
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetRemainCountAtAllRequest} request GetRemainCountAtAllRequest message or plain object
             * @returns {Promise<kritor.group.GetRemainCountAtAllResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getNotJoinedGroupInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetNotJoinedGroupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetNotJoinedGroupInfoResponse} [response] GetNotJoinedGroupInfoResponse
             */

            /**
             * Calls GetNotJoinedGroupInfo.
             * @function getNotJoinedGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} request GetNotJoinedGroupInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetNotJoinedGroupInfoCallback} callback Node-style callback called with the error, if any, and GetNotJoinedGroupInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getNotJoinedGroupInfo = function getNotJoinedGroupInfo(request, callback) {
                return this.rpcCall(getNotJoinedGroupInfo, $root.kritor.group.GetNotJoinedGroupInfoRequest, $root.kritor.group.GetNotJoinedGroupInfoResponse, request, callback);
            }, "name", { value: "GetNotJoinedGroupInfo" });

            /**
             * Calls GetNotJoinedGroupInfo.
             * @function getNotJoinedGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} request GetNotJoinedGroupInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetNotJoinedGroupInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupHonor}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupHonorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupHonorResponse} [response] GetGroupHonorResponse
             */

            /**
             * Calls GetGroupHonor.
             * @function getGroupHonor
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupHonorRequest} request GetGroupHonorRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupHonorCallback} callback Node-style callback called with the error, if any, and GetGroupHonorResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupHonor = function getGroupHonor(request, callback) {
                return this.rpcCall(getGroupHonor, $root.kritor.group.GetGroupHonorRequest, $root.kritor.group.GetGroupHonorResponse, request, callback);
            }, "name", { value: "GetGroupHonor" });

            /**
             * Calls GetGroupHonor.
             * @function getGroupHonor
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupHonorRequest} request GetGroupHonorRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupHonorResponse>} Promise
             * @variation 2
             */

            return GroupService;
        })();

        group.BanMemberRequest = (function() {

            /**
             * Properties of a BanMemberRequest.
             * @memberof kritor.group
             * @interface IBanMemberRequest
             * @property {number|Long|null} [groupId] BanMemberRequest groupId
             * @property {string|null} [targetUid] BanMemberRequest targetUid
             * @property {number|Long|null} [targetUin] BanMemberRequest targetUin
             * @property {number|null} [duration] BanMemberRequest duration
             */

            /**
             * Constructs a new BanMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a BanMemberRequest.
             * @implements IBanMemberRequest
             * @constructor
             * @param {kritor.group.IBanMemberRequest=} [properties] Properties to set
             */
            function BanMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BanMemberRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * BanMemberRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.targetUid = null;

            /**
             * BanMemberRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.targetUin = null;

            /**
             * BanMemberRequest duration.
             * @member {number} duration
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.duration = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BanMemberRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            Object.defineProperty(BanMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BanMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest instance
             */
            BanMemberRequest.create = function create(properties) {
                return new BanMemberRequest(properties);
            };

            /**
             * Encodes the specified BanMemberRequest message. Does not implicitly {@link kritor.group.BanMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest} message BanMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.duration);
                return writer;
            };

            /**
             * Encodes the specified BanMemberRequest message, length delimited. Does not implicitly {@link kritor.group.BanMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest} message BanMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BanMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.BanMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.duration = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BanMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BanMemberRequest message.
             * @function verify
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BanMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (!$util.isInteger(message.duration))
                        return "duration: integer expected";
                return null;
            };

            /**
             * Creates a BanMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             */
            BanMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.BanMemberRequest)
                    return object;
                let message = new $root.kritor.group.BanMemberRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.duration != null)
                    message.duration = object.duration >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BanMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.BanMemberRequest} message BanMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BanMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.duration = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = message.duration;
                return object;
            };

            /**
             * Converts this BanMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.BanMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BanMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BanMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BanMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.BanMemberRequest";
            };

            return BanMemberRequest;
        })();

        group.BanMemberResponse = (function() {

            /**
             * Properties of a BanMemberResponse.
             * @memberof kritor.group
             * @interface IBanMemberResponse
             * @property {number|Long|null} [groupId] BanMemberResponse groupId
             */

            /**
             * Constructs a new BanMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a BanMemberResponse.
             * @implements IBanMemberResponse
             * @constructor
             * @param {kritor.group.IBanMemberResponse=} [properties] Properties to set
             */
            function BanMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BanMemberResponse groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.BanMemberResponse
             * @instance
             */
            BanMemberResponse.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new BanMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse instance
             */
            BanMemberResponse.create = function create(properties) {
                return new BanMemberResponse(properties);
            };

            /**
             * Encodes the specified BanMemberResponse message. Does not implicitly {@link kritor.group.BanMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse} message BanMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified BanMemberResponse message, length delimited. Does not implicitly {@link kritor.group.BanMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse} message BanMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BanMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.BanMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BanMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BanMemberResponse message.
             * @function verify
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BanMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a BanMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             */
            BanMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.BanMemberResponse)
                    return object;
                let message = new $root.kritor.group.BanMemberResponse();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a BanMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.BanMemberResponse} message BanMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BanMemberResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this BanMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.BanMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BanMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BanMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BanMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.BanMemberResponse";
            };

            return BanMemberResponse;
        })();

        group.PokeMemberRequest = (function() {

            /**
             * Properties of a PokeMemberRequest.
             * @memberof kritor.group
             * @interface IPokeMemberRequest
             * @property {number|Long|null} [groupId] PokeMemberRequest groupId
             * @property {string|null} [targetUid] PokeMemberRequest targetUid
             * @property {number|Long|null} [targetUin] PokeMemberRequest targetUin
             */

            /**
             * Constructs a new PokeMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a PokeMemberRequest.
             * @implements IPokeMemberRequest
             * @constructor
             * @param {kritor.group.IPokeMemberRequest=} [properties] Properties to set
             */
            function PokeMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeMemberRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PokeMemberRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.targetUid = null;

            /**
             * PokeMemberRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.targetUin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * PokeMemberRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            Object.defineProperty(PokeMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PokeMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest instance
             */
            PokeMemberRequest.create = function create(properties) {
                return new PokeMemberRequest(properties);
            };

            /**
             * Encodes the specified PokeMemberRequest message. Does not implicitly {@link kritor.group.PokeMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest} message PokeMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                return writer;
            };

            /**
             * Encodes the specified PokeMemberRequest message, length delimited. Does not implicitly {@link kritor.group.PokeMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest} message PokeMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.PokeMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeMemberRequest message.
             * @function verify
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a PokeMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             */
            PokeMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.PokeMemberRequest)
                    return object;
                let message = new $root.kritor.group.PokeMemberRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PokeMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.PokeMemberRequest} message PokeMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                return object;
            };

            /**
             * Converts this PokeMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.PokeMemberRequest";
            };

            return PokeMemberRequest;
        })();

        group.PokeMemberResponse = (function() {

            /**
             * Properties of a PokeMemberResponse.
             * @memberof kritor.group
             * @interface IPokeMemberResponse
             */

            /**
             * Constructs a new PokeMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a PokeMemberResponse.
             * @implements IPokeMemberResponse
             * @constructor
             * @param {kritor.group.IPokeMemberResponse=} [properties] Properties to set
             */
            function PokeMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PokeMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse instance
             */
            PokeMemberResponse.create = function create(properties) {
                return new PokeMemberResponse(properties);
            };

            /**
             * Encodes the specified PokeMemberResponse message. Does not implicitly {@link kritor.group.PokeMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse} message PokeMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PokeMemberResponse message, length delimited. Does not implicitly {@link kritor.group.PokeMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse} message PokeMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.PokeMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeMemberResponse message.
             * @function verify
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a PokeMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             */
            PokeMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.PokeMemberResponse)
                    return object;
                return new $root.kritor.group.PokeMemberResponse();
            };

            /**
             * Creates a plain object from a PokeMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.PokeMemberResponse} message PokeMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeMemberResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this PokeMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.PokeMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.PokeMemberResponse";
            };

            return PokeMemberResponse;
        })();

        group.KickMemberRequest = (function() {

            /**
             * Properties of a KickMemberRequest.
             * @memberof kritor.group
             * @interface IKickMemberRequest
             * @property {number|Long|null} [groupId] KickMemberRequest groupId
             * @property {string|null} [targetUid] KickMemberRequest targetUid
             * @property {number|Long|null} [targetUin] KickMemberRequest targetUin
             * @property {boolean|null} [rejectAddRequest] KickMemberRequest rejectAddRequest
             * @property {string|null} [kickReason] KickMemberRequest kickReason
             */

            /**
             * Constructs a new KickMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a KickMemberRequest.
             * @implements IKickMemberRequest
             * @constructor
             * @param {kritor.group.IKickMemberRequest=} [properties] Properties to set
             */
            function KickMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickMemberRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * KickMemberRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.targetUid = null;

            /**
             * KickMemberRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.targetUin = null;

            /**
             * KickMemberRequest rejectAddRequest.
             * @member {boolean|null|undefined} rejectAddRequest
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.rejectAddRequest = null;

            /**
             * KickMemberRequest kickReason.
             * @member {string|null|undefined} kickReason
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.kickReason = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * KickMemberRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KickMemberRequest _rejectAddRequest.
             * @member {"rejectAddRequest"|undefined} _rejectAddRequest
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "_rejectAddRequest", {
                get: $util.oneOfGetter($oneOfFields = ["rejectAddRequest"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KickMemberRequest _kickReason.
             * @member {"kickReason"|undefined} _kickReason
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "_kickReason", {
                get: $util.oneOfGetter($oneOfFields = ["kickReason"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new KickMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest instance
             */
            KickMemberRequest.create = function create(properties) {
                return new KickMemberRequest(properties);
            };

            /**
             * Encodes the specified KickMemberRequest message. Does not implicitly {@link kritor.group.KickMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest} message KickMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.kickReason != null && Object.hasOwnProperty.call(message, "kickReason"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.kickReason);
                if (message.rejectAddRequest != null && Object.hasOwnProperty.call(message, "rejectAddRequest"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.rejectAddRequest);
                return writer;
            };

            /**
             * Encodes the specified KickMemberRequest message, length delimited. Does not implicitly {@link kritor.group.KickMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest} message KickMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.KickMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.rejectAddRequest = reader.bool();
                            break;
                        }
                    case 5: {
                            message.kickReason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickMemberRequest message.
             * @function verify
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.rejectAddRequest != null && message.hasOwnProperty("rejectAddRequest")) {
                    properties._rejectAddRequest = 1;
                    if (typeof message.rejectAddRequest !== "boolean")
                        return "rejectAddRequest: boolean expected";
                }
                if (message.kickReason != null && message.hasOwnProperty("kickReason")) {
                    properties._kickReason = 1;
                    if (!$util.isString(message.kickReason))
                        return "kickReason: string expected";
                }
                return null;
            };

            /**
             * Creates a KickMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             */
            KickMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.KickMemberRequest)
                    return object;
                let message = new $root.kritor.group.KickMemberRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.rejectAddRequest != null)
                    message.rejectAddRequest = Boolean(object.rejectAddRequest);
                if (object.kickReason != null)
                    message.kickReason = String(object.kickReason);
                return message;
            };

            /**
             * Creates a plain object from a KickMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.KickMemberRequest} message KickMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.kickReason != null && message.hasOwnProperty("kickReason")) {
                    object.kickReason = message.kickReason;
                    if (options.oneofs)
                        object._kickReason = "kickReason";
                }
                if (message.rejectAddRequest != null && message.hasOwnProperty("rejectAddRequest")) {
                    object.rejectAddRequest = message.rejectAddRequest;
                    if (options.oneofs)
                        object._rejectAddRequest = "rejectAddRequest";
                }
                return object;
            };

            /**
             * Converts this KickMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.KickMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.KickMemberRequest";
            };

            return KickMemberRequest;
        })();

        group.KickMemberResponse = (function() {

            /**
             * Properties of a KickMemberResponse.
             * @memberof kritor.group
             * @interface IKickMemberResponse
             */

            /**
             * Constructs a new KickMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a KickMemberResponse.
             * @implements IKickMemberResponse
             * @constructor
             * @param {kritor.group.IKickMemberResponse=} [properties] Properties to set
             */
            function KickMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KickMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse instance
             */
            KickMemberResponse.create = function create(properties) {
                return new KickMemberResponse(properties);
            };

            /**
             * Encodes the specified KickMemberResponse message. Does not implicitly {@link kritor.group.KickMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse} message KickMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KickMemberResponse message, length delimited. Does not implicitly {@link kritor.group.KickMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse} message KickMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.KickMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickMemberResponse message.
             * @function verify
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KickMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             */
            KickMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.KickMemberResponse)
                    return object;
                return new $root.kritor.group.KickMemberResponse();
            };

            /**
             * Creates a plain object from a KickMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.KickMemberResponse} message KickMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickMemberResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this KickMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.KickMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.KickMemberResponse";
            };

            return KickMemberResponse;
        })();

        group.LeaveGroupRequest = (function() {

            /**
             * Properties of a LeaveGroupRequest.
             * @memberof kritor.group
             * @interface ILeaveGroupRequest
             * @property {number|Long|null} [groupId] LeaveGroupRequest groupId
             */

            /**
             * Constructs a new LeaveGroupRequest.
             * @memberof kritor.group
             * @classdesc Represents a LeaveGroupRequest.
             * @implements ILeaveGroupRequest
             * @constructor
             * @param {kritor.group.ILeaveGroupRequest=} [properties] Properties to set
             */
            function LeaveGroupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeaveGroupRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.LeaveGroupRequest
             * @instance
             */
            LeaveGroupRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new LeaveGroupRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest=} [properties] Properties to set
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest instance
             */
            LeaveGroupRequest.create = function create(properties) {
                return new LeaveGroupRequest(properties);
            };

            /**
             * Encodes the specified LeaveGroupRequest message. Does not implicitly {@link kritor.group.LeaveGroupRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest} message LeaveGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified LeaveGroupRequest message, length delimited. Does not implicitly {@link kritor.group.LeaveGroupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest} message LeaveGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LeaveGroupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.LeaveGroupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LeaveGroupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LeaveGroupRequest message.
             * @function verify
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeaveGroupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a LeaveGroupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             */
            LeaveGroupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.LeaveGroupRequest)
                    return object;
                let message = new $root.kritor.group.LeaveGroupRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a LeaveGroupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.LeaveGroupRequest} message LeaveGroupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeaveGroupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this LeaveGroupRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.LeaveGroupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeaveGroupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LeaveGroupRequest
             * @function getTypeUrl
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LeaveGroupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.LeaveGroupRequest";
            };

            return LeaveGroupRequest;
        })();

        group.LeaveGroupResponse = (function() {

            /**
             * Properties of a LeaveGroupResponse.
             * @memberof kritor.group
             * @interface ILeaveGroupResponse
             */

            /**
             * Constructs a new LeaveGroupResponse.
             * @memberof kritor.group
             * @classdesc Represents a LeaveGroupResponse.
             * @implements ILeaveGroupResponse
             * @constructor
             * @param {kritor.group.ILeaveGroupResponse=} [properties] Properties to set
             */
            function LeaveGroupResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LeaveGroupResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse=} [properties] Properties to set
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse instance
             */
            LeaveGroupResponse.create = function create(properties) {
                return new LeaveGroupResponse(properties);
            };

            /**
             * Encodes the specified LeaveGroupResponse message. Does not implicitly {@link kritor.group.LeaveGroupResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse} message LeaveGroupResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified LeaveGroupResponse message, length delimited. Does not implicitly {@link kritor.group.LeaveGroupResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse} message LeaveGroupResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LeaveGroupResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.LeaveGroupResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LeaveGroupResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LeaveGroupResponse message.
             * @function verify
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeaveGroupResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a LeaveGroupResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             */
            LeaveGroupResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.LeaveGroupResponse)
                    return object;
                return new $root.kritor.group.LeaveGroupResponse();
            };

            /**
             * Creates a plain object from a LeaveGroupResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.LeaveGroupResponse} message LeaveGroupResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeaveGroupResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this LeaveGroupResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.LeaveGroupResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeaveGroupResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LeaveGroupResponse
             * @function getTypeUrl
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LeaveGroupResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.LeaveGroupResponse";
            };

            return LeaveGroupResponse;
        })();

        group.ModifyMemberCardRequest = (function() {

            /**
             * Properties of a ModifyMemberCardRequest.
             * @memberof kritor.group
             * @interface IModifyMemberCardRequest
             * @property {number|Long|null} [groupId] ModifyMemberCardRequest groupId
             * @property {string|null} [targetUid] ModifyMemberCardRequest targetUid
             * @property {number|Long|null} [targetUin] ModifyMemberCardRequest targetUin
             * @property {string|null} [card] ModifyMemberCardRequest card
             */

            /**
             * Constructs a new ModifyMemberCardRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyMemberCardRequest.
             * @implements IModifyMemberCardRequest
             * @constructor
             * @param {kritor.group.IModifyMemberCardRequest=} [properties] Properties to set
             */
            function ModifyMemberCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyMemberCardRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyMemberCardRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.targetUid = null;

            /**
             * ModifyMemberCardRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.targetUin = null;

            /**
             * ModifyMemberCardRequest card.
             * @member {string} card
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.card = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ModifyMemberCardRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            Object.defineProperty(ModifyMemberCardRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ModifyMemberCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest instance
             */
            ModifyMemberCardRequest.create = function create(properties) {
                return new ModifyMemberCardRequest(properties);
            };

            /**
             * Encodes the specified ModifyMemberCardRequest message. Does not implicitly {@link kritor.group.ModifyMemberCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest} message ModifyMemberCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.card);
                return writer;
            };

            /**
             * Encodes the specified ModifyMemberCardRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyMemberCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest} message ModifyMemberCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyMemberCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyMemberCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.card = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyMemberCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyMemberCardRequest message.
             * @function verify
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyMemberCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.card != null && message.hasOwnProperty("card"))
                    if (!$util.isString(message.card))
                        return "card: string expected";
                return null;
            };

            /**
             * Creates a ModifyMemberCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             */
            ModifyMemberCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyMemberCardRequest)
                    return object;
                let message = new $root.kritor.group.ModifyMemberCardRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.card != null)
                    message.card = String(object.card);
                return message;
            };

            /**
             * Creates a plain object from a ModifyMemberCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.ModifyMemberCardRequest} message ModifyMemberCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyMemberCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.card = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.card != null && message.hasOwnProperty("card"))
                    object.card = message.card;
                return object;
            };

            /**
             * Converts this ModifyMemberCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyMemberCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyMemberCardRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyMemberCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyMemberCardRequest";
            };

            return ModifyMemberCardRequest;
        })();

        group.ModifyMemberCardResponse = (function() {

            /**
             * Properties of a ModifyMemberCardResponse.
             * @memberof kritor.group
             * @interface IModifyMemberCardResponse
             */

            /**
             * Constructs a new ModifyMemberCardResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyMemberCardResponse.
             * @implements IModifyMemberCardResponse
             * @constructor
             * @param {kritor.group.IModifyMemberCardResponse=} [properties] Properties to set
             */
            function ModifyMemberCardResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyMemberCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse instance
             */
            ModifyMemberCardResponse.create = function create(properties) {
                return new ModifyMemberCardResponse(properties);
            };

            /**
             * Encodes the specified ModifyMemberCardResponse message. Does not implicitly {@link kritor.group.ModifyMemberCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse} message ModifyMemberCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyMemberCardResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyMemberCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse} message ModifyMemberCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyMemberCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyMemberCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyMemberCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyMemberCardResponse message.
             * @function verify
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyMemberCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyMemberCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             */
            ModifyMemberCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyMemberCardResponse)
                    return object;
                return new $root.kritor.group.ModifyMemberCardResponse();
            };

            /**
             * Creates a plain object from a ModifyMemberCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.ModifyMemberCardResponse} message ModifyMemberCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyMemberCardResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyMemberCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyMemberCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyMemberCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyMemberCardResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyMemberCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyMemberCardResponse";
            };

            return ModifyMemberCardResponse;
        })();

        group.ModifyGroupNameRequest = (function() {

            /**
             * Properties of a ModifyGroupNameRequest.
             * @memberof kritor.group
             * @interface IModifyGroupNameRequest
             * @property {number|Long|null} [groupId] ModifyGroupNameRequest groupId
             * @property {string|null} [groupName] ModifyGroupNameRequest groupName
             */

            /**
             * Constructs a new ModifyGroupNameRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupNameRequest.
             * @implements IModifyGroupNameRequest
             * @constructor
             * @param {kritor.group.IModifyGroupNameRequest=} [properties] Properties to set
             */
            function ModifyGroupNameRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyGroupNameRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             */
            ModifyGroupNameRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyGroupNameRequest groupName.
             * @member {string} groupName
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             */
            ModifyGroupNameRequest.prototype.groupName = "";

            /**
             * Creates a new ModifyGroupNameRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest instance
             */
            ModifyGroupNameRequest.create = function create(properties) {
                return new ModifyGroupNameRequest(properties);
            };

            /**
             * Encodes the specified ModifyGroupNameRequest message. Does not implicitly {@link kritor.group.ModifyGroupNameRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest} message ModifyGroupNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupNameRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupNameRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest} message ModifyGroupNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupNameRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupNameRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.groupName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupNameRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupNameRequest message.
             * @function verify
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupNameRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                return null;
            };

            /**
             * Creates a ModifyGroupNameRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             */
            ModifyGroupNameRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupNameRequest)
                    return object;
                let message = new $root.kritor.group.ModifyGroupNameRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                return message;
            };

            /**
             * Creates a plain object from a ModifyGroupNameRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.ModifyGroupNameRequest} message ModifyGroupNameRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupNameRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.groupName = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                return object;
            };

            /**
             * Converts this ModifyGroupNameRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupNameRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupNameRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupNameRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupNameRequest";
            };

            return ModifyGroupNameRequest;
        })();

        group.ModifyGroupNameResponse = (function() {

            /**
             * Properties of a ModifyGroupNameResponse.
             * @memberof kritor.group
             * @interface IModifyGroupNameResponse
             */

            /**
             * Constructs a new ModifyGroupNameResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupNameResponse.
             * @implements IModifyGroupNameResponse
             * @constructor
             * @param {kritor.group.IModifyGroupNameResponse=} [properties] Properties to set
             */
            function ModifyGroupNameResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyGroupNameResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse instance
             */
            ModifyGroupNameResponse.create = function create(properties) {
                return new ModifyGroupNameResponse(properties);
            };

            /**
             * Encodes the specified ModifyGroupNameResponse message. Does not implicitly {@link kritor.group.ModifyGroupNameResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse} message ModifyGroupNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupNameResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupNameResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse} message ModifyGroupNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupNameResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupNameResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupNameResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupNameResponse message.
             * @function verify
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupNameResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyGroupNameResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             */
            ModifyGroupNameResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupNameResponse)
                    return object;
                return new $root.kritor.group.ModifyGroupNameResponse();
            };

            /**
             * Creates a plain object from a ModifyGroupNameResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.ModifyGroupNameResponse} message ModifyGroupNameResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupNameResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyGroupNameResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupNameResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupNameResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupNameResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupNameResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupNameResponse";
            };

            return ModifyGroupNameResponse;
        })();

        group.ModifyGroupRemarkRequest = (function() {

            /**
             * Properties of a ModifyGroupRemarkRequest.
             * @memberof kritor.group
             * @interface IModifyGroupRemarkRequest
             * @property {number|Long|null} [groupId] ModifyGroupRemarkRequest groupId
             * @property {string|null} [remark] ModifyGroupRemarkRequest remark
             */

            /**
             * Constructs a new ModifyGroupRemarkRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupRemarkRequest.
             * @implements IModifyGroupRemarkRequest
             * @constructor
             * @param {kritor.group.IModifyGroupRemarkRequest=} [properties] Properties to set
             */
            function ModifyGroupRemarkRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyGroupRemarkRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             */
            ModifyGroupRemarkRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyGroupRemarkRequest remark.
             * @member {string} remark
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             */
            ModifyGroupRemarkRequest.prototype.remark = "";

            /**
             * Creates a new ModifyGroupRemarkRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest instance
             */
            ModifyGroupRemarkRequest.create = function create(properties) {
                return new ModifyGroupRemarkRequest(properties);
            };

            /**
             * Encodes the specified ModifyGroupRemarkRequest message. Does not implicitly {@link kritor.group.ModifyGroupRemarkRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest} message ModifyGroupRemarkRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remark);
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupRemarkRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupRemarkRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest} message ModifyGroupRemarkRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupRemarkRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupRemarkRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.remark = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupRemarkRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupRemarkRequest message.
             * @function verify
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupRemarkRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                return null;
            };

            /**
             * Creates a ModifyGroupRemarkRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             */
            ModifyGroupRemarkRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupRemarkRequest)
                    return object;
                let message = new $root.kritor.group.ModifyGroupRemarkRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.remark != null)
                    message.remark = String(object.remark);
                return message;
            };

            /**
             * Creates a plain object from a ModifyGroupRemarkRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.ModifyGroupRemarkRequest} message ModifyGroupRemarkRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupRemarkRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.remark = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                return object;
            };

            /**
             * Converts this ModifyGroupRemarkRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupRemarkRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupRemarkRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupRemarkRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupRemarkRequest";
            };

            return ModifyGroupRemarkRequest;
        })();

        group.ModifyGroupRemarkResponse = (function() {

            /**
             * Properties of a ModifyGroupRemarkResponse.
             * @memberof kritor.group
             * @interface IModifyGroupRemarkResponse
             */

            /**
             * Constructs a new ModifyGroupRemarkResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupRemarkResponse.
             * @implements IModifyGroupRemarkResponse
             * @constructor
             * @param {kritor.group.IModifyGroupRemarkResponse=} [properties] Properties to set
             */
            function ModifyGroupRemarkResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyGroupRemarkResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse instance
             */
            ModifyGroupRemarkResponse.create = function create(properties) {
                return new ModifyGroupRemarkResponse(properties);
            };

            /**
             * Encodes the specified ModifyGroupRemarkResponse message. Does not implicitly {@link kritor.group.ModifyGroupRemarkResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse} message ModifyGroupRemarkResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupRemarkResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupRemarkResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse} message ModifyGroupRemarkResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupRemarkResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupRemarkResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupRemarkResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupRemarkResponse message.
             * @function verify
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupRemarkResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyGroupRemarkResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             */
            ModifyGroupRemarkResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupRemarkResponse)
                    return object;
                return new $root.kritor.group.ModifyGroupRemarkResponse();
            };

            /**
             * Creates a plain object from a ModifyGroupRemarkResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.ModifyGroupRemarkResponse} message ModifyGroupRemarkResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupRemarkResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyGroupRemarkResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupRemarkResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupRemarkResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupRemarkResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupRemarkResponse";
            };

            return ModifyGroupRemarkResponse;
        })();

        group.SetGroupAdminRequest = (function() {

            /**
             * Properties of a SetGroupAdminRequest.
             * @memberof kritor.group
             * @interface ISetGroupAdminRequest
             * @property {number|Long|null} [groupId] SetGroupAdminRequest groupId
             * @property {string|null} [targetUid] SetGroupAdminRequest targetUid
             * @property {number|Long|null} [targetUin] SetGroupAdminRequest targetUin
             * @property {boolean|null} [isAdmin] SetGroupAdminRequest isAdmin
             */

            /**
             * Constructs a new SetGroupAdminRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupAdminRequest.
             * @implements ISetGroupAdminRequest
             * @constructor
             * @param {kritor.group.ISetGroupAdminRequest=} [properties] Properties to set
             */
            function SetGroupAdminRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupAdminRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupAdminRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.targetUid = null;

            /**
             * SetGroupAdminRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.targetUin = null;

            /**
             * SetGroupAdminRequest isAdmin.
             * @member {boolean} isAdmin
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.isAdmin = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupAdminRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            Object.defineProperty(SetGroupAdminRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupAdminRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest instance
             */
            SetGroupAdminRequest.create = function create(properties) {
                return new SetGroupAdminRequest(properties);
            };

            /**
             * Encodes the specified SetGroupAdminRequest message. Does not implicitly {@link kritor.group.SetGroupAdminRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest} message SetGroupAdminRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.isAdmin != null && Object.hasOwnProperty.call(message, "isAdmin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isAdmin);
                return writer;
            };

            /**
             * Encodes the specified SetGroupAdminRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupAdminRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest} message SetGroupAdminRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupAdminRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupAdminRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.isAdmin = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupAdminRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupAdminRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupAdminRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    if (typeof message.isAdmin !== "boolean")
                        return "isAdmin: boolean expected";
                return null;
            };

            /**
             * Creates a SetGroupAdminRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             */
            SetGroupAdminRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupAdminRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupAdminRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.isAdmin != null)
                    message.isAdmin = Boolean(object.isAdmin);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupAdminRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.SetGroupAdminRequest} message SetGroupAdminRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupAdminRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.isAdmin = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    object.isAdmin = message.isAdmin;
                return object;
            };

            /**
             * Converts this SetGroupAdminRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupAdminRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupAdminRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupAdminRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupAdminRequest";
            };

            return SetGroupAdminRequest;
        })();

        group.SetGroupAdminResponse = (function() {

            /**
             * Properties of a SetGroupAdminResponse.
             * @memberof kritor.group
             * @interface ISetGroupAdminResponse
             */

            /**
             * Constructs a new SetGroupAdminResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupAdminResponse.
             * @implements ISetGroupAdminResponse
             * @constructor
             * @param {kritor.group.ISetGroupAdminResponse=} [properties] Properties to set
             */
            function SetGroupAdminResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupAdminResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse instance
             */
            SetGroupAdminResponse.create = function create(properties) {
                return new SetGroupAdminResponse(properties);
            };

            /**
             * Encodes the specified SetGroupAdminResponse message. Does not implicitly {@link kritor.group.SetGroupAdminResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse} message SetGroupAdminResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupAdminResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupAdminResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse} message SetGroupAdminResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupAdminResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupAdminResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupAdminResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupAdminResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupAdminResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupAdminResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             */
            SetGroupAdminResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupAdminResponse)
                    return object;
                return new $root.kritor.group.SetGroupAdminResponse();
            };

            /**
             * Creates a plain object from a SetGroupAdminResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.SetGroupAdminResponse} message SetGroupAdminResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupAdminResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupAdminResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupAdminResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupAdminResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupAdminResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupAdminResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupAdminResponse";
            };

            return SetGroupAdminResponse;
        })();

        group.SetGroupUniqueTitleRequest = (function() {

            /**
             * Properties of a SetGroupUniqueTitleRequest.
             * @memberof kritor.group
             * @interface ISetGroupUniqueTitleRequest
             * @property {number|Long|null} [groupId] SetGroupUniqueTitleRequest groupId
             * @property {string|null} [targetUid] SetGroupUniqueTitleRequest targetUid
             * @property {number|Long|null} [targetUin] SetGroupUniqueTitleRequest targetUin
             * @property {string|null} [uniqueTitle] SetGroupUniqueTitleRequest uniqueTitle
             */

            /**
             * Constructs a new SetGroupUniqueTitleRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupUniqueTitleRequest.
             * @implements ISetGroupUniqueTitleRequest
             * @constructor
             * @param {kritor.group.ISetGroupUniqueTitleRequest=} [properties] Properties to set
             */
            function SetGroupUniqueTitleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupUniqueTitleRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupUniqueTitleRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.targetUid = null;

            /**
             * SetGroupUniqueTitleRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.targetUin = null;

            /**
             * SetGroupUniqueTitleRequest uniqueTitle.
             * @member {string} uniqueTitle
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.uniqueTitle = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupUniqueTitleRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            Object.defineProperty(SetGroupUniqueTitleRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupUniqueTitleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest instance
             */
            SetGroupUniqueTitleRequest.create = function create(properties) {
                return new SetGroupUniqueTitleRequest(properties);
            };

            /**
             * Encodes the specified SetGroupUniqueTitleRequest message. Does not implicitly {@link kritor.group.SetGroupUniqueTitleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.uniqueTitle != null && Object.hasOwnProperty.call(message, "uniqueTitle"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uniqueTitle);
                return writer;
            };

            /**
             * Encodes the specified SetGroupUniqueTitleRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupUniqueTitleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupUniqueTitleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupUniqueTitleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.uniqueTitle = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupUniqueTitleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupUniqueTitleRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupUniqueTitleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    if (!$util.isString(message.uniqueTitle))
                        return "uniqueTitle: string expected";
                return null;
            };

            /**
             * Creates a SetGroupUniqueTitleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             */
            SetGroupUniqueTitleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupUniqueTitleRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupUniqueTitleRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.uniqueTitle != null)
                    message.uniqueTitle = String(object.uniqueTitle);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupUniqueTitleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.SetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupUniqueTitleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.uniqueTitle = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    object.uniqueTitle = message.uniqueTitle;
                return object;
            };

            /**
             * Converts this SetGroupUniqueTitleRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupUniqueTitleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupUniqueTitleRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupUniqueTitleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupUniqueTitleRequest";
            };

            return SetGroupUniqueTitleRequest;
        })();

        group.SetGroupUniqueTitleResponse = (function() {

            /**
             * Properties of a SetGroupUniqueTitleResponse.
             * @memberof kritor.group
             * @interface ISetGroupUniqueTitleResponse
             */

            /**
             * Constructs a new SetGroupUniqueTitleResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupUniqueTitleResponse.
             * @implements ISetGroupUniqueTitleResponse
             * @constructor
             * @param {kritor.group.ISetGroupUniqueTitleResponse=} [properties] Properties to set
             */
            function SetGroupUniqueTitleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupUniqueTitleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse instance
             */
            SetGroupUniqueTitleResponse.create = function create(properties) {
                return new SetGroupUniqueTitleResponse(properties);
            };

            /**
             * Encodes the specified SetGroupUniqueTitleResponse message. Does not implicitly {@link kritor.group.SetGroupUniqueTitleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupUniqueTitleResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupUniqueTitleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupUniqueTitleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupUniqueTitleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupUniqueTitleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupUniqueTitleResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupUniqueTitleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupUniqueTitleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             */
            SetGroupUniqueTitleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupUniqueTitleResponse)
                    return object;
                return new $root.kritor.group.SetGroupUniqueTitleResponse();
            };

            /**
             * Creates a plain object from a SetGroupUniqueTitleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.SetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupUniqueTitleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupUniqueTitleResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupUniqueTitleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupUniqueTitleResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupUniqueTitleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupUniqueTitleResponse";
            };

            return SetGroupUniqueTitleResponse;
        })();

        group.SetGroupWholeBanRequest = (function() {

            /**
             * Properties of a SetGroupWholeBanRequest.
             * @memberof kritor.group
             * @interface ISetGroupWholeBanRequest
             * @property {number|Long|null} [groupId] SetGroupWholeBanRequest groupId
             * @property {boolean|null} [isBan] SetGroupWholeBanRequest isBan
             */

            /**
             * Constructs a new SetGroupWholeBanRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupWholeBanRequest.
             * @implements ISetGroupWholeBanRequest
             * @constructor
             * @param {kritor.group.ISetGroupWholeBanRequest=} [properties] Properties to set
             */
            function SetGroupWholeBanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupWholeBanRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             */
            SetGroupWholeBanRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupWholeBanRequest isBan.
             * @member {boolean} isBan
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             */
            SetGroupWholeBanRequest.prototype.isBan = false;

            /**
             * Creates a new SetGroupWholeBanRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest instance
             */
            SetGroupWholeBanRequest.create = function create(properties) {
                return new SetGroupWholeBanRequest(properties);
            };

            /**
             * Encodes the specified SetGroupWholeBanRequest message. Does not implicitly {@link kritor.group.SetGroupWholeBanRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest} message SetGroupWholeBanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.isBan != null && Object.hasOwnProperty.call(message, "isBan"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBan);
                return writer;
            };

            /**
             * Encodes the specified SetGroupWholeBanRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupWholeBanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest} message SetGroupWholeBanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupWholeBanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupWholeBanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.isBan = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupWholeBanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupWholeBanRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupWholeBanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.isBan != null && message.hasOwnProperty("isBan"))
                    if (typeof message.isBan !== "boolean")
                        return "isBan: boolean expected";
                return null;
            };

            /**
             * Creates a SetGroupWholeBanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             */
            SetGroupWholeBanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupWholeBanRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupWholeBanRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.isBan != null)
                    message.isBan = Boolean(object.isBan);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupWholeBanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.SetGroupWholeBanRequest} message SetGroupWholeBanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupWholeBanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.isBan = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.isBan != null && message.hasOwnProperty("isBan"))
                    object.isBan = message.isBan;
                return object;
            };

            /**
             * Converts this SetGroupWholeBanRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupWholeBanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupWholeBanRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupWholeBanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupWholeBanRequest";
            };

            return SetGroupWholeBanRequest;
        })();

        group.SetGroupWholeBanResponse = (function() {

            /**
             * Properties of a SetGroupWholeBanResponse.
             * @memberof kritor.group
             * @interface ISetGroupWholeBanResponse
             */

            /**
             * Constructs a new SetGroupWholeBanResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupWholeBanResponse.
             * @implements ISetGroupWholeBanResponse
             * @constructor
             * @param {kritor.group.ISetGroupWholeBanResponse=} [properties] Properties to set
             */
            function SetGroupWholeBanResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupWholeBanResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse instance
             */
            SetGroupWholeBanResponse.create = function create(properties) {
                return new SetGroupWholeBanResponse(properties);
            };

            /**
             * Encodes the specified SetGroupWholeBanResponse message. Does not implicitly {@link kritor.group.SetGroupWholeBanResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse} message SetGroupWholeBanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupWholeBanResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupWholeBanResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse} message SetGroupWholeBanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupWholeBanResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupWholeBanResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupWholeBanResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupWholeBanResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupWholeBanResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupWholeBanResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             */
            SetGroupWholeBanResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupWholeBanResponse)
                    return object;
                return new $root.kritor.group.SetGroupWholeBanResponse();
            };

            /**
             * Creates a plain object from a SetGroupWholeBanResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.SetGroupWholeBanResponse} message SetGroupWholeBanResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupWholeBanResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupWholeBanResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupWholeBanResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupWholeBanResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupWholeBanResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupWholeBanResponse";
            };

            return SetGroupWholeBanResponse;
        })();

        group.GetGroupInfoRequest = (function() {

            /**
             * Properties of a GetGroupInfoRequest.
             * @memberof kritor.group
             * @interface IGetGroupInfoRequest
             * @property {number|Long|null} [groupId] GetGroupInfoRequest groupId
             */

            /**
             * Constructs a new GetGroupInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupInfoRequest.
             * @implements IGetGroupInfoRequest
             * @constructor
             * @param {kritor.group.IGetGroupInfoRequest=} [properties] Properties to set
             */
            function GetGroupInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupInfoRequest
             * @instance
             */
            GetGroupInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGroupInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest instance
             */
            GetGroupInfoRequest.create = function create(properties) {
                return new GetGroupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetGroupInfoRequest message. Does not implicitly {@link kritor.group.GetGroupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest} message GetGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetGroupInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest} message GetGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGroupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             */
            GetGroupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.GetGroupInfoRequest} message GetGroupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetGroupInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupInfoRequest";
            };

            return GetGroupInfoRequest;
        })();

        group.GetGroupInfoResponse = (function() {

            /**
             * Properties of a GetGroupInfoResponse.
             * @memberof kritor.group
             * @interface IGetGroupInfoResponse
             * @property {kritor.group.IGroupInfo|null} [groupInfo] GetGroupInfoResponse groupInfo
             */

            /**
             * Constructs a new GetGroupInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupInfoResponse.
             * @implements IGetGroupInfoResponse
             * @constructor
             * @param {kritor.group.IGetGroupInfoResponse=} [properties] Properties to set
             */
            function GetGroupInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupInfoResponse groupInfo.
             * @member {kritor.group.IGroupInfo|null|undefined} groupInfo
             * @memberof kritor.group.GetGroupInfoResponse
             * @instance
             */
            GetGroupInfoResponse.prototype.groupInfo = null;

            /**
             * Creates a new GetGroupInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse instance
             */
            GetGroupInfoResponse.create = function create(properties) {
                return new GetGroupInfoResponse(properties);
            };

            /**
             * Encodes the specified GetGroupInfoResponse message. Does not implicitly {@link kritor.group.GetGroupInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse} message GetGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                    $root.kritor.group.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse} message GetGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupInfo = $root.kritor.group.GroupInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                    let error = $root.kritor.group.GroupInfo.verify(message.groupInfo);
                    if (error)
                        return "groupInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetGroupInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             */
            GetGroupInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupInfoResponse();
                if (object.groupInfo != null) {
                    if (typeof object.groupInfo !== "object")
                        throw TypeError(".kritor.group.GetGroupInfoResponse.groupInfo: object expected");
                    message.groupInfo = $root.kritor.group.GroupInfo.fromObject(object.groupInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.GetGroupInfoResponse} message GetGroupInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.groupInfo = null;
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                    object.groupInfo = $root.kritor.group.GroupInfo.toObject(message.groupInfo, options);
                return object;
            };

            /**
             * Converts this GetGroupInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupInfoResponse";
            };

            return GetGroupInfoResponse;
        })();

        group.GetGroupListRequest = (function() {

            /**
             * Properties of a GetGroupListRequest.
             * @memberof kritor.group
             * @interface IGetGroupListRequest
             * @property {boolean|null} [refresh] GetGroupListRequest refresh
             */

            /**
             * Constructs a new GetGroupListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupListRequest.
             * @implements IGetGroupListRequest
             * @constructor
             * @param {kritor.group.IGetGroupListRequest=} [properties] Properties to set
             */
            function GetGroupListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             */
            GetGroupListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             */
            Object.defineProperty(GetGroupListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest instance
             */
            GetGroupListRequest.create = function create(properties) {
                return new GetGroupListRequest(properties);
            };

            /**
             * Encodes the specified GetGroupListRequest message. Does not implicitly {@link kritor.group.GetGroupListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest} message GetGroupListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupListRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest} message GetGroupListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupListRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             */
            GetGroupListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupListRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupListRequest();
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.GetGroupListRequest} message GetGroupListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupListRequest";
            };

            return GetGroupListRequest;
        })();

        group.GetGroupListResponse = (function() {

            /**
             * Properties of a GetGroupListResponse.
             * @memberof kritor.group
             * @interface IGetGroupListResponse
             * @property {Array.<kritor.group.IGroupInfo>|null} [groupInfo] GetGroupListResponse groupInfo
             */

            /**
             * Constructs a new GetGroupListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupListResponse.
             * @implements IGetGroupListResponse
             * @constructor
             * @param {kritor.group.IGetGroupListResponse=} [properties] Properties to set
             */
            function GetGroupListResponse(properties) {
                this.groupInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupListResponse groupInfo.
             * @member {Array.<kritor.group.IGroupInfo>} groupInfo
             * @memberof kritor.group.GetGroupListResponse
             * @instance
             */
            GetGroupListResponse.prototype.groupInfo = $util.emptyArray;

            /**
             * Creates a new GetGroupListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse instance
             */
            GetGroupListResponse.create = function create(properties) {
                return new GetGroupListResponse(properties);
            };

            /**
             * Encodes the specified GetGroupListResponse message. Does not implicitly {@link kritor.group.GetGroupListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse} message GetGroupListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupInfo != null && message.groupInfo.length)
                    for (let i = 0; i < message.groupInfo.length; ++i)
                        $root.kritor.group.GroupInfo.encode(message.groupInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupListResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse} message GetGroupListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groupInfo && message.groupInfo.length))
                                message.groupInfo = [];
                            message.groupInfo.push($root.kritor.group.GroupInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupListResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                    if (!Array.isArray(message.groupInfo))
                        return "groupInfo: array expected";
                    for (let i = 0; i < message.groupInfo.length; ++i) {
                        let error = $root.kritor.group.GroupInfo.verify(message.groupInfo[i]);
                        if (error)
                            return "groupInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             */
            GetGroupListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupListResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupListResponse();
                if (object.groupInfo) {
                    if (!Array.isArray(object.groupInfo))
                        throw TypeError(".kritor.group.GetGroupListResponse.groupInfo: array expected");
                    message.groupInfo = [];
                    for (let i = 0; i < object.groupInfo.length; ++i) {
                        if (typeof object.groupInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupListResponse.groupInfo: object expected");
                        message.groupInfo[i] = $root.kritor.group.GroupInfo.fromObject(object.groupInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.GetGroupListResponse} message GetGroupListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groupInfo = [];
                if (message.groupInfo && message.groupInfo.length) {
                    object.groupInfo = [];
                    for (let j = 0; j < message.groupInfo.length; ++j)
                        object.groupInfo[j] = $root.kritor.group.GroupInfo.toObject(message.groupInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupListResponse";
            };

            return GetGroupListResponse;
        })();

        group.GetGroupMemberInfoRequest = (function() {

            /**
             * Properties of a GetGroupMemberInfoRequest.
             * @memberof kritor.group
             * @interface IGetGroupMemberInfoRequest
             * @property {number|Long|null} [groupId] GetGroupMemberInfoRequest groupId
             * @property {string|null} [uid] GetGroupMemberInfoRequest uid
             * @property {number|Long|null} [uin] GetGroupMemberInfoRequest uin
             * @property {boolean|null} [refresh] GetGroupMemberInfoRequest refresh
             */

            /**
             * Constructs a new GetGroupMemberInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberInfoRequest.
             * @implements IGetGroupMemberInfoRequest
             * @constructor
             * @param {kritor.group.IGetGroupMemberInfoRequest=} [properties] Properties to set
             */
            function GetGroupMemberInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupMemberInfoRequest uid.
             * @member {string|null|undefined} uid
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.uid = null;

            /**
             * GetGroupMemberInfoRequest uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.uin = null;

            /**
             * GetGroupMemberInfoRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupMemberInfoRequest target.
             * @member {"uid"|"uin"|undefined} target
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberInfoRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["uid", "uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetGroupMemberInfoRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberInfoRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupMemberInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest instance
             */
            GetGroupMemberInfoRequest.create = function create(properties) {
                return new GetGroupMemberInfoRequest(properties);
            };

            /**
             * Encodes the specified GetGroupMemberInfoRequest message. Does not implicitly {@link kritor.group.GetGroupMemberInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest} message GetGroupMemberInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.uin);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest} message GetGroupMemberInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.uid != null && message.hasOwnProperty("uid")) {
                    properties.target = 1;
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                }
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             */
            GetGroupMemberInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.GetGroupMemberInfoRequest} message GetGroupMemberInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.uid != null && message.hasOwnProperty("uid")) {
                    object.uid = message.uid;
                    if (options.oneofs)
                        object.target = "uid";
                }
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object.target = "uin";
                }
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberInfoRequest";
            };

            return GetGroupMemberInfoRequest;
        })();

        group.GetGroupMemberInfoResponse = (function() {

            /**
             * Properties of a GetGroupMemberInfoResponse.
             * @memberof kritor.group
             * @interface IGetGroupMemberInfoResponse
             * @property {kritor.group.IGroupMemberInfo|null} [groupMemberInfo] GetGroupMemberInfoResponse groupMemberInfo
             */

            /**
             * Constructs a new GetGroupMemberInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberInfoResponse.
             * @implements IGetGroupMemberInfoResponse
             * @constructor
             * @param {kritor.group.IGetGroupMemberInfoResponse=} [properties] Properties to set
             */
            function GetGroupMemberInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberInfoResponse groupMemberInfo.
             * @member {kritor.group.IGroupMemberInfo|null|undefined} groupMemberInfo
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @instance
             */
            GetGroupMemberInfoResponse.prototype.groupMemberInfo = null;

            /**
             * Creates a new GetGroupMemberInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse instance
             */
            GetGroupMemberInfoResponse.create = function create(properties) {
                return new GetGroupMemberInfoResponse(properties);
            };

            /**
             * Encodes the specified GetGroupMemberInfoResponse message. Does not implicitly {@link kritor.group.GetGroupMemberInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse} message GetGroupMemberInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupMemberInfo != null && Object.hasOwnProperty.call(message, "groupMemberInfo"))
                    $root.kritor.group.GroupMemberInfo.encode(message.groupMemberInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse} message GetGroupMemberInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupMemberInfo = $root.kritor.group.GroupMemberInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupMemberInfo != null && message.hasOwnProperty("groupMemberInfo")) {
                    let error = $root.kritor.group.GroupMemberInfo.verify(message.groupMemberInfo);
                    if (error)
                        return "groupMemberInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             */
            GetGroupMemberInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberInfoResponse();
                if (object.groupMemberInfo != null) {
                    if (typeof object.groupMemberInfo !== "object")
                        throw TypeError(".kritor.group.GetGroupMemberInfoResponse.groupMemberInfo: object expected");
                    message.groupMemberInfo = $root.kritor.group.GroupMemberInfo.fromObject(object.groupMemberInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.GetGroupMemberInfoResponse} message GetGroupMemberInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.groupMemberInfo = null;
                if (message.groupMemberInfo != null && message.hasOwnProperty("groupMemberInfo"))
                    object.groupMemberInfo = $root.kritor.group.GroupMemberInfo.toObject(message.groupMemberInfo, options);
                return object;
            };

            /**
             * Converts this GetGroupMemberInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberInfoResponse";
            };

            return GetGroupMemberInfoResponse;
        })();

        group.GetGroupMemberListRequest = (function() {

            /**
             * Properties of a GetGroupMemberListRequest.
             * @memberof kritor.group
             * @interface IGetGroupMemberListRequest
             * @property {number|Long|null} [groupId] GetGroupMemberListRequest groupId
             * @property {boolean|null} [refresh] GetGroupMemberListRequest refresh
             */

            /**
             * Constructs a new GetGroupMemberListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberListRequest.
             * @implements IGetGroupMemberListRequest
             * @constructor
             * @param {kritor.group.IGetGroupMemberListRequest=} [properties] Properties to set
             */
            function GetGroupMemberListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberListRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            GetGroupMemberListRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupMemberListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            GetGroupMemberListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupMemberListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupMemberListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest instance
             */
            GetGroupMemberListRequest.create = function create(properties) {
                return new GetGroupMemberListRequest(properties);
            };

            /**
             * Encodes the specified GetGroupMemberListRequest message. Does not implicitly {@link kritor.group.GetGroupMemberListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest} message GetGroupMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberListRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest} message GetGroupMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberListRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             */
            GetGroupMemberListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberListRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberListRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.GetGroupMemberListRequest} message GetGroupMemberListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberListRequest";
            };

            return GetGroupMemberListRequest;
        })();

        group.GetGroupMemberListResponse = (function() {

            /**
             * Properties of a GetGroupMemberListResponse.
             * @memberof kritor.group
             * @interface IGetGroupMemberListResponse
             * @property {Array.<kritor.group.IGroupMemberInfo>|null} [groupMemberInfo] GetGroupMemberListResponse groupMemberInfo
             */

            /**
             * Constructs a new GetGroupMemberListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberListResponse.
             * @implements IGetGroupMemberListResponse
             * @constructor
             * @param {kritor.group.IGetGroupMemberListResponse=} [properties] Properties to set
             */
            function GetGroupMemberListResponse(properties) {
                this.groupMemberInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberListResponse groupMemberInfo.
             * @member {Array.<kritor.group.IGroupMemberInfo>} groupMemberInfo
             * @memberof kritor.group.GetGroupMemberListResponse
             * @instance
             */
            GetGroupMemberListResponse.prototype.groupMemberInfo = $util.emptyArray;

            /**
             * Creates a new GetGroupMemberListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse instance
             */
            GetGroupMemberListResponse.create = function create(properties) {
                return new GetGroupMemberListResponse(properties);
            };

            /**
             * Encodes the specified GetGroupMemberListResponse message. Does not implicitly {@link kritor.group.GetGroupMemberListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse} message GetGroupMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupMemberInfo != null && message.groupMemberInfo.length)
                    for (let i = 0; i < message.groupMemberInfo.length; ++i)
                        $root.kritor.group.GroupMemberInfo.encode(message.groupMemberInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberListResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse} message GetGroupMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groupMemberInfo && message.groupMemberInfo.length))
                                message.groupMemberInfo = [];
                            message.groupMemberInfo.push($root.kritor.group.GroupMemberInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberListResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupMemberInfo != null && message.hasOwnProperty("groupMemberInfo")) {
                    if (!Array.isArray(message.groupMemberInfo))
                        return "groupMemberInfo: array expected";
                    for (let i = 0; i < message.groupMemberInfo.length; ++i) {
                        let error = $root.kritor.group.GroupMemberInfo.verify(message.groupMemberInfo[i]);
                        if (error)
                            return "groupMemberInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             */
            GetGroupMemberListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberListResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberListResponse();
                if (object.groupMemberInfo) {
                    if (!Array.isArray(object.groupMemberInfo))
                        throw TypeError(".kritor.group.GetGroupMemberListResponse.groupMemberInfo: array expected");
                    message.groupMemberInfo = [];
                    for (let i = 0; i < object.groupMemberInfo.length; ++i) {
                        if (typeof object.groupMemberInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupMemberListResponse.groupMemberInfo: object expected");
                        message.groupMemberInfo[i] = $root.kritor.group.GroupMemberInfo.fromObject(object.groupMemberInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.GetGroupMemberListResponse} message GetGroupMemberListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groupMemberInfo = [];
                if (message.groupMemberInfo && message.groupMemberInfo.length) {
                    object.groupMemberInfo = [];
                    for (let j = 0; j < message.groupMemberInfo.length; ++j)
                        object.groupMemberInfo[j] = $root.kritor.group.GroupMemberInfo.toObject(message.groupMemberInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberListResponse";
            };

            return GetGroupMemberListResponse;
        })();

        group.GetProhibitedUserListRequest = (function() {

            /**
             * Properties of a GetProhibitedUserListRequest.
             * @memberof kritor.group
             * @interface IGetProhibitedUserListRequest
             * @property {number|Long|null} [groupId] GetProhibitedUserListRequest groupId
             */

            /**
             * Constructs a new GetProhibitedUserListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetProhibitedUserListRequest.
             * @implements IGetProhibitedUserListRequest
             * @constructor
             * @param {kritor.group.IGetProhibitedUserListRequest=} [properties] Properties to set
             */
            function GetProhibitedUserListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetProhibitedUserListRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @instance
             */
            GetProhibitedUserListRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetProhibitedUserListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest instance
             */
            GetProhibitedUserListRequest.create = function create(properties) {
                return new GetProhibitedUserListRequest(properties);
            };

            /**
             * Encodes the specified GetProhibitedUserListRequest message. Does not implicitly {@link kritor.group.GetProhibitedUserListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest} message GetProhibitedUserListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetProhibitedUserListRequest message, length delimited. Does not implicitly {@link kritor.group.GetProhibitedUserListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest} message GetProhibitedUserListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProhibitedUserListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetProhibitedUserListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProhibitedUserListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProhibitedUserListRequest message.
             * @function verify
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProhibitedUserListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetProhibitedUserListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             */
            GetProhibitedUserListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetProhibitedUserListRequest)
                    return object;
                let message = new $root.kritor.group.GetProhibitedUserListRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetProhibitedUserListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.GetProhibitedUserListRequest} message GetProhibitedUserListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProhibitedUserListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetProhibitedUserListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProhibitedUserListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetProhibitedUserListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetProhibitedUserListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetProhibitedUserListRequest";
            };

            return GetProhibitedUserListRequest;
        })();

        group.GetProhibitedUserListResponse = (function() {

            /**
             * Properties of a GetProhibitedUserListResponse.
             * @memberof kritor.group
             * @interface IGetProhibitedUserListResponse
             * @property {Array.<kritor.group.IProhibitedUserInfo>|null} [prohibitedUserInfo] GetProhibitedUserListResponse prohibitedUserInfo
             */

            /**
             * Constructs a new GetProhibitedUserListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetProhibitedUserListResponse.
             * @implements IGetProhibitedUserListResponse
             * @constructor
             * @param {kritor.group.IGetProhibitedUserListResponse=} [properties] Properties to set
             */
            function GetProhibitedUserListResponse(properties) {
                this.prohibitedUserInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetProhibitedUserListResponse prohibitedUserInfo.
             * @member {Array.<kritor.group.IProhibitedUserInfo>} prohibitedUserInfo
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @instance
             */
            GetProhibitedUserListResponse.prototype.prohibitedUserInfo = $util.emptyArray;

            /**
             * Creates a new GetProhibitedUserListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse instance
             */
            GetProhibitedUserListResponse.create = function create(properties) {
                return new GetProhibitedUserListResponse(properties);
            };

            /**
             * Encodes the specified GetProhibitedUserListResponse message. Does not implicitly {@link kritor.group.GetProhibitedUserListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse} message GetProhibitedUserListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prohibitedUserInfo != null && message.prohibitedUserInfo.length)
                    for (let i = 0; i < message.prohibitedUserInfo.length; ++i)
                        $root.kritor.group.ProhibitedUserInfo.encode(message.prohibitedUserInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetProhibitedUserListResponse message, length delimited. Does not implicitly {@link kritor.group.GetProhibitedUserListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse} message GetProhibitedUserListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProhibitedUserListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetProhibitedUserListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.prohibitedUserInfo && message.prohibitedUserInfo.length))
                                message.prohibitedUserInfo = [];
                            message.prohibitedUserInfo.push($root.kritor.group.ProhibitedUserInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProhibitedUserListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProhibitedUserListResponse message.
             * @function verify
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProhibitedUserListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prohibitedUserInfo != null && message.hasOwnProperty("prohibitedUserInfo")) {
                    if (!Array.isArray(message.prohibitedUserInfo))
                        return "prohibitedUserInfo: array expected";
                    for (let i = 0; i < message.prohibitedUserInfo.length; ++i) {
                        let error = $root.kritor.group.ProhibitedUserInfo.verify(message.prohibitedUserInfo[i]);
                        if (error)
                            return "prohibitedUserInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetProhibitedUserListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             */
            GetProhibitedUserListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetProhibitedUserListResponse)
                    return object;
                let message = new $root.kritor.group.GetProhibitedUserListResponse();
                if (object.prohibitedUserInfo) {
                    if (!Array.isArray(object.prohibitedUserInfo))
                        throw TypeError(".kritor.group.GetProhibitedUserListResponse.prohibitedUserInfo: array expected");
                    message.prohibitedUserInfo = [];
                    for (let i = 0; i < object.prohibitedUserInfo.length; ++i) {
                        if (typeof object.prohibitedUserInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetProhibitedUserListResponse.prohibitedUserInfo: object expected");
                        message.prohibitedUserInfo[i] = $root.kritor.group.ProhibitedUserInfo.fromObject(object.prohibitedUserInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetProhibitedUserListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.GetProhibitedUserListResponse} message GetProhibitedUserListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProhibitedUserListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.prohibitedUserInfo = [];
                if (message.prohibitedUserInfo && message.prohibitedUserInfo.length) {
                    object.prohibitedUserInfo = [];
                    for (let j = 0; j < message.prohibitedUserInfo.length; ++j)
                        object.prohibitedUserInfo[j] = $root.kritor.group.ProhibitedUserInfo.toObject(message.prohibitedUserInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetProhibitedUserListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProhibitedUserListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetProhibitedUserListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetProhibitedUserListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetProhibitedUserListResponse";
            };

            return GetProhibitedUserListResponse;
        })();

        group.GetRemainCountAtAllRequest = (function() {

            /**
             * Properties of a GetRemainCountAtAllRequest.
             * @memberof kritor.group
             * @interface IGetRemainCountAtAllRequest
             * @property {number|Long|null} [groupId] GetRemainCountAtAllRequest groupId
             */

            /**
             * Constructs a new GetRemainCountAtAllRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetRemainCountAtAllRequest.
             * @implements IGetRemainCountAtAllRequest
             * @constructor
             * @param {kritor.group.IGetRemainCountAtAllRequest=} [properties] Properties to set
             */
            function GetRemainCountAtAllRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRemainCountAtAllRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @instance
             */
            GetRemainCountAtAllRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetRemainCountAtAllRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest=} [properties] Properties to set
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest instance
             */
            GetRemainCountAtAllRequest.create = function create(properties) {
                return new GetRemainCountAtAllRequest(properties);
            };

            /**
             * Encodes the specified GetRemainCountAtAllRequest message. Does not implicitly {@link kritor.group.GetRemainCountAtAllRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest} message GetRemainCountAtAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetRemainCountAtAllRequest message, length delimited. Does not implicitly {@link kritor.group.GetRemainCountAtAllRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest} message GetRemainCountAtAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRemainCountAtAllRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRemainCountAtAllRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRemainCountAtAllRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRemainCountAtAllRequest message.
             * @function verify
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRemainCountAtAllRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetRemainCountAtAllRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             */
            GetRemainCountAtAllRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRemainCountAtAllRequest)
                    return object;
                let message = new $root.kritor.group.GetRemainCountAtAllRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetRemainCountAtAllRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.GetRemainCountAtAllRequest} message GetRemainCountAtAllRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRemainCountAtAllRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetRemainCountAtAllRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRemainCountAtAllRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRemainCountAtAllRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRemainCountAtAllRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRemainCountAtAllRequest";
            };

            return GetRemainCountAtAllRequest;
        })();

        group.GetRemainCountAtAllResponse = (function() {

            /**
             * Properties of a GetRemainCountAtAllResponse.
             * @memberof kritor.group
             * @interface IGetRemainCountAtAllResponse
             * @property {number|null} [remainCountForGroup] GetRemainCountAtAllResponse remainCountForGroup
             * @property {boolean|null} [accessAtAll] GetRemainCountAtAllResponse accessAtAll
             * @property {number|null} [remainCountForSelf] GetRemainCountAtAllResponse remainCountForSelf
             */

            /**
             * Constructs a new GetRemainCountAtAllResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetRemainCountAtAllResponse.
             * @implements IGetRemainCountAtAllResponse
             * @constructor
             * @param {kritor.group.IGetRemainCountAtAllResponse=} [properties] Properties to set
             */
            function GetRemainCountAtAllResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRemainCountAtAllResponse remainCountForGroup.
             * @member {number} remainCountForGroup
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.remainCountForGroup = 0;

            /**
             * GetRemainCountAtAllResponse accessAtAll.
             * @member {boolean} accessAtAll
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.accessAtAll = false;

            /**
             * GetRemainCountAtAllResponse remainCountForSelf.
             * @member {number} remainCountForSelf
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.remainCountForSelf = 0;

            /**
             * Creates a new GetRemainCountAtAllResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse=} [properties] Properties to set
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse instance
             */
            GetRemainCountAtAllResponse.create = function create(properties) {
                return new GetRemainCountAtAllResponse(properties);
            };

            /**
             * Encodes the specified GetRemainCountAtAllResponse message. Does not implicitly {@link kritor.group.GetRemainCountAtAllResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse} message GetRemainCountAtAllResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.remainCountForGroup != null && Object.hasOwnProperty.call(message, "remainCountForGroup"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.remainCountForGroup);
                if (message.accessAtAll != null && Object.hasOwnProperty.call(message, "accessAtAll"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.accessAtAll);
                if (message.remainCountForSelf != null && Object.hasOwnProperty.call(message, "remainCountForSelf"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.remainCountForSelf);
                return writer;
            };

            /**
             * Encodes the specified GetRemainCountAtAllResponse message, length delimited. Does not implicitly {@link kritor.group.GetRemainCountAtAllResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse} message GetRemainCountAtAllResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRemainCountAtAllResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRemainCountAtAllResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.remainCountForGroup = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.accessAtAll = reader.bool();
                            break;
                        }
                    case 3: {
                            message.remainCountForSelf = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRemainCountAtAllResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRemainCountAtAllResponse message.
             * @function verify
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRemainCountAtAllResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.remainCountForGroup != null && message.hasOwnProperty("remainCountForGroup"))
                    if (!$util.isInteger(message.remainCountForGroup))
                        return "remainCountForGroup: integer expected";
                if (message.accessAtAll != null && message.hasOwnProperty("accessAtAll"))
                    if (typeof message.accessAtAll !== "boolean")
                        return "accessAtAll: boolean expected";
                if (message.remainCountForSelf != null && message.hasOwnProperty("remainCountForSelf"))
                    if (!$util.isInteger(message.remainCountForSelf))
                        return "remainCountForSelf: integer expected";
                return null;
            };

            /**
             * Creates a GetRemainCountAtAllResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             */
            GetRemainCountAtAllResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRemainCountAtAllResponse)
                    return object;
                let message = new $root.kritor.group.GetRemainCountAtAllResponse();
                if (object.remainCountForGroup != null)
                    message.remainCountForGroup = object.remainCountForGroup >>> 0;
                if (object.accessAtAll != null)
                    message.accessAtAll = Boolean(object.accessAtAll);
                if (object.remainCountForSelf != null)
                    message.remainCountForSelf = object.remainCountForSelf >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetRemainCountAtAllResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.GetRemainCountAtAllResponse} message GetRemainCountAtAllResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRemainCountAtAllResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.remainCountForGroup = 0;
                    object.accessAtAll = false;
                    object.remainCountForSelf = 0;
                }
                if (message.remainCountForGroup != null && message.hasOwnProperty("remainCountForGroup"))
                    object.remainCountForGroup = message.remainCountForGroup;
                if (message.accessAtAll != null && message.hasOwnProperty("accessAtAll"))
                    object.accessAtAll = message.accessAtAll;
                if (message.remainCountForSelf != null && message.hasOwnProperty("remainCountForSelf"))
                    object.remainCountForSelf = message.remainCountForSelf;
                return object;
            };

            /**
             * Converts this GetRemainCountAtAllResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRemainCountAtAllResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRemainCountAtAllResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRemainCountAtAllResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRemainCountAtAllResponse";
            };

            return GetRemainCountAtAllResponse;
        })();

        group.GetNotJoinedGroupInfoRequest = (function() {

            /**
             * Properties of a GetNotJoinedGroupInfoRequest.
             * @memberof kritor.group
             * @interface IGetNotJoinedGroupInfoRequest
             * @property {number|Long|null} [groupId] GetNotJoinedGroupInfoRequest groupId
             */

            /**
             * Constructs a new GetNotJoinedGroupInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetNotJoinedGroupInfoRequest.
             * @implements IGetNotJoinedGroupInfoRequest
             * @constructor
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest=} [properties] Properties to set
             */
            function GetNotJoinedGroupInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetNotJoinedGroupInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @instance
             */
            GetNotJoinedGroupInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetNotJoinedGroupInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest instance
             */
            GetNotJoinedGroupInfoRequest.create = function create(properties) {
                return new GetNotJoinedGroupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoRequest message. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetNotJoinedGroupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetNotJoinedGroupInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetNotJoinedGroupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetNotJoinedGroupInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetNotJoinedGroupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetNotJoinedGroupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             */
            GetNotJoinedGroupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetNotJoinedGroupInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetNotJoinedGroupInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetNotJoinedGroupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.GetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetNotJoinedGroupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetNotJoinedGroupInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetNotJoinedGroupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetNotJoinedGroupInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetNotJoinedGroupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetNotJoinedGroupInfoRequest";
            };

            return GetNotJoinedGroupInfoRequest;
        })();

        group.GetNotJoinedGroupInfoResponse = (function() {

            /**
             * Properties of a GetNotJoinedGroupInfoResponse.
             * @memberof kritor.group
             * @interface IGetNotJoinedGroupInfoResponse
             * @property {kritor.group.INotJoinedGroupInfo|null} [groupInfo] GetNotJoinedGroupInfoResponse groupInfo
             */

            /**
             * Constructs a new GetNotJoinedGroupInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetNotJoinedGroupInfoResponse.
             * @implements IGetNotJoinedGroupInfoResponse
             * @constructor
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse=} [properties] Properties to set
             */
            function GetNotJoinedGroupInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetNotJoinedGroupInfoResponse groupInfo.
             * @member {kritor.group.INotJoinedGroupInfo|null|undefined} groupInfo
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @instance
             */
            GetNotJoinedGroupInfoResponse.prototype.groupInfo = null;

            /**
             * Creates a new GetNotJoinedGroupInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse instance
             */
            GetNotJoinedGroupInfoResponse.create = function create(properties) {
                return new GetNotJoinedGroupInfoResponse(properties);
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoResponse message. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                    $root.kritor.group.NotJoinedGroupInfo.encode(message.groupInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetNotJoinedGroupInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetNotJoinedGroupInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupInfo = $root.kritor.group.NotJoinedGroupInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetNotJoinedGroupInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetNotJoinedGroupInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetNotJoinedGroupInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                    let error = $root.kritor.group.NotJoinedGroupInfo.verify(message.groupInfo);
                    if (error)
                        return "groupInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetNotJoinedGroupInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             */
            GetNotJoinedGroupInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetNotJoinedGroupInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetNotJoinedGroupInfoResponse();
                if (object.groupInfo != null) {
                    if (typeof object.groupInfo !== "object")
                        throw TypeError(".kritor.group.GetNotJoinedGroupInfoResponse.groupInfo: object expected");
                    message.groupInfo = $root.kritor.group.NotJoinedGroupInfo.fromObject(object.groupInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetNotJoinedGroupInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.GetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetNotJoinedGroupInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.groupInfo = null;
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                    object.groupInfo = $root.kritor.group.NotJoinedGroupInfo.toObject(message.groupInfo, options);
                return object;
            };

            /**
             * Converts this GetNotJoinedGroupInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetNotJoinedGroupInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetNotJoinedGroupInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetNotJoinedGroupInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetNotJoinedGroupInfoResponse";
            };

            return GetNotJoinedGroupInfoResponse;
        })();

        group.GetGroupHonorRequest = (function() {

            /**
             * Properties of a GetGroupHonorRequest.
             * @memberof kritor.group
             * @interface IGetGroupHonorRequest
             * @property {number|Long|null} [groupId] GetGroupHonorRequest groupId
             * @property {boolean|null} [refresh] GetGroupHonorRequest refresh
             */

            /**
             * Constructs a new GetGroupHonorRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupHonorRequest.
             * @implements IGetGroupHonorRequest
             * @constructor
             * @param {kritor.group.IGetGroupHonorRequest=} [properties] Properties to set
             */
            function GetGroupHonorRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupHonorRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            GetGroupHonorRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupHonorRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            GetGroupHonorRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupHonorRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            Object.defineProperty(GetGroupHonorRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupHonorRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest instance
             */
            GetGroupHonorRequest.create = function create(properties) {
                return new GetGroupHonorRequest(properties);
            };

            /**
             * Encodes the specified GetGroupHonorRequest message. Does not implicitly {@link kritor.group.GetGroupHonorRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest} message GetGroupHonorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupHonorRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupHonorRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest} message GetGroupHonorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupHonorRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupHonorRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupHonorRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupHonorRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupHonorRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupHonorRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             */
            GetGroupHonorRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupHonorRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupHonorRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupHonorRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.GetGroupHonorRequest} message GetGroupHonorRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupHonorRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupHonorRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupHonorRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupHonorRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupHonorRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupHonorRequest";
            };

            return GetGroupHonorRequest;
        })();

        group.GetGroupHonorResponse = (function() {

            /**
             * Properties of a GetGroupHonorResponse.
             * @memberof kritor.group
             * @interface IGetGroupHonorResponse
             * @property {Array.<kritor.group.IGroupHonorInfo>|null} [groupHonorInfo] GetGroupHonorResponse groupHonorInfo
             */

            /**
             * Constructs a new GetGroupHonorResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupHonorResponse.
             * @implements IGetGroupHonorResponse
             * @constructor
             * @param {kritor.group.IGetGroupHonorResponse=} [properties] Properties to set
             */
            function GetGroupHonorResponse(properties) {
                this.groupHonorInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupHonorResponse groupHonorInfo.
             * @member {Array.<kritor.group.IGroupHonorInfo>} groupHonorInfo
             * @memberof kritor.group.GetGroupHonorResponse
             * @instance
             */
            GetGroupHonorResponse.prototype.groupHonorInfo = $util.emptyArray;

            /**
             * Creates a new GetGroupHonorResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse instance
             */
            GetGroupHonorResponse.create = function create(properties) {
                return new GetGroupHonorResponse(properties);
            };

            /**
             * Encodes the specified GetGroupHonorResponse message. Does not implicitly {@link kritor.group.GetGroupHonorResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse} message GetGroupHonorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupHonorInfo != null && message.groupHonorInfo.length)
                    for (let i = 0; i < message.groupHonorInfo.length; ++i)
                        $root.kritor.group.GroupHonorInfo.encode(message.groupHonorInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupHonorResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupHonorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse} message GetGroupHonorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupHonorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupHonorResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groupHonorInfo && message.groupHonorInfo.length))
                                message.groupHonorInfo = [];
                            message.groupHonorInfo.push($root.kritor.group.GroupHonorInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupHonorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupHonorResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupHonorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupHonorInfo != null && message.hasOwnProperty("groupHonorInfo")) {
                    if (!Array.isArray(message.groupHonorInfo))
                        return "groupHonorInfo: array expected";
                    for (let i = 0; i < message.groupHonorInfo.length; ++i) {
                        let error = $root.kritor.group.GroupHonorInfo.verify(message.groupHonorInfo[i]);
                        if (error)
                            return "groupHonorInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupHonorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             */
            GetGroupHonorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupHonorResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupHonorResponse();
                if (object.groupHonorInfo) {
                    if (!Array.isArray(object.groupHonorInfo))
                        throw TypeError(".kritor.group.GetGroupHonorResponse.groupHonorInfo: array expected");
                    message.groupHonorInfo = [];
                    for (let i = 0; i < object.groupHonorInfo.length; ++i) {
                        if (typeof object.groupHonorInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupHonorResponse.groupHonorInfo: object expected");
                        message.groupHonorInfo[i] = $root.kritor.group.GroupHonorInfo.fromObject(object.groupHonorInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupHonorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.GetGroupHonorResponse} message GetGroupHonorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupHonorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groupHonorInfo = [];
                if (message.groupHonorInfo && message.groupHonorInfo.length) {
                    object.groupHonorInfo = [];
                    for (let j = 0; j < message.groupHonorInfo.length; ++j)
                        object.groupHonorInfo[j] = $root.kritor.group.GroupHonorInfo.toObject(message.groupHonorInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupHonorResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupHonorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupHonorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupHonorResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupHonorResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupHonorResponse";
            };

            return GetGroupHonorResponse;
        })();

        return group;
    })();

    kritor.friend = (function() {

        /**
         * Namespace friend.
         * @memberof kritor
         * @namespace
         */
        const friend = {};

        friend.FriendData = (function() {

            /**
             * Properties of a FriendData.
             * @memberof kritor.friend
             * @interface IFriendData
             * @property {string|null} [uid] FriendData uid
             * @property {number|Long|null} [uin] FriendData uin
             * @property {string|null} [qid] FriendData qid
             * @property {string|null} [nick] FriendData nick
             * @property {number|null} [age] FriendData age
             * @property {number|null} [level] FriendData level
             * @property {number|null} [voteCnt] FriendData voteCnt
             * @property {number|null} [gender] FriendData gender
             * @property {number|null} [groupId] FriendData groupId
             * @property {string|null} [remark] FriendData remark
             * @property {Uint8Array|null} [ext] FriendData ext
             */

            /**
             * Constructs a new FriendData.
             * @memberof kritor.friend
             * @classdesc Represents a FriendData.
             * @implements IFriendData
             * @constructor
             * @param {kritor.friend.IFriendData=} [properties] Properties to set
             */
            function FriendData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendData uid.
             * @member {string} uid
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.uid = "";

            /**
             * FriendData uin.
             * @member {number|Long} uin
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendData qid.
             * @member {string} qid
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.qid = "";

            /**
             * FriendData nick.
             * @member {string} nick
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.nick = "";

            /**
             * FriendData age.
             * @member {number} age
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.age = 0;

            /**
             * FriendData level.
             * @member {number} level
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.level = 0;

            /**
             * FriendData voteCnt.
             * @member {number} voteCnt
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.voteCnt = 0;

            /**
             * FriendData gender.
             * @member {number} gender
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.gender = 0;

            /**
             * FriendData groupId.
             * @member {number} groupId
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.groupId = 0;

            /**
             * FriendData remark.
             * @member {string} remark
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.remark = "";

            /**
             * FriendData ext.
             * @member {Uint8Array|null|undefined} ext
             * @memberof kritor.friend.FriendData
             * @instance
             */
            FriendData.prototype.ext = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FriendData _ext.
             * @member {"ext"|undefined} _ext
             * @memberof kritor.friend.FriendData
             * @instance
             */
            Object.defineProperty(FriendData.prototype, "_ext", {
                get: $util.oneOfGetter($oneOfFields = ["ext"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FriendData instance using the specified properties.
             * @function create
             * @memberof kritor.friend.FriendData
             * @static
             * @param {kritor.friend.IFriendData=} [properties] Properties to set
             * @returns {kritor.friend.FriendData} FriendData instance
             */
            FriendData.create = function create(properties) {
                return new FriendData(properties);
            };

            /**
             * Encodes the specified FriendData message. Does not implicitly {@link kritor.friend.FriendData.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.FriendData
             * @static
             * @param {kritor.friend.IFriendData} message FriendData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.qid);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nick);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.age);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.level);
                if (message.voteCnt != null && Object.hasOwnProperty.call(message, "voteCnt"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.voteCnt);
                if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.gender);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.groupId);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.remark);
                if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                    writer.uint32(/* id 99, wireType 2 =*/794).bytes(message.ext);
                return writer;
            };

            /**
             * Encodes the specified FriendData message, length delimited. Does not implicitly {@link kritor.friend.FriendData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.FriendData
             * @static
             * @param {kritor.friend.IFriendData} message FriendData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendData message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.FriendData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.FriendData} FriendData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.FriendData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.qid = reader.string();
                            break;
                        }
                    case 4: {
                            message.nick = reader.string();
                            break;
                        }
                    case 5: {
                            message.age = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.voteCnt = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.gender = reader.int32();
                            break;
                        }
                    case 9: {
                            message.groupId = reader.int32();
                            break;
                        }
                    case 10: {
                            message.remark = reader.string();
                            break;
                        }
                    case 99: {
                            message.ext = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.FriendData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.FriendData} FriendData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendData message.
             * @function verify
             * @memberof kritor.friend.FriendData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.qid != null && message.hasOwnProperty("qid"))
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.age != null && message.hasOwnProperty("age"))
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    if (!$util.isInteger(message.voteCnt))
                        return "voteCnt: integer expected";
                if (message.gender != null && message.hasOwnProperty("gender"))
                    if (!$util.isInteger(message.gender))
                        return "gender: integer expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId))
                        return "groupId: integer expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    properties._ext = 1;
                    if (!(message.ext && typeof message.ext.length === "number" || $util.isString(message.ext)))
                        return "ext: buffer expected";
                }
                return null;
            };

            /**
             * Creates a FriendData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.FriendData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.FriendData} FriendData
             */
            FriendData.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.FriendData)
                    return object;
                let message = new $root.kritor.friend.FriendData();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.age != null)
                    message.age = object.age >>> 0;
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.voteCnt != null)
                    message.voteCnt = object.voteCnt >>> 0;
                if (object.gender != null)
                    message.gender = object.gender | 0;
                if (object.groupId != null)
                    message.groupId = object.groupId | 0;
                if (object.remark != null)
                    message.remark = String(object.remark);
                if (object.ext != null)
                    if (typeof object.ext === "string")
                        $util.base64.decode(object.ext, message.ext = $util.newBuffer($util.base64.length(object.ext)), 0);
                    else if (object.ext.length >= 0)
                        message.ext = object.ext;
                return message;
            };

            /**
             * Creates a plain object from a FriendData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.FriendData
             * @static
             * @param {kritor.friend.FriendData} message FriendData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.qid = "";
                    object.nick = "";
                    object.age = 0;
                    object.level = 0;
                    object.voteCnt = 0;
                    object.gender = 0;
                    object.groupId = 0;
                    object.remark = "";
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.qid != null && message.hasOwnProperty("qid"))
                    object.qid = message.qid;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.age != null && message.hasOwnProperty("age"))
                    object.age = message.age;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    object.voteCnt = message.voteCnt;
                if (message.gender != null && message.hasOwnProperty("gender"))
                    object.gender = message.gender;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = message.groupId;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    object.ext = options.bytes === String ? $util.base64.encode(message.ext, 0, message.ext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ext) : message.ext;
                    if (options.oneofs)
                        object._ext = "ext";
                }
                return object;
            };

            /**
             * Converts this FriendData to JSON.
             * @function toJSON
             * @memberof kritor.friend.FriendData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendData
             * @function getTypeUrl
             * @memberof kritor.friend.FriendData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.FriendData";
            };

            return FriendData;
        })();

        friend.FriendExt = (function() {

            /**
             * Properties of a FriendExt.
             * @memberof kritor.friend
             * @interface IFriendExt
             * @property {boolean|null} [bigVip] FriendExt bigVip
             * @property {boolean|null} [hollywoodVip] FriendExt hollywoodVip
             * @property {boolean|null} [qqVip] FriendExt qqVip
             * @property {boolean|null} [superVip] FriendExt superVip
             * @property {boolean|null} [voted] FriendExt voted
             */

            /**
             * Constructs a new FriendExt.
             * @memberof kritor.friend
             * @classdesc Represents a FriendExt.
             * @implements IFriendExt
             * @constructor
             * @param {kritor.friend.IFriendExt=} [properties] Properties to set
             */
            function FriendExt(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendExt bigVip.
             * @member {boolean|null|undefined} bigVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            FriendExt.prototype.bigVip = null;

            /**
             * FriendExt hollywoodVip.
             * @member {boolean|null|undefined} hollywoodVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            FriendExt.prototype.hollywoodVip = null;

            /**
             * FriendExt qqVip.
             * @member {boolean|null|undefined} qqVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            FriendExt.prototype.qqVip = null;

            /**
             * FriendExt superVip.
             * @member {boolean|null|undefined} superVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            FriendExt.prototype.superVip = null;

            /**
             * FriendExt voted.
             * @member {boolean|null|undefined} voted
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            FriendExt.prototype.voted = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FriendExt _bigVip.
             * @member {"bigVip"|undefined} _bigVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            Object.defineProperty(FriendExt.prototype, "_bigVip", {
                get: $util.oneOfGetter($oneOfFields = ["bigVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FriendExt _hollywoodVip.
             * @member {"hollywoodVip"|undefined} _hollywoodVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            Object.defineProperty(FriendExt.prototype, "_hollywoodVip", {
                get: $util.oneOfGetter($oneOfFields = ["hollywoodVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FriendExt _qqVip.
             * @member {"qqVip"|undefined} _qqVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            Object.defineProperty(FriendExt.prototype, "_qqVip", {
                get: $util.oneOfGetter($oneOfFields = ["qqVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FriendExt _superVip.
             * @member {"superVip"|undefined} _superVip
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            Object.defineProperty(FriendExt.prototype, "_superVip", {
                get: $util.oneOfGetter($oneOfFields = ["superVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FriendExt _voted.
             * @member {"voted"|undefined} _voted
             * @memberof kritor.friend.FriendExt
             * @instance
             */
            Object.defineProperty(FriendExt.prototype, "_voted", {
                get: $util.oneOfGetter($oneOfFields = ["voted"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FriendExt instance using the specified properties.
             * @function create
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {kritor.friend.IFriendExt=} [properties] Properties to set
             * @returns {kritor.friend.FriendExt} FriendExt instance
             */
            FriendExt.create = function create(properties) {
                return new FriendExt(properties);
            };

            /**
             * Encodes the specified FriendExt message. Does not implicitly {@link kritor.friend.FriendExt.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {kritor.friend.IFriendExt} message FriendExt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendExt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bigVip != null && Object.hasOwnProperty.call(message, "bigVip"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bigVip);
                if (message.hollywoodVip != null && Object.hasOwnProperty.call(message, "hollywoodVip"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hollywoodVip);
                if (message.qqVip != null && Object.hasOwnProperty.call(message, "qqVip"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.qqVip);
                if (message.superVip != null && Object.hasOwnProperty.call(message, "superVip"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.superVip);
                if (message.voted != null && Object.hasOwnProperty.call(message, "voted"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.voted);
                return writer;
            };

            /**
             * Encodes the specified FriendExt message, length delimited. Does not implicitly {@link kritor.friend.FriendExt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {kritor.friend.IFriendExt} message FriendExt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendExt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendExt message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.FriendExt} FriendExt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendExt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.FriendExt();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bigVip = reader.bool();
                            break;
                        }
                    case 2: {
                            message.hollywoodVip = reader.bool();
                            break;
                        }
                    case 3: {
                            message.qqVip = reader.bool();
                            break;
                        }
                    case 4: {
                            message.superVip = reader.bool();
                            break;
                        }
                    case 5: {
                            message.voted = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendExt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.FriendExt} FriendExt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendExt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendExt message.
             * @function verify
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendExt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.bigVip != null && message.hasOwnProperty("bigVip")) {
                    properties._bigVip = 1;
                    if (typeof message.bigVip !== "boolean")
                        return "bigVip: boolean expected";
                }
                if (message.hollywoodVip != null && message.hasOwnProperty("hollywoodVip")) {
                    properties._hollywoodVip = 1;
                    if (typeof message.hollywoodVip !== "boolean")
                        return "hollywoodVip: boolean expected";
                }
                if (message.qqVip != null && message.hasOwnProperty("qqVip")) {
                    properties._qqVip = 1;
                    if (typeof message.qqVip !== "boolean")
                        return "qqVip: boolean expected";
                }
                if (message.superVip != null && message.hasOwnProperty("superVip")) {
                    properties._superVip = 1;
                    if (typeof message.superVip !== "boolean")
                        return "superVip: boolean expected";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    properties._voted = 1;
                    if (typeof message.voted !== "boolean")
                        return "voted: boolean expected";
                }
                return null;
            };

            /**
             * Creates a FriendExt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.FriendExt} FriendExt
             */
            FriendExt.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.FriendExt)
                    return object;
                let message = new $root.kritor.friend.FriendExt();
                if (object.bigVip != null)
                    message.bigVip = Boolean(object.bigVip);
                if (object.hollywoodVip != null)
                    message.hollywoodVip = Boolean(object.hollywoodVip);
                if (object.qqVip != null)
                    message.qqVip = Boolean(object.qqVip);
                if (object.superVip != null)
                    message.superVip = Boolean(object.superVip);
                if (object.voted != null)
                    message.voted = Boolean(object.voted);
                return message;
            };

            /**
             * Creates a plain object from a FriendExt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {kritor.friend.FriendExt} message FriendExt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendExt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.bigVip != null && message.hasOwnProperty("bigVip")) {
                    object.bigVip = message.bigVip;
                    if (options.oneofs)
                        object._bigVip = "bigVip";
                }
                if (message.hollywoodVip != null && message.hasOwnProperty("hollywoodVip")) {
                    object.hollywoodVip = message.hollywoodVip;
                    if (options.oneofs)
                        object._hollywoodVip = "hollywoodVip";
                }
                if (message.qqVip != null && message.hasOwnProperty("qqVip")) {
                    object.qqVip = message.qqVip;
                    if (options.oneofs)
                        object._qqVip = "qqVip";
                }
                if (message.superVip != null && message.hasOwnProperty("superVip")) {
                    object.superVip = message.superVip;
                    if (options.oneofs)
                        object._superVip = "superVip";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    object.voted = message.voted;
                    if (options.oneofs)
                        object._voted = "voted";
                }
                return object;
            };

            /**
             * Converts this FriendExt to JSON.
             * @function toJSON
             * @memberof kritor.friend.FriendExt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendExt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendExt
             * @function getTypeUrl
             * @memberof kritor.friend.FriendExt
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendExt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.FriendExt";
            };

            return FriendExt;
        })();

        friend.FriendService = (function() {

            /**
             * Constructs a new FriendService service.
             * @memberof kritor.friend
             * @classdesc Represents a FriendService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function FriendService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (FriendService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FriendService;

            /**
             * Creates new FriendService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.friend.FriendService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {FriendService} RPC service. Useful where requests and/or responses are streamed.
             */
            FriendService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.friend.FriendService#getFriendList}.
             * @memberof kritor.friend.FriendService
             * @typedef GetFriendListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetFriendListResponse} [response] GetFriendListResponse
             */

            /**
             * Calls GetFriendList.
             * @function getFriendList
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendListRequest} request GetFriendListRequest message or plain object
             * @param {kritor.friend.FriendService.GetFriendListCallback} callback Node-style callback called with the error, if any, and GetFriendListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getFriendList = function getFriendList(request, callback) {
                return this.rpcCall(getFriendList, $root.kritor.friend.GetFriendListRequest, $root.kritor.friend.GetFriendListResponse, request, callback);
            }, "name", { value: "GetFriendList" });

            /**
             * Calls GetFriendList.
             * @function getFriendList
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendListRequest} request GetFriendListRequest message or plain object
             * @returns {Promise<kritor.friend.GetFriendListResponse>} Promise
             * @variation 2
             */

            return FriendService;
        })();

        friend.GetFriendListRequest = (function() {

            /**
             * Properties of a GetFriendListRequest.
             * @memberof kritor.friend
             * @interface IGetFriendListRequest
             * @property {boolean|null} [refresh] GetFriendListRequest refresh
             */

            /**
             * Constructs a new GetFriendListRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendListRequest.
             * @implements IGetFriendListRequest
             * @constructor
             * @param {kritor.friend.IGetFriendListRequest=} [properties] Properties to set
             */
            function GetFriendListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             */
            GetFriendListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetFriendListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             */
            Object.defineProperty(GetFriendListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetFriendListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest instance
             */
            GetFriendListRequest.create = function create(properties) {
                return new GetFriendListRequest(properties);
            };

            /**
             * Encodes the specified GetFriendListRequest message. Does not implicitly {@link kritor.friend.GetFriendListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest} message GetFriendListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetFriendListRequest message, length delimited. Does not implicitly {@link kritor.friend.GetFriendListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest} message GetFriendListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendListRequest message.
             * @function verify
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetFriendListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             */
            GetFriendListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendListRequest)
                    return object;
                let message = new $root.kritor.friend.GetFriendListRequest();
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetFriendListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.GetFriendListRequest} message GetFriendListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetFriendListRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendListRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendListRequest";
            };

            return GetFriendListRequest;
        })();

        friend.GetFriendListResponse = (function() {

            /**
             * Properties of a GetFriendListResponse.
             * @memberof kritor.friend
             * @interface IGetFriendListResponse
             * @property {Array.<kritor.friend.IFriendData>|null} [friendList] GetFriendListResponse friendList
             */

            /**
             * Constructs a new GetFriendListResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendListResponse.
             * @implements IGetFriendListResponse
             * @constructor
             * @param {kritor.friend.IGetFriendListResponse=} [properties] Properties to set
             */
            function GetFriendListResponse(properties) {
                this.friendList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendListResponse friendList.
             * @member {Array.<kritor.friend.IFriendData>} friendList
             * @memberof kritor.friend.GetFriendListResponse
             * @instance
             */
            GetFriendListResponse.prototype.friendList = $util.emptyArray;

            /**
             * Creates a new GetFriendListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse instance
             */
            GetFriendListResponse.create = function create(properties) {
                return new GetFriendListResponse(properties);
            };

            /**
             * Encodes the specified GetFriendListResponse message. Does not implicitly {@link kritor.friend.GetFriendListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse} message GetFriendListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.friendList != null && message.friendList.length)
                    for (let i = 0; i < message.friendList.length; ++i)
                        $root.kritor.friend.FriendData.encode(message.friendList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFriendListResponse message, length delimited. Does not implicitly {@link kritor.friend.GetFriendListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse} message GetFriendListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.friendList && message.friendList.length))
                                message.friendList = [];
                            message.friendList.push($root.kritor.friend.FriendData.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendListResponse message.
             * @function verify
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.friendList != null && message.hasOwnProperty("friendList")) {
                    if (!Array.isArray(message.friendList))
                        return "friendList: array expected";
                    for (let i = 0; i < message.friendList.length; ++i) {
                        let error = $root.kritor.friend.FriendData.verify(message.friendList[i]);
                        if (error)
                            return "friendList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFriendListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             */
            GetFriendListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendListResponse)
                    return object;
                let message = new $root.kritor.friend.GetFriendListResponse();
                if (object.friendList) {
                    if (!Array.isArray(object.friendList))
                        throw TypeError(".kritor.friend.GetFriendListResponse.friendList: array expected");
                    message.friendList = [];
                    for (let i = 0; i < object.friendList.length; ++i) {
                        if (typeof object.friendList[i] !== "object")
                            throw TypeError(".kritor.friend.GetFriendListResponse.friendList: object expected");
                        message.friendList[i] = $root.kritor.friend.FriendData.fromObject(object.friendList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.GetFriendListResponse} message GetFriendListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.friendList = [];
                if (message.friendList && message.friendList.length) {
                    object.friendList = [];
                    for (let j = 0; j < message.friendList.length; ++j)
                        object.friendList[j] = $root.kritor.friend.FriendData.toObject(message.friendList[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFriendListResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendListResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendListResponse";
            };

            return GetFriendListResponse;
        })();

        return friend;
    })();

    kritor.message = (function() {

        /**
         * Namespace message.
         * @memberof kritor
         * @namespace
         */
        const message = {};

        message.MessageBody = (function() {

            /**
             * Properties of a MessageBody.
             * @memberof kritor.message
             * @interface IMessageBody
             * @property {number|null} [time] MessageBody time
             * @property {kritor.message.Scene|null} [scene] MessageBody scene
             * @property {number|Long|null} [messageId] MessageBody messageId
             * @property {number|Long|null} [messageSeq] MessageBody messageSeq
             * @property {kritor.message.IContact|null} [contact] MessageBody contact
             * @property {kritor.message.ISender|null} [sender] MessageBody sender
             * @property {Array.<kritor.message.IElement>|null} [elements] MessageBody elements
             */

            /**
             * Constructs a new MessageBody.
             * @memberof kritor.message
             * @classdesc Represents a MessageBody.
             * @implements IMessageBody
             * @constructor
             * @param {kritor.message.IMessageBody=} [properties] Properties to set
             */
            function MessageBody(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageBody time.
             * @member {number} time
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.time = 0;

            /**
             * MessageBody scene.
             * @member {kritor.message.Scene} scene
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.scene = 0;

            /**
             * MessageBody messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MessageBody messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MessageBody contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.contact = null;

            /**
             * MessageBody sender.
             * @member {kritor.message.ISender|null|undefined} sender
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.sender = null;

            /**
             * MessageBody elements.
             * @member {Array.<kritor.message.IElement>} elements
             * @memberof kritor.message.MessageBody
             * @instance
             */
            MessageBody.prototype.elements = $util.emptyArray;

            /**
             * Creates a new MessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.message.MessageBody
             * @static
             * @param {kritor.message.IMessageBody=} [properties] Properties to set
             * @returns {kritor.message.MessageBody} MessageBody instance
             */
            MessageBody.create = function create(properties) {
                return new MessageBody(properties);
            };

            /**
             * Encodes the specified MessageBody message. Does not implicitly {@link kritor.message.MessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.MessageBody
             * @static
             * @param {kritor.message.IMessageBody} message MessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.time);
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.scene);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageId);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.messageSeq);
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    $root.kritor.message.Sender.encode(message.sender, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.message.Element.encode(message.elements[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageBody message, length delimited. Does not implicitly {@link kritor.message.MessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.MessageBody
             * @static
             * @param {kritor.message.IMessageBody} message MessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.MessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.MessageBody} MessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.MessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 3: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.sender = $root.kritor.message.Sender.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.message.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.MessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.MessageBody} MessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageBody message.
             * @function verify
             * @memberof kritor.message.MessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.sender != null && message.hasOwnProperty("sender")) {
                    let error = $root.kritor.message.Sender.verify(message.sender);
                    if (error)
                        return "sender." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.message.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.MessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.MessageBody} MessageBody
             */
            MessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.MessageBody)
                    return object;
                let message = new $root.kritor.message.MessageBody();
                if (object.time != null)
                    message.time = object.time >>> 0;
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.MessageBody.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.sender != null) {
                    if (typeof object.sender !== "object")
                        throw TypeError(".kritor.message.MessageBody.sender: object expected");
                    message.sender = $root.kritor.message.Sender.fromObject(object.sender);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.message.MessageBody.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.message.MessageBody.elements: object expected");
                        message.elements[i] = $root.kritor.message.Element.fromObject(object.elements[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.MessageBody
             * @static
             * @param {kritor.message.MessageBody} message MessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults) {
                    object.time = 0;
                    object.scene = options.enums === String ? "GROUP" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                    object.contact = null;
                    object.sender = null;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.message.Scene[message.scene] === undefined ? message.scene : $root.kritor.message.Scene[message.scene] : message.scene;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = $root.kritor.message.Sender.toObject(message.sender, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.message.Element.toObject(message.elements[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageBody to JSON.
             * @function toJSON
             * @memberof kritor.message.MessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageBody
             * @function getTypeUrl
             * @memberof kritor.message.MessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.MessageBody";
            };

            return MessageBody;
        })();

        message.Sender = (function() {

            /**
             * Properties of a Sender.
             * @memberof kritor.message
             * @interface ISender
             * @property {string|null} [nick] Sender nick
             * @property {string|null} [uid] Sender uid
             * @property {number|Long|null} [uin] Sender uin
             */

            /**
             * Constructs a new Sender.
             * @memberof kritor.message
             * @classdesc Represents a Sender.
             * @implements ISender
             * @constructor
             * @param {kritor.message.ISender=} [properties] Properties to set
             */
            function Sender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sender nick.
             * @member {string} nick
             * @memberof kritor.message.Sender
             * @instance
             */
            Sender.prototype.nick = "";

            /**
             * Sender uid.
             * @member {string} uid
             * @memberof kritor.message.Sender
             * @instance
             */
            Sender.prototype.uid = "";

            /**
             * Sender uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.message.Sender
             * @instance
             */
            Sender.prototype.uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Sender _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.message.Sender
             * @instance
             */
            Object.defineProperty(Sender.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Sender instance using the specified properties.
             * @function create
             * @memberof kritor.message.Sender
             * @static
             * @param {kritor.message.ISender=} [properties] Properties to set
             * @returns {kritor.message.Sender} Sender instance
             */
            Sender.create = function create(properties) {
                return new Sender(properties);
            };

            /**
             * Encodes the specified Sender message. Does not implicitly {@link kritor.message.Sender.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.Sender
             * @static
             * @param {kritor.message.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nick);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified Sender message, length delimited. Does not implicitly {@link kritor.message.Sender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.Sender
             * @static
             * @param {kritor.message.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.Sender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nick = reader.string();
                            break;
                        }
                    case 2: {
                            message.uid = reader.string();
                            break;
                        }
                    case 3: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sender message.
             * @function verify
             * @memberof kritor.message.Sender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a Sender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.Sender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.Sender} Sender
             */
            Sender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.Sender)
                    return object;
                let message = new $root.kritor.message.Sender();
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Sender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.Sender
             * @static
             * @param {kritor.message.Sender} message Sender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nick = "";
                    object.uid = "";
                }
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                return object;
            };

            /**
             * Converts this Sender to JSON.
             * @function toJSON
             * @memberof kritor.message.Sender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sender
             * @function getTypeUrl
             * @memberof kritor.message.Sender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.Sender";
            };

            return Sender;
        })();

        /**
         * ElementType enum.
         * @name kritor.message.ElementType
         * @enum {number}
         * @property {number} TEXT=0 TEXT value
         * @property {number} AT=1 AT value
         * @property {number} FACE=2 FACE value
         * @property {number} BUBBLE_FACE=3 BUBBLE_FACE value
         * @property {number} REPLY=4 REPLY value
         * @property {number} IMAGE=5 IMAGE value
         * @property {number} VOICE=6 VOICE value
         * @property {number} VIDEO=7 VIDEO value
         * @property {number} BASKETBALL=8 BASKETBALL value
         * @property {number} DICE=9 DICE value
         * @property {number} RPS=10 RPS value
         * @property {number} POKE=11 POKE value
         * @property {number} MUSIC=12 MUSIC value
         * @property {number} WEATHER=13 WEATHER value
         * @property {number} LOCATION=14 LOCATION value
         * @property {number} SHARE=15 SHARE value
         * @property {number} GIFT=16 GIFT value
         * @property {number} MARKET_FACE=17 MARKET_FACE value
         * @property {number} FORWARD=18 FORWARD value
         * @property {number} CONTACT=19 CONTACT value
         * @property {number} JSON=20 JSON value
         * @property {number} XML=21 XML value
         * @property {number} FILE=22 FILE value
         * @property {number} MARKDOWN=23 MARKDOWN value
         * @property {number} BUTTON=24 BUTTON value
         * @property {number} NODE=99 NODE value
         */
        message.ElementType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TEXT"] = 0;
            values[valuesById[1] = "AT"] = 1;
            values[valuesById[2] = "FACE"] = 2;
            values[valuesById[3] = "BUBBLE_FACE"] = 3;
            values[valuesById[4] = "REPLY"] = 4;
            values[valuesById[5] = "IMAGE"] = 5;
            values[valuesById[6] = "VOICE"] = 6;
            values[valuesById[7] = "VIDEO"] = 7;
            values[valuesById[8] = "BASKETBALL"] = 8;
            values[valuesById[9] = "DICE"] = 9;
            values[valuesById[10] = "RPS"] = 10;
            values[valuesById[11] = "POKE"] = 11;
            values[valuesById[12] = "MUSIC"] = 12;
            values[valuesById[13] = "WEATHER"] = 13;
            values[valuesById[14] = "LOCATION"] = 14;
            values[valuesById[15] = "SHARE"] = 15;
            values[valuesById[16] = "GIFT"] = 16;
            values[valuesById[17] = "MARKET_FACE"] = 17;
            values[valuesById[18] = "FORWARD"] = 18;
            values[valuesById[19] = "CONTACT"] = 19;
            values[valuesById[20] = "JSON"] = 20;
            values[valuesById[21] = "XML"] = 21;
            values[valuesById[22] = "FILE"] = 22;
            values[valuesById[23] = "MARKDOWN"] = 23;
            values[valuesById[24] = "BUTTON"] = 24;
            values[valuesById[99] = "NODE"] = 99;
            return values;
        })();

        message.Element = (function() {

            /**
             * Properties of an Element.
             * @memberof kritor.message
             * @interface IElement
             * @property {kritor.message.ElementType|null} [type] Element type
             * @property {kritor.message.ITextElement|null} [text] Element text
             * @property {kritor.message.IAtElement|null} [at] Element at
             * @property {kritor.message.IFaceElement|null} [face] Element face
             * @property {kritor.message.IBubbleFaceElement|null} [bubbleFace] Element bubbleFace
             * @property {kritor.message.IReplyElement|null} [reply] Element reply
             * @property {kritor.message.IImageElement|null} [image] Element image
             * @property {kritor.message.IVoiceElement|null} [voice] Element voice
             * @property {kritor.message.IVideoElement|null} [video] Element video
             * @property {kritor.message.IBasketballElement|null} [basketball] Element basketball
             * @property {kritor.message.IDiceElement|null} [dice] Element dice
             * @property {kritor.message.IRpsElement|null} [rps] Element rps
             * @property {kritor.message.IPokeElement|null} [poke] Element poke
             * @property {kritor.message.IMusicElement|null} [music] Element music
             * @property {kritor.message.IWeatherElement|null} [weather] Element weather
             * @property {kritor.message.ILocationElement|null} [location] Element location
             * @property {kritor.message.IShareElement|null} [share] Element share
             * @property {kritor.message.IGiftElement|null} [gift] Element gift
             * @property {kritor.message.IMarketFaceElement|null} [marketFace] Element marketFace
             * @property {kritor.message.IForwardElement|null} [forward] Element forward
             * @property {kritor.message.IContactElement|null} [contact] Element contact
             * @property {kritor.message.IJsonElement|null} [json] Element json
             * @property {kritor.message.IXmlElement|null} [xml] Element xml
             * @property {kritor.message.IFileElement|null} [file] Element file
             * @property {kritor.message.IMarkdownElement|null} [markdown] Element markdown
             * @property {kritor.message.IButtonElement|null} [button] Element button
             * @property {kritor.message.INodeElement|null} [node] Element node
             */

            /**
             * Constructs a new Element.
             * @memberof kritor.message
             * @classdesc Represents an Element.
             * @implements IElement
             * @constructor
             * @param {kritor.message.IElement=} [properties] Properties to set
             */
            function Element(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Element type.
             * @member {kritor.message.ElementType} type
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.type = 0;

            /**
             * Element text.
             * @member {kritor.message.ITextElement|null|undefined} text
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.text = null;

            /**
             * Element at.
             * @member {kritor.message.IAtElement|null|undefined} at
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.at = null;

            /**
             * Element face.
             * @member {kritor.message.IFaceElement|null|undefined} face
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.face = null;

            /**
             * Element bubbleFace.
             * @member {kritor.message.IBubbleFaceElement|null|undefined} bubbleFace
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.bubbleFace = null;

            /**
             * Element reply.
             * @member {kritor.message.IReplyElement|null|undefined} reply
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.reply = null;

            /**
             * Element image.
             * @member {kritor.message.IImageElement|null|undefined} image
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.image = null;

            /**
             * Element voice.
             * @member {kritor.message.IVoiceElement|null|undefined} voice
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.voice = null;

            /**
             * Element video.
             * @member {kritor.message.IVideoElement|null|undefined} video
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.video = null;

            /**
             * Element basketball.
             * @member {kritor.message.IBasketballElement|null|undefined} basketball
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.basketball = null;

            /**
             * Element dice.
             * @member {kritor.message.IDiceElement|null|undefined} dice
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.dice = null;

            /**
             * Element rps.
             * @member {kritor.message.IRpsElement|null|undefined} rps
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.rps = null;

            /**
             * Element poke.
             * @member {kritor.message.IPokeElement|null|undefined} poke
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.poke = null;

            /**
             * Element music.
             * @member {kritor.message.IMusicElement|null|undefined} music
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.music = null;

            /**
             * Element weather.
             * @member {kritor.message.IWeatherElement|null|undefined} weather
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.weather = null;

            /**
             * Element location.
             * @member {kritor.message.ILocationElement|null|undefined} location
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.location = null;

            /**
             * Element share.
             * @member {kritor.message.IShareElement|null|undefined} share
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.share = null;

            /**
             * Element gift.
             * @member {kritor.message.IGiftElement|null|undefined} gift
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.gift = null;

            /**
             * Element marketFace.
             * @member {kritor.message.IMarketFaceElement|null|undefined} marketFace
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.marketFace = null;

            /**
             * Element forward.
             * @member {kritor.message.IForwardElement|null|undefined} forward
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.forward = null;

            /**
             * Element contact.
             * @member {kritor.message.IContactElement|null|undefined} contact
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.contact = null;

            /**
             * Element json.
             * @member {kritor.message.IJsonElement|null|undefined} json
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.json = null;

            /**
             * Element xml.
             * @member {kritor.message.IXmlElement|null|undefined} xml
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.xml = null;

            /**
             * Element file.
             * @member {kritor.message.IFileElement|null|undefined} file
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.file = null;

            /**
             * Element markdown.
             * @member {kritor.message.IMarkdownElement|null|undefined} markdown
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.markdown = null;

            /**
             * Element button.
             * @member {kritor.message.IButtonElement|null|undefined} button
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.button = null;

            /**
             * Element node.
             * @member {kritor.message.INodeElement|null|undefined} node
             * @memberof kritor.message.Element
             * @instance
             */
            Element.prototype.node = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Element data.
             * @member {"text"|"at"|"face"|"bubbleFace"|"reply"|"image"|"voice"|"video"|"basketball"|"dice"|"rps"|"poke"|"music"|"weather"|"location"|"share"|"gift"|"marketFace"|"forward"|"contact"|"json"|"xml"|"file"|"markdown"|"button"|"node"|undefined} data
             * @memberof kritor.message.Element
             * @instance
             */
            Object.defineProperty(Element.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["text", "at", "face", "bubbleFace", "reply", "image", "voice", "video", "basketball", "dice", "rps", "poke", "music", "weather", "location", "share", "gift", "marketFace", "forward", "contact", "json", "xml", "file", "markdown", "button", "node"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Element instance using the specified properties.
             * @function create
             * @memberof kritor.message.Element
             * @static
             * @param {kritor.message.IElement=} [properties] Properties to set
             * @returns {kritor.message.Element} Element instance
             */
            Element.create = function create(properties) {
                return new Element(properties);
            };

            /**
             * Encodes the specified Element message. Does not implicitly {@link kritor.message.Element.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.Element
             * @static
             * @param {kritor.message.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    $root.kritor.message.TextElement.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.at != null && Object.hasOwnProperty.call(message, "at"))
                    $root.kritor.message.AtElement.encode(message.at, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                    $root.kritor.message.FaceElement.encode(message.face, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.bubbleFace != null && Object.hasOwnProperty.call(message, "bubbleFace"))
                    $root.kritor.message.BubbleFaceElement.encode(message.bubbleFace, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    $root.kritor.message.ReplyElement.encode(message.reply, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.kritor.message.ImageElement.encode(message.image, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.voice != null && Object.hasOwnProperty.call(message, "voice"))
                    $root.kritor.message.VoiceElement.encode(message.voice, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                    $root.kritor.message.VideoElement.encode(message.video, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.basketball != null && Object.hasOwnProperty.call(message, "basketball"))
                    $root.kritor.message.BasketballElement.encode(message.basketball, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.dice != null && Object.hasOwnProperty.call(message, "dice"))
                    $root.kritor.message.DiceElement.encode(message.dice, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.rps != null && Object.hasOwnProperty.call(message, "rps"))
                    $root.kritor.message.RpsElement.encode(message.rps, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.poke != null && Object.hasOwnProperty.call(message, "poke"))
                    $root.kritor.message.PokeElement.encode(message.poke, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.music != null && Object.hasOwnProperty.call(message, "music"))
                    $root.kritor.message.MusicElement.encode(message.music, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.weather != null && Object.hasOwnProperty.call(message, "weather"))
                    $root.kritor.message.WeatherElement.encode(message.weather, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.kritor.message.LocationElement.encode(message.location, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.share != null && Object.hasOwnProperty.call(message, "share"))
                    $root.kritor.message.ShareElement.encode(message.share, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.gift != null && Object.hasOwnProperty.call(message, "gift"))
                    $root.kritor.message.GiftElement.encode(message.gift, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.marketFace != null && Object.hasOwnProperty.call(message, "marketFace"))
                    $root.kritor.message.MarketFaceElement.encode(message.marketFace, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.kritor.message.ForwardElement.encode(message.forward, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.ContactElement.encode(message.contact, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    $root.kritor.message.JsonElement.encode(message.json, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    $root.kritor.message.XmlElement.encode(message.xml, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.kritor.message.FileElement.encode(message.file, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    $root.kritor.message.MarkdownElement.encode(message.markdown, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.button != null && Object.hasOwnProperty.call(message, "button"))
                    $root.kritor.message.ButtonElement.encode(message.button, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.node != null && Object.hasOwnProperty.call(message, "node"))
                    $root.kritor.message.NodeElement.encode(message.node, writer.uint32(/* id 99, wireType 2 =*/794).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Element message, length delimited. Does not implicitly {@link kritor.message.Element.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.Element
             * @static
             * @param {kritor.message.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Element message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.Element();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.text = $root.kritor.message.TextElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.at = $root.kritor.message.AtElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.face = $root.kritor.message.FaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.bubbleFace = $root.kritor.message.BubbleFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.reply = $root.kritor.message.ReplyElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.image = $root.kritor.message.ImageElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.voice = $root.kritor.message.VoiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.video = $root.kritor.message.VideoElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.basketball = $root.kritor.message.BasketballElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dice = $root.kritor.message.DiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.rps = $root.kritor.message.RpsElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.poke = $root.kritor.message.PokeElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.music = $root.kritor.message.MusicElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.weather = $root.kritor.message.WeatherElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.location = $root.kritor.message.LocationElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.share = $root.kritor.message.ShareElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.gift = $root.kritor.message.GiftElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.marketFace = $root.kritor.message.MarketFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.forward = $root.kritor.message.ForwardElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.contact = $root.kritor.message.ContactElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.json = $root.kritor.message.JsonElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.xml = $root.kritor.message.XmlElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.file = $root.kritor.message.FileElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.markdown = $root.kritor.message.MarkdownElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.button = $root.kritor.message.ButtonElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 99: {
                            message.node = $root.kritor.message.NodeElement.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Element message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Element message.
             * @function verify
             * @memberof kritor.message.Element
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Element.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 99:
                        break;
                    }
                if (message.text != null && message.hasOwnProperty("text")) {
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.TextElement.verify(message.text);
                        if (error)
                            return "text." + error;
                    }
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.AtElement.verify(message.at);
                        if (error)
                            return "at." + error;
                    }
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.FaceElement.verify(message.face);
                        if (error)
                            return "face." + error;
                    }
                }
                if (message.bubbleFace != null && message.hasOwnProperty("bubbleFace")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.BubbleFaceElement.verify(message.bubbleFace);
                        if (error)
                            return "bubbleFace." + error;
                    }
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.ReplyElement.verify(message.reply);
                        if (error)
                            return "reply." + error;
                    }
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.ImageElement.verify(message.image);
                        if (error)
                            return "image." + error;
                    }
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.VoiceElement.verify(message.voice);
                        if (error)
                            return "voice." + error;
                    }
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.VideoElement.verify(message.video);
                        if (error)
                            return "video." + error;
                    }
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.BasketballElement.verify(message.basketball);
                        if (error)
                            return "basketball." + error;
                    }
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.DiceElement.verify(message.dice);
                        if (error)
                            return "dice." + error;
                    }
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.RpsElement.verify(message.rps);
                        if (error)
                            return "rps." + error;
                    }
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.PokeElement.verify(message.poke);
                        if (error)
                            return "poke." + error;
                    }
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.MusicElement.verify(message.music);
                        if (error)
                            return "music." + error;
                    }
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.WeatherElement.verify(message.weather);
                        if (error)
                            return "weather." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.LocationElement.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.ShareElement.verify(message.share);
                        if (error)
                            return "share." + error;
                    }
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.GiftElement.verify(message.gift);
                        if (error)
                            return "gift." + error;
                    }
                }
                if (message.marketFace != null && message.hasOwnProperty("marketFace")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.MarketFaceElement.verify(message.marketFace);
                        if (error)
                            return "marketFace." + error;
                    }
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.ForwardElement.verify(message.forward);
                        if (error)
                            return "forward." + error;
                    }
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.ContactElement.verify(message.contact);
                        if (error)
                            return "contact." + error;
                    }
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.JsonElement.verify(message.json);
                        if (error)
                            return "json." + error;
                    }
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.XmlElement.verify(message.xml);
                        if (error)
                            return "xml." + error;
                    }
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.FileElement.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.MarkdownElement.verify(message.markdown);
                        if (error)
                            return "markdown." + error;
                    }
                }
                if (message.button != null && message.hasOwnProperty("button")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.ButtonElement.verify(message.button);
                        if (error)
                            return "button." + error;
                    }
                }
                if (message.node != null && message.hasOwnProperty("node")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.NodeElement.verify(message.node);
                        if (error)
                            return "node." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Element message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.Element
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.Element} Element
             */
            Element.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.Element)
                    return object;
                let message = new $root.kritor.message.Element();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TEXT":
                case 0:
                    message.type = 0;
                    break;
                case "AT":
                case 1:
                    message.type = 1;
                    break;
                case "FACE":
                case 2:
                    message.type = 2;
                    break;
                case "BUBBLE_FACE":
                case 3:
                    message.type = 3;
                    break;
                case "REPLY":
                case 4:
                    message.type = 4;
                    break;
                case "IMAGE":
                case 5:
                    message.type = 5;
                    break;
                case "VOICE":
                case 6:
                    message.type = 6;
                    break;
                case "VIDEO":
                case 7:
                    message.type = 7;
                    break;
                case "BASKETBALL":
                case 8:
                    message.type = 8;
                    break;
                case "DICE":
                case 9:
                    message.type = 9;
                    break;
                case "RPS":
                case 10:
                    message.type = 10;
                    break;
                case "POKE":
                case 11:
                    message.type = 11;
                    break;
                case "MUSIC":
                case 12:
                    message.type = 12;
                    break;
                case "WEATHER":
                case 13:
                    message.type = 13;
                    break;
                case "LOCATION":
                case 14:
                    message.type = 14;
                    break;
                case "SHARE":
                case 15:
                    message.type = 15;
                    break;
                case "GIFT":
                case 16:
                    message.type = 16;
                    break;
                case "MARKET_FACE":
                case 17:
                    message.type = 17;
                    break;
                case "FORWARD":
                case 18:
                    message.type = 18;
                    break;
                case "CONTACT":
                case 19:
                    message.type = 19;
                    break;
                case "JSON":
                case 20:
                    message.type = 20;
                    break;
                case "XML":
                case 21:
                    message.type = 21;
                    break;
                case "FILE":
                case 22:
                    message.type = 22;
                    break;
                case "MARKDOWN":
                case 23:
                    message.type = 23;
                    break;
                case "BUTTON":
                case 24:
                    message.type = 24;
                    break;
                case "NODE":
                case 99:
                    message.type = 99;
                    break;
                }
                if (object.text != null) {
                    if (typeof object.text !== "object")
                        throw TypeError(".kritor.message.Element.text: object expected");
                    message.text = $root.kritor.message.TextElement.fromObject(object.text);
                }
                if (object.at != null) {
                    if (typeof object.at !== "object")
                        throw TypeError(".kritor.message.Element.at: object expected");
                    message.at = $root.kritor.message.AtElement.fromObject(object.at);
                }
                if (object.face != null) {
                    if (typeof object.face !== "object")
                        throw TypeError(".kritor.message.Element.face: object expected");
                    message.face = $root.kritor.message.FaceElement.fromObject(object.face);
                }
                if (object.bubbleFace != null) {
                    if (typeof object.bubbleFace !== "object")
                        throw TypeError(".kritor.message.Element.bubbleFace: object expected");
                    message.bubbleFace = $root.kritor.message.BubbleFaceElement.fromObject(object.bubbleFace);
                }
                if (object.reply != null) {
                    if (typeof object.reply !== "object")
                        throw TypeError(".kritor.message.Element.reply: object expected");
                    message.reply = $root.kritor.message.ReplyElement.fromObject(object.reply);
                }
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".kritor.message.Element.image: object expected");
                    message.image = $root.kritor.message.ImageElement.fromObject(object.image);
                }
                if (object.voice != null) {
                    if (typeof object.voice !== "object")
                        throw TypeError(".kritor.message.Element.voice: object expected");
                    message.voice = $root.kritor.message.VoiceElement.fromObject(object.voice);
                }
                if (object.video != null) {
                    if (typeof object.video !== "object")
                        throw TypeError(".kritor.message.Element.video: object expected");
                    message.video = $root.kritor.message.VideoElement.fromObject(object.video);
                }
                if (object.basketball != null) {
                    if (typeof object.basketball !== "object")
                        throw TypeError(".kritor.message.Element.basketball: object expected");
                    message.basketball = $root.kritor.message.BasketballElement.fromObject(object.basketball);
                }
                if (object.dice != null) {
                    if (typeof object.dice !== "object")
                        throw TypeError(".kritor.message.Element.dice: object expected");
                    message.dice = $root.kritor.message.DiceElement.fromObject(object.dice);
                }
                if (object.rps != null) {
                    if (typeof object.rps !== "object")
                        throw TypeError(".kritor.message.Element.rps: object expected");
                    message.rps = $root.kritor.message.RpsElement.fromObject(object.rps);
                }
                if (object.poke != null) {
                    if (typeof object.poke !== "object")
                        throw TypeError(".kritor.message.Element.poke: object expected");
                    message.poke = $root.kritor.message.PokeElement.fromObject(object.poke);
                }
                if (object.music != null) {
                    if (typeof object.music !== "object")
                        throw TypeError(".kritor.message.Element.music: object expected");
                    message.music = $root.kritor.message.MusicElement.fromObject(object.music);
                }
                if (object.weather != null) {
                    if (typeof object.weather !== "object")
                        throw TypeError(".kritor.message.Element.weather: object expected");
                    message.weather = $root.kritor.message.WeatherElement.fromObject(object.weather);
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".kritor.message.Element.location: object expected");
                    message.location = $root.kritor.message.LocationElement.fromObject(object.location);
                }
                if (object.share != null) {
                    if (typeof object.share !== "object")
                        throw TypeError(".kritor.message.Element.share: object expected");
                    message.share = $root.kritor.message.ShareElement.fromObject(object.share);
                }
                if (object.gift != null) {
                    if (typeof object.gift !== "object")
                        throw TypeError(".kritor.message.Element.gift: object expected");
                    message.gift = $root.kritor.message.GiftElement.fromObject(object.gift);
                }
                if (object.marketFace != null) {
                    if (typeof object.marketFace !== "object")
                        throw TypeError(".kritor.message.Element.marketFace: object expected");
                    message.marketFace = $root.kritor.message.MarketFaceElement.fromObject(object.marketFace);
                }
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".kritor.message.Element.forward: object expected");
                    message.forward = $root.kritor.message.ForwardElement.fromObject(object.forward);
                }
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.Element.contact: object expected");
                    message.contact = $root.kritor.message.ContactElement.fromObject(object.contact);
                }
                if (object.json != null) {
                    if (typeof object.json !== "object")
                        throw TypeError(".kritor.message.Element.json: object expected");
                    message.json = $root.kritor.message.JsonElement.fromObject(object.json);
                }
                if (object.xml != null) {
                    if (typeof object.xml !== "object")
                        throw TypeError(".kritor.message.Element.xml: object expected");
                    message.xml = $root.kritor.message.XmlElement.fromObject(object.xml);
                }
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".kritor.message.Element.file: object expected");
                    message.file = $root.kritor.message.FileElement.fromObject(object.file);
                }
                if (object.markdown != null) {
                    if (typeof object.markdown !== "object")
                        throw TypeError(".kritor.message.Element.markdown: object expected");
                    message.markdown = $root.kritor.message.MarkdownElement.fromObject(object.markdown);
                }
                if (object.button != null) {
                    if (typeof object.button !== "object")
                        throw TypeError(".kritor.message.Element.button: object expected");
                    message.button = $root.kritor.message.ButtonElement.fromObject(object.button);
                }
                if (object.node != null) {
                    if (typeof object.node !== "object")
                        throw TypeError(".kritor.message.Element.node: object expected");
                    message.node = $root.kritor.message.NodeElement.fromObject(object.node);
                }
                return message;
            };

            /**
             * Creates a plain object from an Element message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.Element
             * @static
             * @param {kritor.message.Element} message Element
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Element.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "TEXT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.message.ElementType[message.type] === undefined ? message.type : $root.kritor.message.ElementType[message.type] : message.type;
                if (message.text != null && message.hasOwnProperty("text")) {
                    object.text = $root.kritor.message.TextElement.toObject(message.text, options);
                    if (options.oneofs)
                        object.data = "text";
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    object.at = $root.kritor.message.AtElement.toObject(message.at, options);
                    if (options.oneofs)
                        object.data = "at";
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    object.face = $root.kritor.message.FaceElement.toObject(message.face, options);
                    if (options.oneofs)
                        object.data = "face";
                }
                if (message.bubbleFace != null && message.hasOwnProperty("bubbleFace")) {
                    object.bubbleFace = $root.kritor.message.BubbleFaceElement.toObject(message.bubbleFace, options);
                    if (options.oneofs)
                        object.data = "bubbleFace";
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    object.reply = $root.kritor.message.ReplyElement.toObject(message.reply, options);
                    if (options.oneofs)
                        object.data = "reply";
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    object.image = $root.kritor.message.ImageElement.toObject(message.image, options);
                    if (options.oneofs)
                        object.data = "image";
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    object.voice = $root.kritor.message.VoiceElement.toObject(message.voice, options);
                    if (options.oneofs)
                        object.data = "voice";
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    object.video = $root.kritor.message.VideoElement.toObject(message.video, options);
                    if (options.oneofs)
                        object.data = "video";
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    object.basketball = $root.kritor.message.BasketballElement.toObject(message.basketball, options);
                    if (options.oneofs)
                        object.data = "basketball";
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    object.dice = $root.kritor.message.DiceElement.toObject(message.dice, options);
                    if (options.oneofs)
                        object.data = "dice";
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    object.rps = $root.kritor.message.RpsElement.toObject(message.rps, options);
                    if (options.oneofs)
                        object.data = "rps";
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    object.poke = $root.kritor.message.PokeElement.toObject(message.poke, options);
                    if (options.oneofs)
                        object.data = "poke";
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    object.music = $root.kritor.message.MusicElement.toObject(message.music, options);
                    if (options.oneofs)
                        object.data = "music";
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    object.weather = $root.kritor.message.WeatherElement.toObject(message.weather, options);
                    if (options.oneofs)
                        object.data = "weather";
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    object.location = $root.kritor.message.LocationElement.toObject(message.location, options);
                    if (options.oneofs)
                        object.data = "location";
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    object.share = $root.kritor.message.ShareElement.toObject(message.share, options);
                    if (options.oneofs)
                        object.data = "share";
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    object.gift = $root.kritor.message.GiftElement.toObject(message.gift, options);
                    if (options.oneofs)
                        object.data = "gift";
                }
                if (message.marketFace != null && message.hasOwnProperty("marketFace")) {
                    object.marketFace = $root.kritor.message.MarketFaceElement.toObject(message.marketFace, options);
                    if (options.oneofs)
                        object.data = "marketFace";
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    object.forward = $root.kritor.message.ForwardElement.toObject(message.forward, options);
                    if (options.oneofs)
                        object.data = "forward";
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    object.contact = $root.kritor.message.ContactElement.toObject(message.contact, options);
                    if (options.oneofs)
                        object.data = "contact";
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    object.json = $root.kritor.message.JsonElement.toObject(message.json, options);
                    if (options.oneofs)
                        object.data = "json";
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    object.xml = $root.kritor.message.XmlElement.toObject(message.xml, options);
                    if (options.oneofs)
                        object.data = "xml";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = $root.kritor.message.FileElement.toObject(message.file, options);
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    object.markdown = $root.kritor.message.MarkdownElement.toObject(message.markdown, options);
                    if (options.oneofs)
                        object.data = "markdown";
                }
                if (message.button != null && message.hasOwnProperty("button")) {
                    object.button = $root.kritor.message.ButtonElement.toObject(message.button, options);
                    if (options.oneofs)
                        object.data = "button";
                }
                if (message.node != null && message.hasOwnProperty("node")) {
                    object.node = $root.kritor.message.NodeElement.toObject(message.node, options);
                    if (options.oneofs)
                        object.data = "node";
                }
                return object;
            };

            /**
             * Converts this Element to JSON.
             * @function toJSON
             * @memberof kritor.message.Element
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Element.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Element
             * @function getTypeUrl
             * @memberof kritor.message.Element
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Element.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.Element";
            };

            return Element;
        })();

        message.TextElement = (function() {

            /**
             * Properties of a TextElement.
             * @memberof kritor.message
             * @interface ITextElement
             * @property {string|null} [text] TextElement text
             */

            /**
             * Constructs a new TextElement.
             * @memberof kritor.message
             * @classdesc Represents a TextElement.
             * @implements ITextElement
             * @constructor
             * @param {kritor.message.ITextElement=} [properties] Properties to set
             */
            function TextElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TextElement text.
             * @member {string} text
             * @memberof kritor.message.TextElement
             * @instance
             */
            TextElement.prototype.text = "";

            /**
             * Creates a new TextElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.TextElement
             * @static
             * @param {kritor.message.ITextElement=} [properties] Properties to set
             * @returns {kritor.message.TextElement} TextElement instance
             */
            TextElement.create = function create(properties) {
                return new TextElement(properties);
            };

            /**
             * Encodes the specified TextElement message. Does not implicitly {@link kritor.message.TextElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.TextElement
             * @static
             * @param {kritor.message.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };

            /**
             * Encodes the specified TextElement message, length delimited. Does not implicitly {@link kritor.message.TextElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.TextElement
             * @static
             * @param {kritor.message.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.TextElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.text = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TextElement message.
             * @function verify
             * @memberof kritor.message.TextElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TextElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };

            /**
             * Creates a TextElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.TextElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.TextElement} TextElement
             */
            TextElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.TextElement)
                    return object;
                let message = new $root.kritor.message.TextElement();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };

            /**
             * Creates a plain object from a TextElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.TextElement
             * @static
             * @param {kritor.message.TextElement} message TextElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TextElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };

            /**
             * Converts this TextElement to JSON.
             * @function toJSON
             * @memberof kritor.message.TextElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TextElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TextElement
             * @function getTypeUrl
             * @memberof kritor.message.TextElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TextElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.TextElement";
            };

            return TextElement;
        })();

        message.AtElement = (function() {

            /**
             * Properties of an AtElement.
             * @memberof kritor.message
             * @interface IAtElement
             * @property {number|Long|null} [uin] AtElement uin
             * @property {string|null} [uid] AtElement uid
             */

            /**
             * Constructs a new AtElement.
             * @memberof kritor.message
             * @classdesc Represents an AtElement.
             * @implements IAtElement
             * @constructor
             * @param {kritor.message.IAtElement=} [properties] Properties to set
             */
            function AtElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AtElement uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.message.AtElement
             * @instance
             */
            AtElement.prototype.uin = null;

            /**
             * AtElement uid.
             * @member {string|null|undefined} uid
             * @memberof kritor.message.AtElement
             * @instance
             */
            AtElement.prototype.uid = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AtElement account.
             * @member {"uin"|"uid"|undefined} account
             * @memberof kritor.message.AtElement
             * @instance
             */
            Object.defineProperty(AtElement.prototype, "account", {
                get: $util.oneOfGetter($oneOfFields = ["uin", "uid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AtElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.AtElement
             * @static
             * @param {kritor.message.IAtElement=} [properties] Properties to set
             * @returns {kritor.message.AtElement} AtElement instance
             */
            AtElement.create = function create(properties) {
                return new AtElement(properties);
            };

            /**
             * Encodes the specified AtElement message. Does not implicitly {@link kritor.message.AtElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.AtElement
             * @static
             * @param {kritor.message.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uin);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                return writer;
            };

            /**
             * Encodes the specified AtElement message, length delimited. Does not implicitly {@link kritor.message.AtElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.AtElement
             * @static
             * @param {kritor.message.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.AtElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.uid = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AtElement message.
             * @function verify
             * @memberof kritor.message.AtElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AtElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties.account = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                if (message.uid != null && message.hasOwnProperty("uid")) {
                    if (properties.account === 1)
                        return "account: multiple values";
                    properties.account = 1;
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                }
                return null;
            };

            /**
             * Creates an AtElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.AtElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.AtElement} AtElement
             */
            AtElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.AtElement)
                    return object;
                let message = new $root.kritor.message.AtElement();
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.uid != null)
                    message.uid = String(object.uid);
                return message;
            };

            /**
             * Creates a plain object from an AtElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.AtElement
             * @static
             * @param {kritor.message.AtElement} message AtElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AtElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object.account = "uin";
                }
                if (message.uid != null && message.hasOwnProperty("uid")) {
                    object.uid = message.uid;
                    if (options.oneofs)
                        object.account = "uid";
                }
                return object;
            };

            /**
             * Converts this AtElement to JSON.
             * @function toJSON
             * @memberof kritor.message.AtElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AtElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AtElement
             * @function getTypeUrl
             * @memberof kritor.message.AtElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AtElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.AtElement";
            };

            return AtElement;
        })();

        message.FaceElement = (function() {

            /**
             * Properties of a FaceElement.
             * @memberof kritor.message
             * @interface IFaceElement
             * @property {number|null} [id] FaceElement id
             * @property {boolean|null} [isBig] FaceElement isBig
             * @property {number|null} [result] FaceElement result
             */

            /**
             * Constructs a new FaceElement.
             * @memberof kritor.message
             * @classdesc Represents a FaceElement.
             * @implements IFaceElement
             * @constructor
             * @param {kritor.message.IFaceElement=} [properties] Properties to set
             */
            function FaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FaceElement id.
             * @member {number} id
             * @memberof kritor.message.FaceElement
             * @instance
             */
            FaceElement.prototype.id = 0;

            /**
             * FaceElement isBig.
             * @member {boolean|null|undefined} isBig
             * @memberof kritor.message.FaceElement
             * @instance
             */
            FaceElement.prototype.isBig = null;

            /**
             * FaceElement result.
             * @member {number|null|undefined} result
             * @memberof kritor.message.FaceElement
             * @instance
             */
            FaceElement.prototype.result = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FaceElement _isBig.
             * @member {"isBig"|undefined} _isBig
             * @memberof kritor.message.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_isBig", {
                get: $util.oneOfGetter($oneOfFields = ["isBig"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FaceElement _result.
             * @member {"result"|undefined} _result
             * @memberof kritor.message.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_result", {
                get: $util.oneOfGetter($oneOfFields = ["result"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.FaceElement
             * @static
             * @param {kritor.message.IFaceElement=} [properties] Properties to set
             * @returns {kritor.message.FaceElement} FaceElement instance
             */
            FaceElement.create = function create(properties) {
                return new FaceElement(properties);
            };

            /**
             * Encodes the specified FaceElement message. Does not implicitly {@link kritor.message.FaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.FaceElement
             * @static
             * @param {kritor.message.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.isBig != null && Object.hasOwnProperty.call(message, "isBig"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBig);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.result);
                return writer;
            };

            /**
             * Encodes the specified FaceElement message, length delimited. Does not implicitly {@link kritor.message.FaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.FaceElement
             * @static
             * @param {kritor.message.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.FaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.isBig = reader.bool();
                            break;
                        }
                    case 3: {
                            message.result = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FaceElement message.
             * @function verify
             * @memberof kritor.message.FaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.isBig != null && message.hasOwnProperty("isBig")) {
                    properties._isBig = 1;
                    if (typeof message.isBig !== "boolean")
                        return "isBig: boolean expected";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    properties._result = 1;
                    if (!$util.isInteger(message.result))
                        return "result: integer expected";
                }
                return null;
            };

            /**
             * Creates a FaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.FaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.FaceElement} FaceElement
             */
            FaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.FaceElement)
                    return object;
                let message = new $root.kritor.message.FaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.isBig != null)
                    message.isBig = Boolean(object.isBig);
                if (object.result != null)
                    message.result = object.result >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a FaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.FaceElement
             * @static
             * @param {kritor.message.FaceElement} message FaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.isBig != null && message.hasOwnProperty("isBig")) {
                    object.isBig = message.isBig;
                    if (options.oneofs)
                        object._isBig = "isBig";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object._result = "result";
                }
                return object;
            };

            /**
             * Converts this FaceElement to JSON.
             * @function toJSON
             * @memberof kritor.message.FaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FaceElement
             * @function getTypeUrl
             * @memberof kritor.message.FaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.FaceElement";
            };

            return FaceElement;
        })();

        message.BubbleFaceElement = (function() {

            /**
             * Properties of a BubbleFaceElement.
             * @memberof kritor.message
             * @interface IBubbleFaceElement
             * @property {number|null} [id] BubbleFaceElement id
             * @property {number|null} [count] BubbleFaceElement count
             */

            /**
             * Constructs a new BubbleFaceElement.
             * @memberof kritor.message
             * @classdesc Represents a BubbleFaceElement.
             * @implements IBubbleFaceElement
             * @constructor
             * @param {kritor.message.IBubbleFaceElement=} [properties] Properties to set
             */
            function BubbleFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BubbleFaceElement id.
             * @member {number} id
             * @memberof kritor.message.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.id = 0;

            /**
             * BubbleFaceElement count.
             * @member {number} count
             * @memberof kritor.message.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.count = 0;

            /**
             * Creates a new BubbleFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {kritor.message.IBubbleFaceElement=} [properties] Properties to set
             * @returns {kritor.message.BubbleFaceElement} BubbleFaceElement instance
             */
            BubbleFaceElement.create = function create(properties) {
                return new BubbleFaceElement(properties);
            };

            /**
             * Encodes the specified BubbleFaceElement message. Does not implicitly {@link kritor.message.BubbleFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {kritor.message.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified BubbleFaceElement message, length delimited. Does not implicitly {@link kritor.message.BubbleFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {kritor.message.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.BubbleFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BubbleFaceElement message.
             * @function verify
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BubbleFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a BubbleFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.BubbleFaceElement} BubbleFaceElement
             */
            BubbleFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.BubbleFaceElement)
                    return object;
                let message = new $root.kritor.message.BubbleFaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BubbleFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {kritor.message.BubbleFaceElement} message BubbleFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BubbleFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.count = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this BubbleFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.message.BubbleFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BubbleFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BubbleFaceElement
             * @function getTypeUrl
             * @memberof kritor.message.BubbleFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BubbleFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.BubbleFaceElement";
            };

            return BubbleFaceElement;
        })();

        message.ReplyElement = (function() {

            /**
             * Properties of a ReplyElement.
             * @memberof kritor.message
             * @interface IReplyElement
             * @property {number|Long|null} [messageId] ReplyElement messageId
             */

            /**
             * Constructs a new ReplyElement.
             * @memberof kritor.message
             * @classdesc Represents a ReplyElement.
             * @implements IReplyElement
             * @constructor
             * @param {kritor.message.IReplyElement=} [properties] Properties to set
             */
            function ReplyElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplyElement messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.ReplyElement
             * @instance
             */
            ReplyElement.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ReplyElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {kritor.message.IReplyElement=} [properties] Properties to set
             * @returns {kritor.message.ReplyElement} ReplyElement instance
             */
            ReplyElement.create = function create(properties) {
                return new ReplyElement(properties);
            };

            /**
             * Encodes the specified ReplyElement message. Does not implicitly {@link kritor.message.ReplyElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {kritor.message.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified ReplyElement message, length delimited. Does not implicitly {@link kritor.message.ReplyElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {kritor.message.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ReplyElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplyElement message.
             * @function verify
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplyElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a ReplyElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ReplyElement} ReplyElement
             */
            ReplyElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ReplyElement)
                    return object;
                let message = new $root.kritor.message.ReplyElement();
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ReplyElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {kritor.message.ReplyElement} message ReplyElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplyElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this ReplyElement to JSON.
             * @function toJSON
             * @memberof kritor.message.ReplyElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplyElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReplyElement
             * @function getTypeUrl
             * @memberof kritor.message.ReplyElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReplyElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ReplyElement";
            };

            return ReplyElement;
        })();

        /**
         * ImageType enum.
         * @name kritor.message.ImageType
         * @enum {number}
         * @property {number} COMMON=0 COMMON value
         * @property {number} ORIGIN=1 ORIGIN value
         * @property {number} FLASH=2 FLASH value
         */
        message.ImageType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COMMON"] = 0;
            values[valuesById[1] = "ORIGIN"] = 1;
            values[valuesById[2] = "FLASH"] = 2;
            return values;
        })();

        message.ImageElement = (function() {

            /**
             * Properties of an ImageElement.
             * @memberof kritor.message
             * @interface IImageElement
             * @property {string|null} [fileName] ImageElement fileName
             * @property {string|null} [filePath] ImageElement filePath
             * @property {string|null} [fileBase64] ImageElement fileBase64
             * @property {string|null} [url] ImageElement url
             * @property {number|null} [subType] ImageElement subType
             * @property {string|null} [file] ImageElement file
             * @property {kritor.message.ImageType|null} [type] ImageElement type
             */

            /**
             * Constructs a new ImageElement.
             * @memberof kritor.message
             * @classdesc Represents an ImageElement.
             * @implements IImageElement
             * @constructor
             * @param {kritor.message.IImageElement=} [properties] Properties to set
             */
            function ImageElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImageElement fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.fileName = null;

            /**
             * ImageElement filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.filePath = null;

            /**
             * ImageElement fileBase64.
             * @member {string|null|undefined} fileBase64
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.fileBase64 = null;

            /**
             * ImageElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.url = null;

            /**
             * ImageElement subType.
             * @member {number|null|undefined} subType
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.subType = null;

            /**
             * ImageElement file.
             * @member {string|null|undefined} file
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.file = null;

            /**
             * ImageElement type.
             * @member {kritor.message.ImageType|null|undefined} type
             * @memberof kritor.message.ImageElement
             * @instance
             */
            ImageElement.prototype.type = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ImageElement data.
             * @member {"fileName"|"filePath"|"fileBase64"|"url"|undefined} data
             * @memberof kritor.message.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["fileName", "filePath", "fileBase64", "url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _subType.
             * @member {"subType"|undefined} _subType
             * @memberof kritor.message.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_subType", {
                get: $util.oneOfGetter($oneOfFields = ["subType"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _file.
             * @member {"file"|undefined} _file
             * @memberof kritor.message.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_file", {
                get: $util.oneOfGetter($oneOfFields = ["file"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _type.
             * @member {"type"|undefined} _type
             * @memberof kritor.message.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_type", {
                get: $util.oneOfGetter($oneOfFields = ["type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ImageElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.ImageElement
             * @static
             * @param {kritor.message.IImageElement=} [properties] Properties to set
             * @returns {kritor.message.ImageElement} ImageElement instance
             */
            ImageElement.create = function create(properties) {
                return new ImageElement(properties);
            };

            /**
             * Encodes the specified ImageElement message. Does not implicitly {@link kritor.message.ImageElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ImageElement
             * @static
             * @param {kritor.message.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileBase64 != null && Object.hasOwnProperty.call(message, "fileBase64"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileBase64);
                if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.subType);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.file);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified ImageElement message, length delimited. Does not implicitly {@link kritor.message.ImageElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ImageElement
             * @static
             * @param {kritor.message.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ImageElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileBase64 = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    case 6: {
                            message.subType = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.file = reader.string();
                            break;
                        }
                    case 10: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImageElement message.
             * @function verify
             * @memberof kritor.message.ImageElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImageElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileBase64 != null && message.hasOwnProperty("fileBase64")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileBase64))
                        return "fileBase64: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.subType != null && message.hasOwnProperty("subType")) {
                    properties._subType = 1;
                    if (!$util.isInteger(message.subType))
                        return "subType: integer expected";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties._file = 1;
                    if (!$util.isString(message.file))
                        return "file: string expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    properties._type = 1;
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                }
                return null;
            };

            /**
             * Creates an ImageElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ImageElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ImageElement} ImageElement
             */
            ImageElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ImageElement)
                    return object;
                let message = new $root.kritor.message.ImageElement();
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileBase64 != null)
                    message.fileBase64 = String(object.fileBase64);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.subType != null)
                    message.subType = object.subType >>> 0;
                if (object.file != null)
                    message.file = String(object.file);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "COMMON":
                case 0:
                    message.type = 0;
                    break;
                case "ORIGIN":
                case 1:
                    message.type = 1;
                    break;
                case "FLASH":
                case 2:
                    message.type = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ImageElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ImageElement
             * @static
             * @param {kritor.message.ImageElement} message ImageElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object.data = "url";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileBase64 != null && message.hasOwnProperty("fileBase64")) {
                    object.fileBase64 = message.fileBase64;
                    if (options.oneofs)
                        object.data = "fileBase64";
                }
                if (message.subType != null && message.hasOwnProperty("subType")) {
                    object.subType = message.subType;
                    if (options.oneofs)
                        object._subType = "subType";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = message.file;
                    if (options.oneofs)
                        object._file = "file";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    object.type = options.enums === String ? $root.kritor.message.ImageType[message.type] === undefined ? message.type : $root.kritor.message.ImageType[message.type] : message.type;
                    if (options.oneofs)
                        object._type = "type";
                }
                return object;
            };

            /**
             * Converts this ImageElement to JSON.
             * @function toJSON
             * @memberof kritor.message.ImageElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImageElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ImageElement
             * @function getTypeUrl
             * @memberof kritor.message.ImageElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ImageElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ImageElement";
            };

            return ImageElement;
        })();

        message.VoiceElement = (function() {

            /**
             * Properties of a VoiceElement.
             * @memberof kritor.message
             * @interface IVoiceElement
             * @property {string|null} [fileName] VoiceElement fileName
             * @property {string|null} [filePath] VoiceElement filePath
             * @property {string|null} [fileBase64] VoiceElement fileBase64
             * @property {string|null} [url] VoiceElement url
             * @property {string|null} [file] VoiceElement file
             * @property {boolean|null} [magic] VoiceElement magic
             */

            /**
             * Constructs a new VoiceElement.
             * @memberof kritor.message
             * @classdesc Represents a VoiceElement.
             * @implements IVoiceElement
             * @constructor
             * @param {kritor.message.IVoiceElement=} [properties] Properties to set
             */
            function VoiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoiceElement fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            VoiceElement.prototype.fileName = null;

            /**
             * VoiceElement filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            VoiceElement.prototype.filePath = null;

            /**
             * VoiceElement fileBase64.
             * @member {string|null|undefined} fileBase64
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            VoiceElement.prototype.fileBase64 = null;

            /**
             * VoiceElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            VoiceElement.prototype.url = null;

            /**
             * VoiceElement file.
             * @member {string|null|undefined} file
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file = null;

            /**
             * VoiceElement magic.
             * @member {boolean|null|undefined} magic
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            VoiceElement.prototype.magic = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoiceElement data.
             * @member {"fileName"|"filePath"|"fileBase64"|"url"|undefined} data
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["fileName", "filePath", "fileBase64", "url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _file.
             * @member {"file"|undefined} _file
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_file", {
                get: $util.oneOfGetter($oneOfFields = ["file"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _magic.
             * @member {"magic"|undefined} _magic
             * @memberof kritor.message.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_magic", {
                get: $util.oneOfGetter($oneOfFields = ["magic"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {kritor.message.IVoiceElement=} [properties] Properties to set
             * @returns {kritor.message.VoiceElement} VoiceElement instance
             */
            VoiceElement.create = function create(properties) {
                return new VoiceElement(properties);
            };

            /**
             * Encodes the specified VoiceElement message. Does not implicitly {@link kritor.message.VoiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {kritor.message.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileBase64 != null && Object.hasOwnProperty.call(message, "fileBase64"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileBase64);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.file);
                if (message.magic != null && Object.hasOwnProperty.call(message, "magic"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.magic);
                return writer;
            };

            /**
             * Encodes the specified VoiceElement message, length delimited. Does not implicitly {@link kritor.message.VoiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {kritor.message.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.VoiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileBase64 = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    case 7: {
                            message.file = reader.string();
                            break;
                        }
                    case 10: {
                            message.magic = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoiceElement message.
             * @function verify
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileBase64 != null && message.hasOwnProperty("fileBase64")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileBase64))
                        return "fileBase64: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties._file = 1;
                    if (!$util.isString(message.file))
                        return "file: string expected";
                }
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    properties._magic = 1;
                    if (typeof message.magic !== "boolean")
                        return "magic: boolean expected";
                }
                return null;
            };

            /**
             * Creates a VoiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.VoiceElement} VoiceElement
             */
            VoiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.VoiceElement)
                    return object;
                let message = new $root.kritor.message.VoiceElement();
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileBase64 != null)
                    message.fileBase64 = String(object.fileBase64);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.file != null)
                    message.file = String(object.file);
                if (object.magic != null)
                    message.magic = Boolean(object.magic);
                return message;
            };

            /**
             * Creates a plain object from a VoiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {kritor.message.VoiceElement} message VoiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object.data = "url";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileBase64 != null && message.hasOwnProperty("fileBase64")) {
                    object.fileBase64 = message.fileBase64;
                    if (options.oneofs)
                        object.data = "fileBase64";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = message.file;
                    if (options.oneofs)
                        object._file = "file";
                }
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    object.magic = message.magic;
                    if (options.oneofs)
                        object._magic = "magic";
                }
                return object;
            };

            /**
             * Converts this VoiceElement to JSON.
             * @function toJSON
             * @memberof kritor.message.VoiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoiceElement
             * @function getTypeUrl
             * @memberof kritor.message.VoiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.VoiceElement";
            };

            return VoiceElement;
        })();

        message.VideoElement = (function() {

            /**
             * Properties of a VideoElement.
             * @memberof kritor.message
             * @interface IVideoElement
             * @property {string|null} [fileName] VideoElement fileName
             * @property {string|null} [filePath] VideoElement filePath
             * @property {string|null} [fileBase64] VideoElement fileBase64
             * @property {string|null} [url] VideoElement url
             * @property {string|null} [file] VideoElement file
             */

            /**
             * Constructs a new VideoElement.
             * @memberof kritor.message
             * @classdesc Represents a VideoElement.
             * @implements IVideoElement
             * @constructor
             * @param {kritor.message.IVideoElement=} [properties] Properties to set
             */
            function VideoElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VideoElement fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.message.VideoElement
             * @instance
             */
            VideoElement.prototype.fileName = null;

            /**
             * VideoElement filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.message.VideoElement
             * @instance
             */
            VideoElement.prototype.filePath = null;

            /**
             * VideoElement fileBase64.
             * @member {string|null|undefined} fileBase64
             * @memberof kritor.message.VideoElement
             * @instance
             */
            VideoElement.prototype.fileBase64 = null;

            /**
             * VideoElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.message.VideoElement
             * @instance
             */
            VideoElement.prototype.url = null;

            /**
             * VideoElement file.
             * @member {string|null|undefined} file
             * @memberof kritor.message.VideoElement
             * @instance
             */
            VideoElement.prototype.file = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VideoElement data.
             * @member {"fileName"|"filePath"|"fileBase64"|"url"|undefined} data
             * @memberof kritor.message.VideoElement
             * @instance
             */
            Object.defineProperty(VideoElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["fileName", "filePath", "fileBase64", "url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VideoElement _file.
             * @member {"file"|undefined} _file
             * @memberof kritor.message.VideoElement
             * @instance
             */
            Object.defineProperty(VideoElement.prototype, "_file", {
                get: $util.oneOfGetter($oneOfFields = ["file"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VideoElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.VideoElement
             * @static
             * @param {kritor.message.IVideoElement=} [properties] Properties to set
             * @returns {kritor.message.VideoElement} VideoElement instance
             */
            VideoElement.create = function create(properties) {
                return new VideoElement(properties);
            };

            /**
             * Encodes the specified VideoElement message. Does not implicitly {@link kritor.message.VideoElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.VideoElement
             * @static
             * @param {kritor.message.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileBase64 != null && Object.hasOwnProperty.call(message, "fileBase64"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileBase64);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.file);
                return writer;
            };

            /**
             * Encodes the specified VideoElement message, length delimited. Does not implicitly {@link kritor.message.VideoElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.VideoElement
             * @static
             * @param {kritor.message.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.VideoElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileBase64 = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    case 7: {
                            message.file = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VideoElement message.
             * @function verify
             * @memberof kritor.message.VideoElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VideoElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileBase64 != null && message.hasOwnProperty("fileBase64")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileBase64))
                        return "fileBase64: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties._file = 1;
                    if (!$util.isString(message.file))
                        return "file: string expected";
                }
                return null;
            };

            /**
             * Creates a VideoElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.VideoElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.VideoElement} VideoElement
             */
            VideoElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.VideoElement)
                    return object;
                let message = new $root.kritor.message.VideoElement();
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileBase64 != null)
                    message.fileBase64 = String(object.fileBase64);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.file != null)
                    message.file = String(object.file);
                return message;
            };

            /**
             * Creates a plain object from a VideoElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.VideoElement
             * @static
             * @param {kritor.message.VideoElement} message VideoElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VideoElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object.data = "url";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileBase64 != null && message.hasOwnProperty("fileBase64")) {
                    object.fileBase64 = message.fileBase64;
                    if (options.oneofs)
                        object.data = "fileBase64";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = message.file;
                    if (options.oneofs)
                        object._file = "file";
                }
                return object;
            };

            /**
             * Converts this VideoElement to JSON.
             * @function toJSON
             * @memberof kritor.message.VideoElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VideoElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VideoElement
             * @function getTypeUrl
             * @memberof kritor.message.VideoElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VideoElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.VideoElement";
            };

            return VideoElement;
        })();

        message.BasketballElement = (function() {

            /**
             * Properties of a BasketballElement.
             * @memberof kritor.message
             * @interface IBasketballElement
             * @property {number|null} [id] BasketballElement id
             */

            /**
             * Constructs a new BasketballElement.
             * @memberof kritor.message
             * @classdesc Represents a BasketballElement.
             * @implements IBasketballElement
             * @constructor
             * @param {kritor.message.IBasketballElement=} [properties] Properties to set
             */
            function BasketballElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BasketballElement id.
             * @member {number} id
             * @memberof kritor.message.BasketballElement
             * @instance
             */
            BasketballElement.prototype.id = 0;

            /**
             * Creates a new BasketballElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {kritor.message.IBasketballElement=} [properties] Properties to set
             * @returns {kritor.message.BasketballElement} BasketballElement instance
             */
            BasketballElement.create = function create(properties) {
                return new BasketballElement(properties);
            };

            /**
             * Encodes the specified BasketballElement message. Does not implicitly {@link kritor.message.BasketballElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {kritor.message.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified BasketballElement message, length delimited. Does not implicitly {@link kritor.message.BasketballElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {kritor.message.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.BasketballElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BasketballElement message.
             * @function verify
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BasketballElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a BasketballElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.BasketballElement} BasketballElement
             */
            BasketballElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.BasketballElement)
                    return object;
                let message = new $root.kritor.message.BasketballElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BasketballElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {kritor.message.BasketballElement} message BasketballElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BasketballElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this BasketballElement to JSON.
             * @function toJSON
             * @memberof kritor.message.BasketballElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BasketballElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BasketballElement
             * @function getTypeUrl
             * @memberof kritor.message.BasketballElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BasketballElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.BasketballElement";
            };

            return BasketballElement;
        })();

        message.DiceElement = (function() {

            /**
             * Properties of a DiceElement.
             * @memberof kritor.message
             * @interface IDiceElement
             * @property {number|null} [id] DiceElement id
             */

            /**
             * Constructs a new DiceElement.
             * @memberof kritor.message
             * @classdesc Represents a DiceElement.
             * @implements IDiceElement
             * @constructor
             * @param {kritor.message.IDiceElement=} [properties] Properties to set
             */
            function DiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiceElement id.
             * @member {number} id
             * @memberof kritor.message.DiceElement
             * @instance
             */
            DiceElement.prototype.id = 0;

            /**
             * Creates a new DiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.DiceElement
             * @static
             * @param {kritor.message.IDiceElement=} [properties] Properties to set
             * @returns {kritor.message.DiceElement} DiceElement instance
             */
            DiceElement.create = function create(properties) {
                return new DiceElement(properties);
            };

            /**
             * Encodes the specified DiceElement message. Does not implicitly {@link kritor.message.DiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DiceElement
             * @static
             * @param {kritor.message.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified DiceElement message, length delimited. Does not implicitly {@link kritor.message.DiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DiceElement
             * @static
             * @param {kritor.message.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiceElement message.
             * @function verify
             * @memberof kritor.message.DiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a DiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DiceElement} DiceElement
             */
            DiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DiceElement)
                    return object;
                let message = new $root.kritor.message.DiceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DiceElement
             * @static
             * @param {kritor.message.DiceElement} message DiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DiceElement to JSON.
             * @function toJSON
             * @memberof kritor.message.DiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DiceElement
             * @function getTypeUrl
             * @memberof kritor.message.DiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DiceElement";
            };

            return DiceElement;
        })();

        message.RpsElement = (function() {

            /**
             * Properties of a RpsElement.
             * @memberof kritor.message
             * @interface IRpsElement
             * @property {number|null} [id] RpsElement id
             */

            /**
             * Constructs a new RpsElement.
             * @memberof kritor.message
             * @classdesc Represents a RpsElement.
             * @implements IRpsElement
             * @constructor
             * @param {kritor.message.IRpsElement=} [properties] Properties to set
             */
            function RpsElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RpsElement id.
             * @member {number} id
             * @memberof kritor.message.RpsElement
             * @instance
             */
            RpsElement.prototype.id = 0;

            /**
             * Creates a new RpsElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.RpsElement
             * @static
             * @param {kritor.message.IRpsElement=} [properties] Properties to set
             * @returns {kritor.message.RpsElement} RpsElement instance
             */
            RpsElement.create = function create(properties) {
                return new RpsElement(properties);
            };

            /**
             * Encodes the specified RpsElement message. Does not implicitly {@link kritor.message.RpsElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RpsElement
             * @static
             * @param {kritor.message.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified RpsElement message, length delimited. Does not implicitly {@link kritor.message.RpsElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RpsElement
             * @static
             * @param {kritor.message.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RpsElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RpsElement message.
             * @function verify
             * @memberof kritor.message.RpsElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RpsElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a RpsElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RpsElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RpsElement} RpsElement
             */
            RpsElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RpsElement)
                    return object;
                let message = new $root.kritor.message.RpsElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RpsElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RpsElement
             * @static
             * @param {kritor.message.RpsElement} message RpsElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RpsElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this RpsElement to JSON.
             * @function toJSON
             * @memberof kritor.message.RpsElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RpsElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RpsElement
             * @function getTypeUrl
             * @memberof kritor.message.RpsElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RpsElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RpsElement";
            };

            return RpsElement;
        })();

        message.PokeElement = (function() {

            /**
             * Properties of a PokeElement.
             * @memberof kritor.message
             * @interface IPokeElement
             * @property {number|null} [id] PokeElement id
             * @property {number|null} [type] PokeElement type
             * @property {number|null} [strength] PokeElement strength
             */

            /**
             * Constructs a new PokeElement.
             * @memberof kritor.message
             * @classdesc Represents a PokeElement.
             * @implements IPokeElement
             * @constructor
             * @param {kritor.message.IPokeElement=} [properties] Properties to set
             */
            function PokeElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeElement id.
             * @member {number} id
             * @memberof kritor.message.PokeElement
             * @instance
             */
            PokeElement.prototype.id = 0;

            /**
             * PokeElement type.
             * @member {number} type
             * @memberof kritor.message.PokeElement
             * @instance
             */
            PokeElement.prototype.type = 0;

            /**
             * PokeElement strength.
             * @member {number} strength
             * @memberof kritor.message.PokeElement
             * @instance
             */
            PokeElement.prototype.strength = 0;

            /**
             * Creates a new PokeElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.PokeElement
             * @static
             * @param {kritor.message.IPokeElement=} [properties] Properties to set
             * @returns {kritor.message.PokeElement} PokeElement instance
             */
            PokeElement.create = function create(properties) {
                return new PokeElement(properties);
            };

            /**
             * Encodes the specified PokeElement message. Does not implicitly {@link kritor.message.PokeElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.PokeElement
             * @static
             * @param {kritor.message.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
                if (message.strength != null && Object.hasOwnProperty.call(message, "strength"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.strength);
                return writer;
            };

            /**
             * Encodes the specified PokeElement message, length delimited. Does not implicitly {@link kritor.message.PokeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.PokeElement
             * @static
             * @param {kritor.message.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.PokeElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.strength = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeElement message.
             * @function verify
             * @memberof kritor.message.PokeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.strength != null && message.hasOwnProperty("strength"))
                    if (!$util.isInteger(message.strength))
                        return "strength: integer expected";
                return null;
            };

            /**
             * Creates a PokeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.PokeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.PokeElement} PokeElement
             */
            PokeElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.PokeElement)
                    return object;
                let message = new $root.kritor.message.PokeElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.strength != null)
                    message.strength = object.strength >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a PokeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.PokeElement
             * @static
             * @param {kritor.message.PokeElement} message PokeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.type = 0;
                    object.strength = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.strength != null && message.hasOwnProperty("strength"))
                    object.strength = message.strength;
                return object;
            };

            /**
             * Converts this PokeElement to JSON.
             * @function toJSON
             * @memberof kritor.message.PokeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeElement
             * @function getTypeUrl
             * @memberof kritor.message.PokeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.PokeElement";
            };

            return PokeElement;
        })();

        /**
         * MusicPlatform enum.
         * @name kritor.message.MusicPlatform
         * @enum {number}
         * @property {number} QQ=0 QQ value
         * @property {number} NetEase=1 NetEase value
         * @property {number} Custom=10 Custom value
         */
        message.MusicPlatform = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "QQ"] = 0;
            values[valuesById[1] = "NetEase"] = 1;
            values[valuesById[10] = "Custom"] = 10;
            return values;
        })();

        message.CustomMusicData = (function() {

            /**
             * Properties of a CustomMusicData.
             * @memberof kritor.message
             * @interface ICustomMusicData
             * @property {string|null} [url] CustomMusicData url
             * @property {string|null} [audio] CustomMusicData audio
             * @property {string|null} [title] CustomMusicData title
             * @property {string|null} [author] CustomMusicData author
             * @property {string|null} [pic] CustomMusicData pic
             */

            /**
             * Constructs a new CustomMusicData.
             * @memberof kritor.message
             * @classdesc Represents a CustomMusicData.
             * @implements ICustomMusicData
             * @constructor
             * @param {kritor.message.ICustomMusicData=} [properties] Properties to set
             */
            function CustomMusicData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomMusicData url.
             * @member {string} url
             * @memberof kritor.message.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.url = "";

            /**
             * CustomMusicData audio.
             * @member {string} audio
             * @memberof kritor.message.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.audio = "";

            /**
             * CustomMusicData title.
             * @member {string} title
             * @memberof kritor.message.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.title = "";

            /**
             * CustomMusicData author.
             * @member {string} author
             * @memberof kritor.message.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.author = "";

            /**
             * CustomMusicData pic.
             * @member {string} pic
             * @memberof kritor.message.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.pic = "";

            /**
             * Creates a new CustomMusicData instance using the specified properties.
             * @function create
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {kritor.message.ICustomMusicData=} [properties] Properties to set
             * @returns {kritor.message.CustomMusicData} CustomMusicData instance
             */
            CustomMusicData.create = function create(properties) {
                return new CustomMusicData(properties);
            };

            /**
             * Encodes the specified CustomMusicData message. Does not implicitly {@link kritor.message.CustomMusicData.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {kritor.message.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.audio);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.author);
                if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.pic);
                return writer;
            };

            /**
             * Encodes the specified CustomMusicData message, length delimited. Does not implicitly {@link kritor.message.CustomMusicData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {kritor.message.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.CustomMusicData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.audio = reader.string();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.author = reader.string();
                            break;
                        }
                    case 5: {
                            message.pic = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomMusicData message.
             * @function verify
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomMusicData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.audio != null && message.hasOwnProperty("audio"))
                    if (!$util.isString(message.audio))
                        return "audio: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.author != null && message.hasOwnProperty("author"))
                    if (!$util.isString(message.author))
                        return "author: string expected";
                if (message.pic != null && message.hasOwnProperty("pic"))
                    if (!$util.isString(message.pic))
                        return "pic: string expected";
                return null;
            };

            /**
             * Creates a CustomMusicData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.CustomMusicData} CustomMusicData
             */
            CustomMusicData.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.CustomMusicData)
                    return object;
                let message = new $root.kritor.message.CustomMusicData();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.audio != null)
                    message.audio = String(object.audio);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.author != null)
                    message.author = String(object.author);
                if (object.pic != null)
                    message.pic = String(object.pic);
                return message;
            };

            /**
             * Creates a plain object from a CustomMusicData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {kritor.message.CustomMusicData} message CustomMusicData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomMusicData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.audio = "";
                    object.title = "";
                    object.author = "";
                    object.pic = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.audio != null && message.hasOwnProperty("audio"))
                    object.audio = message.audio;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.author != null && message.hasOwnProperty("author"))
                    object.author = message.author;
                if (message.pic != null && message.hasOwnProperty("pic"))
                    object.pic = message.pic;
                return object;
            };

            /**
             * Converts this CustomMusicData to JSON.
             * @function toJSON
             * @memberof kritor.message.CustomMusicData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomMusicData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CustomMusicData
             * @function getTypeUrl
             * @memberof kritor.message.CustomMusicData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CustomMusicData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.CustomMusicData";
            };

            return CustomMusicData;
        })();

        message.MusicElement = (function() {

            /**
             * Properties of a MusicElement.
             * @memberof kritor.message
             * @interface IMusicElement
             * @property {kritor.message.MusicPlatform|null} [platform] MusicElement platform
             * @property {string|null} [id] MusicElement id
             * @property {kritor.message.ICustomMusicData|null} [custom] MusicElement custom
             */

            /**
             * Constructs a new MusicElement.
             * @memberof kritor.message
             * @classdesc Represents a MusicElement.
             * @implements IMusicElement
             * @constructor
             * @param {kritor.message.IMusicElement=} [properties] Properties to set
             */
            function MusicElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MusicElement platform.
             * @member {kritor.message.MusicPlatform} platform
             * @memberof kritor.message.MusicElement
             * @instance
             */
            MusicElement.prototype.platform = 0;

            /**
             * MusicElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.message.MusicElement
             * @instance
             */
            MusicElement.prototype.id = null;

            /**
             * MusicElement custom.
             * @member {kritor.message.ICustomMusicData|null|undefined} custom
             * @memberof kritor.message.MusicElement
             * @instance
             */
            MusicElement.prototype.custom = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MusicElement data.
             * @member {"id"|"custom"|undefined} data
             * @memberof kritor.message.MusicElement
             * @instance
             */
            Object.defineProperty(MusicElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["id", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MusicElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.MusicElement
             * @static
             * @param {kritor.message.IMusicElement=} [properties] Properties to set
             * @returns {kritor.message.MusicElement} MusicElement instance
             */
            MusicElement.create = function create(properties) {
                return new MusicElement(properties);
            };

            /**
             * Encodes the specified MusicElement message. Does not implicitly {@link kritor.message.MusicElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.MusicElement
             * @static
             * @param {kritor.message.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
                    $root.kritor.message.CustomMusicData.encode(message.custom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MusicElement message, length delimited. Does not implicitly {@link kritor.message.MusicElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.MusicElement
             * @static
             * @param {kritor.message.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.MusicElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.platform = reader.int32();
                            break;
                        }
                    case 2: {
                            message.id = reader.string();
                            break;
                        }
                    case 3: {
                            message.custom = $root.kritor.message.CustomMusicData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MusicElement message.
             * @function verify
             * @memberof kritor.message.MusicElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MusicElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 10:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties.data = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.message.CustomMusicData.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MusicElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.MusicElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.MusicElement} MusicElement
             */
            MusicElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.MusicElement)
                    return object;
                let message = new $root.kritor.message.MusicElement();
                switch (object.platform) {
                default:
                    if (typeof object.platform === "number") {
                        message.platform = object.platform;
                        break;
                    }
                    break;
                case "QQ":
                case 0:
                    message.platform = 0;
                    break;
                case "NetEase":
                case 1:
                    message.platform = 1;
                    break;
                case "Custom":
                case 10:
                    message.platform = 10;
                    break;
                }
                if (object.id != null)
                    message.id = String(object.id);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".kritor.message.MusicElement.custom: object expected");
                    message.custom = $root.kritor.message.CustomMusicData.fromObject(object.custom);
                }
                return message;
            };

            /**
             * Creates a plain object from a MusicElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.MusicElement
             * @static
             * @param {kritor.message.MusicElement} message MusicElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MusicElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.platform = options.enums === String ? "QQ" : 0;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.kritor.message.MusicPlatform[message.platform] === undefined ? message.platform : $root.kritor.message.MusicPlatform[message.platform] : message.platform;
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object.data = "id";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.kritor.message.CustomMusicData.toObject(message.custom, options);
                    if (options.oneofs)
                        object.data = "custom";
                }
                return object;
            };

            /**
             * Converts this MusicElement to JSON.
             * @function toJSON
             * @memberof kritor.message.MusicElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MusicElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MusicElement
             * @function getTypeUrl
             * @memberof kritor.message.MusicElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MusicElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.MusicElement";
            };

            return MusicElement;
        })();

        message.WeatherElement = (function() {

            /**
             * Properties of a WeatherElement.
             * @memberof kritor.message
             * @interface IWeatherElement
             * @property {string|null} [city] WeatherElement city
             * @property {string|null} [code] WeatherElement code
             */

            /**
             * Constructs a new WeatherElement.
             * @memberof kritor.message
             * @classdesc Represents a WeatherElement.
             * @implements IWeatherElement
             * @constructor
             * @param {kritor.message.IWeatherElement=} [properties] Properties to set
             */
            function WeatherElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeatherElement city.
             * @member {string} city
             * @memberof kritor.message.WeatherElement
             * @instance
             */
            WeatherElement.prototype.city = "";

            /**
             * WeatherElement code.
             * @member {string} code
             * @memberof kritor.message.WeatherElement
             * @instance
             */
            WeatherElement.prototype.code = "";

            /**
             * Creates a new WeatherElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {kritor.message.IWeatherElement=} [properties] Properties to set
             * @returns {kritor.message.WeatherElement} WeatherElement instance
             */
            WeatherElement.create = function create(properties) {
                return new WeatherElement(properties);
            };

            /**
             * Encodes the specified WeatherElement message. Does not implicitly {@link kritor.message.WeatherElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {kritor.message.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.city);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
                return writer;
            };

            /**
             * Encodes the specified WeatherElement message, length delimited. Does not implicitly {@link kritor.message.WeatherElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {kritor.message.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.WeatherElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.city = reader.string();
                            break;
                        }
                    case 2: {
                            message.code = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeatherElement message.
             * @function verify
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeatherElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.city != null && message.hasOwnProperty("city"))
                    if (!$util.isString(message.city))
                        return "city: string expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                return null;
            };

            /**
             * Creates a WeatherElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.WeatherElement} WeatherElement
             */
            WeatherElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.WeatherElement)
                    return object;
                let message = new $root.kritor.message.WeatherElement();
                if (object.city != null)
                    message.city = String(object.city);
                if (object.code != null)
                    message.code = String(object.code);
                return message;
            };

            /**
             * Creates a plain object from a WeatherElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {kritor.message.WeatherElement} message WeatherElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WeatherElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.city = "";
                    object.code = "";
                }
                if (message.city != null && message.hasOwnProperty("city"))
                    object.city = message.city;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                return object;
            };

            /**
             * Converts this WeatherElement to JSON.
             * @function toJSON
             * @memberof kritor.message.WeatherElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WeatherElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WeatherElement
             * @function getTypeUrl
             * @memberof kritor.message.WeatherElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WeatherElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.WeatherElement";
            };

            return WeatherElement;
        })();

        message.LocationElement = (function() {

            /**
             * Properties of a LocationElement.
             * @memberof kritor.message
             * @interface ILocationElement
             * @property {number|null} [lat] LocationElement lat
             * @property {number|null} [lon] LocationElement lon
             * @property {string|null} [title] LocationElement title
             * @property {string|null} [address] LocationElement address
             */

            /**
             * Constructs a new LocationElement.
             * @memberof kritor.message
             * @classdesc Represents a LocationElement.
             * @implements ILocationElement
             * @constructor
             * @param {kritor.message.ILocationElement=} [properties] Properties to set
             */
            function LocationElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationElement lat.
             * @member {number} lat
             * @memberof kritor.message.LocationElement
             * @instance
             */
            LocationElement.prototype.lat = 0;

            /**
             * LocationElement lon.
             * @member {number} lon
             * @memberof kritor.message.LocationElement
             * @instance
             */
            LocationElement.prototype.lon = 0;

            /**
             * LocationElement title.
             * @member {string} title
             * @memberof kritor.message.LocationElement
             * @instance
             */
            LocationElement.prototype.title = "";

            /**
             * LocationElement address.
             * @member {string} address
             * @memberof kritor.message.LocationElement
             * @instance
             */
            LocationElement.prototype.address = "";

            /**
             * Creates a new LocationElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.LocationElement
             * @static
             * @param {kritor.message.ILocationElement=} [properties] Properties to set
             * @returns {kritor.message.LocationElement} LocationElement instance
             */
            LocationElement.create = function create(properties) {
                return new LocationElement(properties);
            };

            /**
             * Encodes the specified LocationElement message. Does not implicitly {@link kritor.message.LocationElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.LocationElement
             * @static
             * @param {kritor.message.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.lat);
                if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.lon);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified LocationElement message, length delimited. Does not implicitly {@link kritor.message.LocationElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.LocationElement
             * @static
             * @param {kritor.message.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.LocationElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.lat = reader.float();
                            break;
                        }
                    case 2: {
                            message.lon = reader.float();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.address = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationElement message.
             * @function verify
             * @memberof kritor.message.LocationElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lat != null && message.hasOwnProperty("lat"))
                    if (typeof message.lat !== "number")
                        return "lat: number expected";
                if (message.lon != null && message.hasOwnProperty("lon"))
                    if (typeof message.lon !== "number")
                        return "lon: number expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a LocationElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.LocationElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.LocationElement} LocationElement
             */
            LocationElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.LocationElement)
                    return object;
                let message = new $root.kritor.message.LocationElement();
                if (object.lat != null)
                    message.lat = Number(object.lat);
                if (object.lon != null)
                    message.lon = Number(object.lon);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a LocationElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.LocationElement
             * @static
             * @param {kritor.message.LocationElement} message LocationElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lat = 0;
                    object.lon = 0;
                    object.title = "";
                    object.address = "";
                }
                if (message.lat != null && message.hasOwnProperty("lat"))
                    object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
                if (message.lon != null && message.hasOwnProperty("lon"))
                    object.lon = options.json && !isFinite(message.lon) ? String(message.lon) : message.lon;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this LocationElement to JSON.
             * @function toJSON
             * @memberof kritor.message.LocationElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocationElement
             * @function getTypeUrl
             * @memberof kritor.message.LocationElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocationElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.LocationElement";
            };

            return LocationElement;
        })();

        message.ShareElement = (function() {

            /**
             * Properties of a ShareElement.
             * @memberof kritor.message
             * @interface IShareElement
             * @property {string|null} [url] ShareElement url
             * @property {string|null} [title] ShareElement title
             * @property {string|null} [content] ShareElement content
             * @property {string|null} [image] ShareElement image
             */

            /**
             * Constructs a new ShareElement.
             * @memberof kritor.message
             * @classdesc Represents a ShareElement.
             * @implements IShareElement
             * @constructor
             * @param {kritor.message.IShareElement=} [properties] Properties to set
             */
            function ShareElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShareElement url.
             * @member {string} url
             * @memberof kritor.message.ShareElement
             * @instance
             */
            ShareElement.prototype.url = "";

            /**
             * ShareElement title.
             * @member {string} title
             * @memberof kritor.message.ShareElement
             * @instance
             */
            ShareElement.prototype.title = "";

            /**
             * ShareElement content.
             * @member {string} content
             * @memberof kritor.message.ShareElement
             * @instance
             */
            ShareElement.prototype.content = "";

            /**
             * ShareElement image.
             * @member {string} image
             * @memberof kritor.message.ShareElement
             * @instance
             */
            ShareElement.prototype.image = "";

            /**
             * Creates a new ShareElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.ShareElement
             * @static
             * @param {kritor.message.IShareElement=} [properties] Properties to set
             * @returns {kritor.message.ShareElement} ShareElement instance
             */
            ShareElement.create = function create(properties) {
                return new ShareElement(properties);
            };

            /**
             * Encodes the specified ShareElement message. Does not implicitly {@link kritor.message.ShareElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ShareElement
             * @static
             * @param {kritor.message.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.image);
                return writer;
            };

            /**
             * Encodes the specified ShareElement message, length delimited. Does not implicitly {@link kritor.message.ShareElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ShareElement
             * @static
             * @param {kritor.message.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ShareElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.content = reader.string();
                            break;
                        }
                    case 4: {
                            message.image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShareElement message.
             * @function verify
             * @memberof kritor.message.ShareElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShareElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                if (message.image != null && message.hasOwnProperty("image"))
                    if (!$util.isString(message.image))
                        return "image: string expected";
                return null;
            };

            /**
             * Creates a ShareElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ShareElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ShareElement} ShareElement
             */
            ShareElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ShareElement)
                    return object;
                let message = new $root.kritor.message.ShareElement();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.content != null)
                    message.content = String(object.content);
                if (object.image != null)
                    message.image = String(object.image);
                return message;
            };

            /**
             * Creates a plain object from a ShareElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ShareElement
             * @static
             * @param {kritor.message.ShareElement} message ShareElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShareElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.title = "";
                    object.content = "";
                    object.image = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = message.image;
                return object;
            };

            /**
             * Converts this ShareElement to JSON.
             * @function toJSON
             * @memberof kritor.message.ShareElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShareElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShareElement
             * @function getTypeUrl
             * @memberof kritor.message.ShareElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShareElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ShareElement";
            };

            return ShareElement;
        })();

        message.GiftElement = (function() {

            /**
             * Properties of a GiftElement.
             * @memberof kritor.message
             * @interface IGiftElement
             * @property {number|Long|null} [qq] GiftElement qq
             * @property {number|null} [id] GiftElement id
             */

            /**
             * Constructs a new GiftElement.
             * @memberof kritor.message
             * @classdesc Represents a GiftElement.
             * @implements IGiftElement
             * @constructor
             * @param {kritor.message.IGiftElement=} [properties] Properties to set
             */
            function GiftElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GiftElement qq.
             * @member {number|Long} qq
             * @memberof kritor.message.GiftElement
             * @instance
             */
            GiftElement.prototype.qq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GiftElement id.
             * @member {number} id
             * @memberof kritor.message.GiftElement
             * @instance
             */
            GiftElement.prototype.id = 0;

            /**
             * Creates a new GiftElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.GiftElement
             * @static
             * @param {kritor.message.IGiftElement=} [properties] Properties to set
             * @returns {kritor.message.GiftElement} GiftElement instance
             */
            GiftElement.create = function create(properties) {
                return new GiftElement(properties);
            };

            /**
             * Encodes the specified GiftElement message. Does not implicitly {@link kritor.message.GiftElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GiftElement
             * @static
             * @param {kritor.message.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.qq != null && Object.hasOwnProperty.call(message, "qq"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.qq);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified GiftElement message, length delimited. Does not implicitly {@link kritor.message.GiftElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GiftElement
             * @static
             * @param {kritor.message.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GiftElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.qq = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GiftElement message.
             * @function verify
             * @memberof kritor.message.GiftElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GiftElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (!$util.isInteger(message.qq) && !(message.qq && $util.isInteger(message.qq.low) && $util.isInteger(message.qq.high)))
                        return "qq: integer|Long expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a GiftElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GiftElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GiftElement} GiftElement
             */
            GiftElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GiftElement)
                    return object;
                let message = new $root.kritor.message.GiftElement();
                if (object.qq != null)
                    if ($util.Long)
                        (message.qq = $util.Long.fromValue(object.qq)).unsigned = true;
                    else if (typeof object.qq === "string")
                        message.qq = parseInt(object.qq, 10);
                    else if (typeof object.qq === "number")
                        message.qq = object.qq;
                    else if (typeof object.qq === "object")
                        message.qq = new $util.LongBits(object.qq.low >>> 0, object.qq.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GiftElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GiftElement
             * @static
             * @param {kritor.message.GiftElement} message GiftElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GiftElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.qq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.qq = options.longs === String ? "0" : 0;
                    object.id = 0;
                }
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (typeof message.qq === "number")
                        object.qq = options.longs === String ? String(message.qq) : message.qq;
                    else
                        object.qq = options.longs === String ? $util.Long.prototype.toString.call(message.qq) : options.longs === Number ? new $util.LongBits(message.qq.low >>> 0, message.qq.high >>> 0).toNumber(true) : message.qq;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GiftElement to JSON.
             * @function toJSON
             * @memberof kritor.message.GiftElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GiftElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GiftElement
             * @function getTypeUrl
             * @memberof kritor.message.GiftElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GiftElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GiftElement";
            };

            return GiftElement;
        })();

        message.MarketFaceElement = (function() {

            /**
             * Properties of a MarketFaceElement.
             * @memberof kritor.message
             * @interface IMarketFaceElement
             * @property {string|null} [id] MarketFaceElement id
             */

            /**
             * Constructs a new MarketFaceElement.
             * @memberof kritor.message
             * @classdesc Represents a MarketFaceElement.
             * @implements IMarketFaceElement
             * @constructor
             * @param {kritor.message.IMarketFaceElement=} [properties] Properties to set
             */
            function MarketFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarketFaceElement id.
             * @member {string} id
             * @memberof kritor.message.MarketFaceElement
             * @instance
             */
            MarketFaceElement.prototype.id = "";

            /**
             * Creates a new MarketFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {kritor.message.IMarketFaceElement=} [properties] Properties to set
             * @returns {kritor.message.MarketFaceElement} MarketFaceElement instance
             */
            MarketFaceElement.create = function create(properties) {
                return new MarketFaceElement(properties);
            };

            /**
             * Encodes the specified MarketFaceElement message. Does not implicitly {@link kritor.message.MarketFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {kritor.message.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified MarketFaceElement message, length delimited. Does not implicitly {@link kritor.message.MarketFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {kritor.message.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.MarketFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarketFaceElement message.
             * @function verify
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarketFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a MarketFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.MarketFaceElement} MarketFaceElement
             */
            MarketFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.MarketFaceElement)
                    return object;
                let message = new $root.kritor.message.MarketFaceElement();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a MarketFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {kritor.message.MarketFaceElement} message MarketFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarketFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this MarketFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.message.MarketFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarketFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarketFaceElement
             * @function getTypeUrl
             * @memberof kritor.message.MarketFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarketFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.MarketFaceElement";
            };

            return MarketFaceElement;
        })();

        message.ForwardElement = (function() {

            /**
             * Properties of a ForwardElement.
             * @memberof kritor.message
             * @interface IForwardElement
             * @property {string|null} [id] ForwardElement id
             * @property {string|null} [uniseq] ForwardElement uniseq
             * @property {string|null} [summary] ForwardElement summary
             * @property {string|null} [description] ForwardElement description
             */

            /**
             * Constructs a new ForwardElement.
             * @memberof kritor.message
             * @classdesc Represents a ForwardElement.
             * @implements IForwardElement
             * @constructor
             * @param {kritor.message.IForwardElement=} [properties] Properties to set
             */
            function ForwardElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardElement id.
             * @member {string} id
             * @memberof kritor.message.ForwardElement
             * @instance
             */
            ForwardElement.prototype.id = "";

            /**
             * ForwardElement uniseq.
             * @member {string} uniseq
             * @memberof kritor.message.ForwardElement
             * @instance
             */
            ForwardElement.prototype.uniseq = "";

            /**
             * ForwardElement summary.
             * @member {string} summary
             * @memberof kritor.message.ForwardElement
             * @instance
             */
            ForwardElement.prototype.summary = "";

            /**
             * ForwardElement description.
             * @member {string} description
             * @memberof kritor.message.ForwardElement
             * @instance
             */
            ForwardElement.prototype.description = "";

            /**
             * Creates a new ForwardElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {kritor.message.IForwardElement=} [properties] Properties to set
             * @returns {kritor.message.ForwardElement} ForwardElement instance
             */
            ForwardElement.create = function create(properties) {
                return new ForwardElement(properties);
            };

            /**
             * Encodes the specified ForwardElement message. Does not implicitly {@link kritor.message.ForwardElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {kritor.message.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.uniseq != null && Object.hasOwnProperty.call(message, "uniseq"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uniseq);
                if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.summary);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified ForwardElement message, length delimited. Does not implicitly {@link kritor.message.ForwardElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {kritor.message.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ForwardElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.uniseq = reader.string();
                            break;
                        }
                    case 3: {
                            message.summary = reader.string();
                            break;
                        }
                    case 4: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardElement message.
             * @function verify
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    if (!$util.isString(message.uniseq))
                        return "uniseq: string expected";
                if (message.summary != null && message.hasOwnProperty("summary"))
                    if (!$util.isString(message.summary))
                        return "summary: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a ForwardElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ForwardElement} ForwardElement
             */
            ForwardElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ForwardElement)
                    return object;
                let message = new $root.kritor.message.ForwardElement();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.uniseq != null)
                    message.uniseq = String(object.uniseq);
                if (object.summary != null)
                    message.summary = String(object.summary);
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a ForwardElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {kritor.message.ForwardElement} message ForwardElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.uniseq = "";
                    object.summary = "";
                    object.description = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    object.uniseq = message.uniseq;
                if (message.summary != null && message.hasOwnProperty("summary"))
                    object.summary = message.summary;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this ForwardElement to JSON.
             * @function toJSON
             * @memberof kritor.message.ForwardElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardElement
             * @function getTypeUrl
             * @memberof kritor.message.ForwardElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ForwardElement";
            };

            return ForwardElement;
        })();

        message.ContactElement = (function() {

            /**
             * Properties of a ContactElement.
             * @memberof kritor.message
             * @interface IContactElement
             * @property {kritor.message.Scene|null} [scene] ContactElement scene
             * @property {string|null} [peer] ContactElement peer
             */

            /**
             * Constructs a new ContactElement.
             * @memberof kritor.message
             * @classdesc Represents a ContactElement.
             * @implements IContactElement
             * @constructor
             * @param {kritor.message.IContactElement=} [properties] Properties to set
             */
            function ContactElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactElement scene.
             * @member {kritor.message.Scene} scene
             * @memberof kritor.message.ContactElement
             * @instance
             */
            ContactElement.prototype.scene = 0;

            /**
             * ContactElement peer.
             * @member {string} peer
             * @memberof kritor.message.ContactElement
             * @instance
             */
            ContactElement.prototype.peer = "";

            /**
             * Creates a new ContactElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.ContactElement
             * @static
             * @param {kritor.message.IContactElement=} [properties] Properties to set
             * @returns {kritor.message.ContactElement} ContactElement instance
             */
            ContactElement.create = function create(properties) {
                return new ContactElement(properties);
            };

            /**
             * Encodes the specified ContactElement message. Does not implicitly {@link kritor.message.ContactElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ContactElement
             * @static
             * @param {kritor.message.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                return writer;
            };

            /**
             * Encodes the specified ContactElement message, length delimited. Does not implicitly {@link kritor.message.ContactElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ContactElement
             * @static
             * @param {kritor.message.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ContactElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactElement message.
             * @function verify
             * @memberof kritor.message.ContactElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                return null;
            };

            /**
             * Creates a ContactElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ContactElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ContactElement} ContactElement
             */
            ContactElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ContactElement)
                    return object;
                let message = new $root.kritor.message.ContactElement();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                return message;
            };

            /**
             * Creates a plain object from a ContactElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ContactElement
             * @static
             * @param {kritor.message.ContactElement} message ContactElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.message.Scene[message.scene] === undefined ? message.scene : $root.kritor.message.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                return object;
            };

            /**
             * Converts this ContactElement to JSON.
             * @function toJSON
             * @memberof kritor.message.ContactElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ContactElement
             * @function getTypeUrl
             * @memberof kritor.message.ContactElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ContactElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ContactElement";
            };

            return ContactElement;
        })();

        message.JsonElement = (function() {

            /**
             * Properties of a JsonElement.
             * @memberof kritor.message
             * @interface IJsonElement
             * @property {string|null} [json] JsonElement json
             */

            /**
             * Constructs a new JsonElement.
             * @memberof kritor.message
             * @classdesc Represents a JsonElement.
             * @implements IJsonElement
             * @constructor
             * @param {kritor.message.IJsonElement=} [properties] Properties to set
             */
            function JsonElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JsonElement json.
             * @member {string} json
             * @memberof kritor.message.JsonElement
             * @instance
             */
            JsonElement.prototype.json = "";

            /**
             * Creates a new JsonElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.JsonElement
             * @static
             * @param {kritor.message.IJsonElement=} [properties] Properties to set
             * @returns {kritor.message.JsonElement} JsonElement instance
             */
            JsonElement.create = function create(properties) {
                return new JsonElement(properties);
            };

            /**
             * Encodes the specified JsonElement message. Does not implicitly {@link kritor.message.JsonElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.JsonElement
             * @static
             * @param {kritor.message.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
                return writer;
            };

            /**
             * Encodes the specified JsonElement message, length delimited. Does not implicitly {@link kritor.message.JsonElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.JsonElement
             * @static
             * @param {kritor.message.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.JsonElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.json = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JsonElement message.
             * @function verify
             * @memberof kritor.message.JsonElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JsonElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.json != null && message.hasOwnProperty("json"))
                    if (!$util.isString(message.json))
                        return "json: string expected";
                return null;
            };

            /**
             * Creates a JsonElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.JsonElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.JsonElement} JsonElement
             */
            JsonElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.JsonElement)
                    return object;
                let message = new $root.kritor.message.JsonElement();
                if (object.json != null)
                    message.json = String(object.json);
                return message;
            };

            /**
             * Creates a plain object from a JsonElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.JsonElement
             * @static
             * @param {kritor.message.JsonElement} message JsonElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JsonElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.json = "";
                if (message.json != null && message.hasOwnProperty("json"))
                    object.json = message.json;
                return object;
            };

            /**
             * Converts this JsonElement to JSON.
             * @function toJSON
             * @memberof kritor.message.JsonElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JsonElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JsonElement
             * @function getTypeUrl
             * @memberof kritor.message.JsonElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JsonElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.JsonElement";
            };

            return JsonElement;
        })();

        message.XmlElement = (function() {

            /**
             * Properties of a XmlElement.
             * @memberof kritor.message
             * @interface IXmlElement
             * @property {string|null} [xml] XmlElement xml
             */

            /**
             * Constructs a new XmlElement.
             * @memberof kritor.message
             * @classdesc Represents a XmlElement.
             * @implements IXmlElement
             * @constructor
             * @param {kritor.message.IXmlElement=} [properties] Properties to set
             */
            function XmlElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * XmlElement xml.
             * @member {string} xml
             * @memberof kritor.message.XmlElement
             * @instance
             */
            XmlElement.prototype.xml = "";

            /**
             * Creates a new XmlElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.XmlElement
             * @static
             * @param {kritor.message.IXmlElement=} [properties] Properties to set
             * @returns {kritor.message.XmlElement} XmlElement instance
             */
            XmlElement.create = function create(properties) {
                return new XmlElement(properties);
            };

            /**
             * Encodes the specified XmlElement message. Does not implicitly {@link kritor.message.XmlElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.XmlElement
             * @static
             * @param {kritor.message.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.xml);
                return writer;
            };

            /**
             * Encodes the specified XmlElement message, length delimited. Does not implicitly {@link kritor.message.XmlElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.XmlElement
             * @static
             * @param {kritor.message.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.XmlElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.xml = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a XmlElement message.
             * @function verify
             * @memberof kritor.message.XmlElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            XmlElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    if (!$util.isString(message.xml))
                        return "xml: string expected";
                return null;
            };

            /**
             * Creates a XmlElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.XmlElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.XmlElement} XmlElement
             */
            XmlElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.XmlElement)
                    return object;
                let message = new $root.kritor.message.XmlElement();
                if (object.xml != null)
                    message.xml = String(object.xml);
                return message;
            };

            /**
             * Creates a plain object from a XmlElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.XmlElement
             * @static
             * @param {kritor.message.XmlElement} message XmlElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            XmlElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.xml = "";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    object.xml = message.xml;
                return object;
            };

            /**
             * Converts this XmlElement to JSON.
             * @function toJSON
             * @memberof kritor.message.XmlElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            XmlElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for XmlElement
             * @function getTypeUrl
             * @memberof kritor.message.XmlElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            XmlElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.XmlElement";
            };

            return XmlElement;
        })();

        message.FileElement = (function() {

            /**
             * Properties of a FileElement.
             * @memberof kritor.message
             * @interface IFileElement
             * @property {string|null} [name] FileElement name
             * @property {number|Long|null} [size] FileElement size
             * @property {number|Long|null} [expireTime] FileElement expireTime
             * @property {string|null} [id] FileElement id
             * @property {string|null} [url] FileElement url
             * @property {number|null} [biz] FileElement biz
             * @property {string|null} [subId] FileElement subId
             */

            /**
             * Constructs a new FileElement.
             * @memberof kritor.message
             * @classdesc Represents a FileElement.
             * @implements IFileElement
             * @constructor
             * @param {kritor.message.IFileElement=} [properties] Properties to set
             */
            function FileElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileElement name.
             * @member {string|null|undefined} name
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.name = null;

            /**
             * FileElement size.
             * @member {number|Long|null|undefined} size
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.size = null;

            /**
             * FileElement expireTime.
             * @member {number|Long|null|undefined} expireTime
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.expireTime = null;

            /**
             * FileElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.id = null;

            /**
             * FileElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.url = null;

            /**
             * FileElement biz.
             * @member {number|null|undefined} biz
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.biz = null;

            /**
             * FileElement subId.
             * @member {string|null|undefined} subId
             * @memberof kritor.message.FileElement
             * @instance
             */
            FileElement.prototype.subId = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FileElement _name.
             * @member {"name"|undefined} _name
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_name", {
                get: $util.oneOfGetter($oneOfFields = ["name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _size.
             * @member {"size"|undefined} _size
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_size", {
                get: $util.oneOfGetter($oneOfFields = ["size"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _expireTime.
             * @member {"expireTime"|undefined} _expireTime
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_expireTime", {
                get: $util.oneOfGetter($oneOfFields = ["expireTime"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _id.
             * @member {"id"|undefined} _id
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_id", {
                get: $util.oneOfGetter($oneOfFields = ["id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _biz.
             * @member {"biz"|undefined} _biz
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_biz", {
                get: $util.oneOfGetter($oneOfFields = ["biz"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _subId.
             * @member {"subId"|undefined} _subId
             * @memberof kritor.message.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_subId", {
                get: $util.oneOfGetter($oneOfFields = ["subId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FileElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.FileElement
             * @static
             * @param {kritor.message.IFileElement=} [properties] Properties to set
             * @returns {kritor.message.FileElement} FileElement instance
             */
            FileElement.create = function create(properties) {
                return new FileElement(properties);
            };

            /**
             * Encodes the specified FileElement message. Does not implicitly {@link kritor.message.FileElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.FileElement
             * @static
             * @param {kritor.message.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.size);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.expireTime);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.id);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.biz);
                if (message.subId != null && Object.hasOwnProperty.call(message, "subId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.subId);
                return writer;
            };

            /**
             * Encodes the specified FileElement message, length delimited. Does not implicitly {@link kritor.message.FileElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.FileElement
             * @static
             * @param {kritor.message.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.FileElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.size = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.expireTime = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.id = reader.string();
                            break;
                        }
                    case 5: {
                            message.url = reader.string();
                            break;
                        }
                    case 6: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 7: {
                            message.subId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileElement message.
             * @function verify
             * @memberof kritor.message.FileElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    properties._name = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    properties._size = 1;
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                }
                if (message.expireTime != null && message.hasOwnProperty("expireTime")) {
                    properties._expireTime = 1;
                    if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                        return "expireTime: integer|Long expected";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties._id = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.biz != null && message.hasOwnProperty("biz")) {
                    properties._biz = 1;
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                }
                if (message.subId != null && message.hasOwnProperty("subId")) {
                    properties._subId = 1;
                    if (!$util.isString(message.subId))
                        return "subId: string expected";
                }
                return null;
            };

            /**
             * Creates a FileElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.FileElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.FileElement} FileElement
             */
            FileElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.FileElement)
                    return object;
                let message = new $root.kritor.message.FileElement();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    if ($util.Long)
                        (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = true;
                    else if (typeof object.expireTime === "string")
                        message.expireTime = parseInt(object.expireTime, 10);
                    else if (typeof object.expireTime === "number")
                        message.expireTime = object.expireTime;
                    else if (typeof object.expireTime === "object")
                        message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.subId != null)
                    message.subId = String(object.subId);
                return message;
            };

            /**
             * Creates a plain object from a FileElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.FileElement
             * @static
             * @param {kritor.message.FileElement} message FileElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object._name = "name";
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
                    if (options.oneofs)
                        object._size = "size";
                }
                if (message.expireTime != null && message.hasOwnProperty("expireTime")) {
                    if (typeof message.expireTime === "number")
                        object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                    else
                        object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber(true) : message.expireTime;
                    if (options.oneofs)
                        object._expireTime = "expireTime";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object._id = "id";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.biz != null && message.hasOwnProperty("biz")) {
                    object.biz = message.biz;
                    if (options.oneofs)
                        object._biz = "biz";
                }
                if (message.subId != null && message.hasOwnProperty("subId")) {
                    object.subId = message.subId;
                    if (options.oneofs)
                        object._subId = "subId";
                }
                return object;
            };

            /**
             * Converts this FileElement to JSON.
             * @function toJSON
             * @memberof kritor.message.FileElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileElement
             * @function getTypeUrl
             * @memberof kritor.message.FileElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.FileElement";
            };

            return FileElement;
        })();

        message.MarkdownElement = (function() {

            /**
             * Properties of a MarkdownElement.
             * @memberof kritor.message
             * @interface IMarkdownElement
             * @property {string|null} [markdown] MarkdownElement markdown
             */

            /**
             * Constructs a new MarkdownElement.
             * @memberof kritor.message
             * @classdesc Represents a MarkdownElement.
             * @implements IMarkdownElement
             * @constructor
             * @param {kritor.message.IMarkdownElement=} [properties] Properties to set
             */
            function MarkdownElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarkdownElement markdown.
             * @member {string} markdown
             * @memberof kritor.message.MarkdownElement
             * @instance
             */
            MarkdownElement.prototype.markdown = "";

            /**
             * Creates a new MarkdownElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {kritor.message.IMarkdownElement=} [properties] Properties to set
             * @returns {kritor.message.MarkdownElement} MarkdownElement instance
             */
            MarkdownElement.create = function create(properties) {
                return new MarkdownElement(properties);
            };

            /**
             * Encodes the specified MarkdownElement message. Does not implicitly {@link kritor.message.MarkdownElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {kritor.message.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.markdown);
                return writer;
            };

            /**
             * Encodes the specified MarkdownElement message, length delimited. Does not implicitly {@link kritor.message.MarkdownElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {kritor.message.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.MarkdownElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.markdown = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarkdownElement message.
             * @function verify
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarkdownElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    if (!$util.isString(message.markdown))
                        return "markdown: string expected";
                return null;
            };

            /**
             * Creates a MarkdownElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.MarkdownElement} MarkdownElement
             */
            MarkdownElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.MarkdownElement)
                    return object;
                let message = new $root.kritor.message.MarkdownElement();
                if (object.markdown != null)
                    message.markdown = String(object.markdown);
                return message;
            };

            /**
             * Creates a plain object from a MarkdownElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {kritor.message.MarkdownElement} message MarkdownElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarkdownElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.markdown = "";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    object.markdown = message.markdown;
                return object;
            };

            /**
             * Converts this MarkdownElement to JSON.
             * @function toJSON
             * @memberof kritor.message.MarkdownElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarkdownElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarkdownElement
             * @function getTypeUrl
             * @memberof kritor.message.MarkdownElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarkdownElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.MarkdownElement";
            };

            return MarkdownElement;
        })();

        message.ButtonActionPermission = (function() {

            /**
             * Properties of a ButtonActionPermission.
             * @memberof kritor.message
             * @interface IButtonActionPermission
             * @property {number|null} [type] ButtonActionPermission type
             * @property {Array.<string>|null} [roleIds] ButtonActionPermission roleIds
             * @property {Array.<string>|null} [userIds] ButtonActionPermission userIds
             */

            /**
             * Constructs a new ButtonActionPermission.
             * @memberof kritor.message
             * @classdesc Represents a ButtonActionPermission.
             * @implements IButtonActionPermission
             * @constructor
             * @param {kritor.message.IButtonActionPermission=} [properties] Properties to set
             */
            function ButtonActionPermission(properties) {
                this.roleIds = [];
                this.userIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonActionPermission type.
             * @member {number} type
             * @memberof kritor.message.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.type = 0;

            /**
             * ButtonActionPermission roleIds.
             * @member {Array.<string>} roleIds
             * @memberof kritor.message.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.roleIds = $util.emptyArray;

            /**
             * ButtonActionPermission userIds.
             * @member {Array.<string>} userIds
             * @memberof kritor.message.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.userIds = $util.emptyArray;

            /**
             * Creates a new ButtonActionPermission instance using the specified properties.
             * @function create
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {kritor.message.IButtonActionPermission=} [properties] Properties to set
             * @returns {kritor.message.ButtonActionPermission} ButtonActionPermission instance
             */
            ButtonActionPermission.create = function create(properties) {
                return new ButtonActionPermission(properties);
            };

            /**
             * Encodes the specified ButtonActionPermission message. Does not implicitly {@link kritor.message.ButtonActionPermission.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {kritor.message.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.roleIds != null && message.roleIds.length)
                    for (let i = 0; i < message.roleIds.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleIds[i]);
                if (message.userIds != null && message.userIds.length)
                    for (let i = 0; i < message.userIds.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.userIds[i]);
                return writer;
            };

            /**
             * Encodes the specified ButtonActionPermission message, length delimited. Does not implicitly {@link kritor.message.ButtonActionPermission.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {kritor.message.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ButtonActionPermission();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            if (!(message.roleIds && message.roleIds.length))
                                message.roleIds = [];
                            message.roleIds.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.userIds && message.userIds.length))
                                message.userIds = [];
                            message.userIds.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonActionPermission message.
             * @function verify
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonActionPermission.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.roleIds != null && message.hasOwnProperty("roleIds")) {
                    if (!Array.isArray(message.roleIds))
                        return "roleIds: array expected";
                    for (let i = 0; i < message.roleIds.length; ++i)
                        if (!$util.isString(message.roleIds[i]))
                            return "roleIds: string[] expected";
                }
                if (message.userIds != null && message.hasOwnProperty("userIds")) {
                    if (!Array.isArray(message.userIds))
                        return "userIds: array expected";
                    for (let i = 0; i < message.userIds.length; ++i)
                        if (!$util.isString(message.userIds[i]))
                            return "userIds: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ButtonActionPermission message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ButtonActionPermission} ButtonActionPermission
             */
            ButtonActionPermission.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ButtonActionPermission)
                    return object;
                let message = new $root.kritor.message.ButtonActionPermission();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.roleIds) {
                    if (!Array.isArray(object.roleIds))
                        throw TypeError(".kritor.message.ButtonActionPermission.roleIds: array expected");
                    message.roleIds = [];
                    for (let i = 0; i < object.roleIds.length; ++i)
                        message.roleIds[i] = String(object.roleIds[i]);
                }
                if (object.userIds) {
                    if (!Array.isArray(object.userIds))
                        throw TypeError(".kritor.message.ButtonActionPermission.userIds: array expected");
                    message.userIds = [];
                    for (let i = 0; i < object.userIds.length; ++i)
                        message.userIds[i] = String(object.userIds[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonActionPermission message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {kritor.message.ButtonActionPermission} message ButtonActionPermission
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonActionPermission.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.roleIds = [];
                    object.userIds = [];
                }
                if (options.defaults)
                    object.type = 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.roleIds && message.roleIds.length) {
                    object.roleIds = [];
                    for (let j = 0; j < message.roleIds.length; ++j)
                        object.roleIds[j] = message.roleIds[j];
                }
                if (message.userIds && message.userIds.length) {
                    object.userIds = [];
                    for (let j = 0; j < message.userIds.length; ++j)
                        object.userIds[j] = message.userIds[j];
                }
                return object;
            };

            /**
             * Converts this ButtonActionPermission to JSON.
             * @function toJSON
             * @memberof kritor.message.ButtonActionPermission
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonActionPermission.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonActionPermission
             * @function getTypeUrl
             * @memberof kritor.message.ButtonActionPermission
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonActionPermission.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ButtonActionPermission";
            };

            return ButtonActionPermission;
        })();

        message.ButtonAction = (function() {

            /**
             * Properties of a ButtonAction.
             * @memberof kritor.message
             * @interface IButtonAction
             * @property {number|null} [type] ButtonAction type
             * @property {kritor.message.IButtonActionPermission|null} [permission] ButtonAction permission
             * @property {string|null} [unsupportedTips] ButtonAction unsupportedTips
             * @property {string|null} [data] ButtonAction data
             * @property {boolean|null} [reply] ButtonAction reply
             * @property {boolean|null} [enter] ButtonAction enter
             */

            /**
             * Constructs a new ButtonAction.
             * @memberof kritor.message
             * @classdesc Represents a ButtonAction.
             * @implements IButtonAction
             * @constructor
             * @param {kritor.message.IButtonAction=} [properties] Properties to set
             */
            function ButtonAction(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonAction type.
             * @member {number} type
             * @memberof kritor.message.ButtonAction
             * @instance
             */
            ButtonAction.prototype.type = 0;

            /**
             * ButtonAction permission.
             * @member {kritor.message.IButtonActionPermission|null|undefined} permission
             * @memberof kritor.message.ButtonAction
             * @instance
             */
            ButtonAction.prototype.permission = null;

            /**
             * ButtonAction unsupportedTips.
             * @member {string} unsupportedTips
             * @memberof kritor.message.ButtonAction
             * @instance
             */
            ButtonAction.prototype.unsupportedTips = "";

            /**
             * ButtonAction data.
             * @member {string} data
             * @memberof kritor.message.ButtonAction
             * @instance
             */
            ButtonAction.prototype.data = "";

            /**
             * ButtonAction reply.
             * @member {boolean} reply
             * @memberof kritor.message.ButtonAction
             * @instance
             */
            ButtonAction.prototype.reply = false;

            /**
             * ButtonAction enter.
             * @member {boolean} enter
             * @memberof kritor.message.ButtonAction
             * @instance
             */
            ButtonAction.prototype.enter = false;

            /**
             * Creates a new ButtonAction instance using the specified properties.
             * @function create
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {kritor.message.IButtonAction=} [properties] Properties to set
             * @returns {kritor.message.ButtonAction} ButtonAction instance
             */
            ButtonAction.create = function create(properties) {
                return new ButtonAction(properties);
            };

            /**
             * Encodes the specified ButtonAction message. Does not implicitly {@link kritor.message.ButtonAction.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {kritor.message.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    $root.kritor.message.ButtonActionPermission.encode(message.permission, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.unsupportedTips != null && Object.hasOwnProperty.call(message, "unsupportedTips"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.unsupportedTips);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.data);
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reply);
                if (message.enter != null && Object.hasOwnProperty.call(message, "enter"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enter);
                return writer;
            };

            /**
             * Encodes the specified ButtonAction message, length delimited. Does not implicitly {@link kritor.message.ButtonAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {kritor.message.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ButtonAction();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.permission = $root.kritor.message.ButtonActionPermission.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.unsupportedTips = reader.string();
                            break;
                        }
                    case 4: {
                            message.data = reader.string();
                            break;
                        }
                    case 5: {
                            message.reply = reader.bool();
                            break;
                        }
                    case 6: {
                            message.enter = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonAction message.
             * @function verify
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.permission != null && message.hasOwnProperty("permission")) {
                    let error = $root.kritor.message.ButtonActionPermission.verify(message.permission);
                    if (error)
                        return "permission." + error;
                }
                if (message.unsupportedTips != null && message.hasOwnProperty("unsupportedTips"))
                    if (!$util.isString(message.unsupportedTips))
                        return "unsupportedTips: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.reply != null && message.hasOwnProperty("reply"))
                    if (typeof message.reply !== "boolean")
                        return "reply: boolean expected";
                if (message.enter != null && message.hasOwnProperty("enter"))
                    if (typeof message.enter !== "boolean")
                        return "enter: boolean expected";
                return null;
            };

            /**
             * Creates a ButtonAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ButtonAction} ButtonAction
             */
            ButtonAction.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ButtonAction)
                    return object;
                let message = new $root.kritor.message.ButtonAction();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.permission != null) {
                    if (typeof object.permission !== "object")
                        throw TypeError(".kritor.message.ButtonAction.permission: object expected");
                    message.permission = $root.kritor.message.ButtonActionPermission.fromObject(object.permission);
                }
                if (object.unsupportedTips != null)
                    message.unsupportedTips = String(object.unsupportedTips);
                if (object.data != null)
                    message.data = String(object.data);
                if (object.reply != null)
                    message.reply = Boolean(object.reply);
                if (object.enter != null)
                    message.enter = Boolean(object.enter);
                return message;
            };

            /**
             * Creates a plain object from a ButtonAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {kritor.message.ButtonAction} message ButtonAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.permission = null;
                    object.unsupportedTips = "";
                    object.data = "";
                    object.reply = false;
                    object.enter = false;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = $root.kritor.message.ButtonActionPermission.toObject(message.permission, options);
                if (message.unsupportedTips != null && message.hasOwnProperty("unsupportedTips"))
                    object.unsupportedTips = message.unsupportedTips;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.reply != null && message.hasOwnProperty("reply"))
                    object.reply = message.reply;
                if (message.enter != null && message.hasOwnProperty("enter"))
                    object.enter = message.enter;
                return object;
            };

            /**
             * Converts this ButtonAction to JSON.
             * @function toJSON
             * @memberof kritor.message.ButtonAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonAction
             * @function getTypeUrl
             * @memberof kritor.message.ButtonAction
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ButtonAction";
            };

            return ButtonAction;
        })();

        message.ButtonRender = (function() {

            /**
             * Properties of a ButtonRender.
             * @memberof kritor.message
             * @interface IButtonRender
             * @property {string|null} [label] ButtonRender label
             * @property {string|null} [visitedLabel] ButtonRender visitedLabel
             * @property {number|null} [style] ButtonRender style
             */

            /**
             * Constructs a new ButtonRender.
             * @memberof kritor.message
             * @classdesc Represents a ButtonRender.
             * @implements IButtonRender
             * @constructor
             * @param {kritor.message.IButtonRender=} [properties] Properties to set
             */
            function ButtonRender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonRender label.
             * @member {string} label
             * @memberof kritor.message.ButtonRender
             * @instance
             */
            ButtonRender.prototype.label = "";

            /**
             * ButtonRender visitedLabel.
             * @member {string} visitedLabel
             * @memberof kritor.message.ButtonRender
             * @instance
             */
            ButtonRender.prototype.visitedLabel = "";

            /**
             * ButtonRender style.
             * @member {number} style
             * @memberof kritor.message.ButtonRender
             * @instance
             */
            ButtonRender.prototype.style = 0;

            /**
             * Creates a new ButtonRender instance using the specified properties.
             * @function create
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {kritor.message.IButtonRender=} [properties] Properties to set
             * @returns {kritor.message.ButtonRender} ButtonRender instance
             */
            ButtonRender.create = function create(properties) {
                return new ButtonRender(properties);
            };

            /**
             * Encodes the specified ButtonRender message. Does not implicitly {@link kritor.message.ButtonRender.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {kritor.message.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                if (message.visitedLabel != null && Object.hasOwnProperty.call(message, "visitedLabel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.visitedLabel);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                return writer;
            };

            /**
             * Encodes the specified ButtonRender message, length delimited. Does not implicitly {@link kritor.message.ButtonRender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {kritor.message.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ButtonRender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.label = reader.string();
                            break;
                        }
                    case 2: {
                            message.visitedLabel = reader.string();
                            break;
                        }
                    case 3: {
                            message.style = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonRender message.
             * @function verify
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonRender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.visitedLabel != null && message.hasOwnProperty("visitedLabel"))
                    if (!$util.isString(message.visitedLabel))
                        return "visitedLabel: string expected";
                if (message.style != null && message.hasOwnProperty("style"))
                    if (!$util.isInteger(message.style))
                        return "style: integer expected";
                return null;
            };

            /**
             * Creates a ButtonRender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ButtonRender} ButtonRender
             */
            ButtonRender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ButtonRender)
                    return object;
                let message = new $root.kritor.message.ButtonRender();
                if (object.label != null)
                    message.label = String(object.label);
                if (object.visitedLabel != null)
                    message.visitedLabel = String(object.visitedLabel);
                if (object.style != null)
                    message.style = object.style | 0;
                return message;
            };

            /**
             * Creates a plain object from a ButtonRender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {kritor.message.ButtonRender} message ButtonRender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonRender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.label = "";
                    object.visitedLabel = "";
                    object.style = 0;
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.visitedLabel != null && message.hasOwnProperty("visitedLabel"))
                    object.visitedLabel = message.visitedLabel;
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = message.style;
                return object;
            };

            /**
             * Converts this ButtonRender to JSON.
             * @function toJSON
             * @memberof kritor.message.ButtonRender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonRender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonRender
             * @function getTypeUrl
             * @memberof kritor.message.ButtonRender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonRender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ButtonRender";
            };

            return ButtonRender;
        })();

        message.Button = (function() {

            /**
             * Properties of a Button.
             * @memberof kritor.message
             * @interface IButton
             * @property {string|null} [id] Button id
             * @property {kritor.message.IButtonRender|null} [renderData] Button renderData
             * @property {kritor.message.IButtonAction|null} [action] Button action
             */

            /**
             * Constructs a new Button.
             * @memberof kritor.message
             * @classdesc Represents a Button.
             * @implements IButton
             * @constructor
             * @param {kritor.message.IButton=} [properties] Properties to set
             */
            function Button(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Button id.
             * @member {string} id
             * @memberof kritor.message.Button
             * @instance
             */
            Button.prototype.id = "";

            /**
             * Button renderData.
             * @member {kritor.message.IButtonRender|null|undefined} renderData
             * @memberof kritor.message.Button
             * @instance
             */
            Button.prototype.renderData = null;

            /**
             * Button action.
             * @member {kritor.message.IButtonAction|null|undefined} action
             * @memberof kritor.message.Button
             * @instance
             */
            Button.prototype.action = null;

            /**
             * Creates a new Button instance using the specified properties.
             * @function create
             * @memberof kritor.message.Button
             * @static
             * @param {kritor.message.IButton=} [properties] Properties to set
             * @returns {kritor.message.Button} Button instance
             */
            Button.create = function create(properties) {
                return new Button(properties);
            };

            /**
             * Encodes the specified Button message. Does not implicitly {@link kritor.message.Button.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.Button
             * @static
             * @param {kritor.message.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.renderData != null && Object.hasOwnProperty.call(message, "renderData"))
                    $root.kritor.message.ButtonRender.encode(message.renderData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    $root.kritor.message.ButtonAction.encode(message.action, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Button message, length delimited. Does not implicitly {@link kritor.message.Button.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.Button
             * @static
             * @param {kritor.message.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Button message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.Button();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.renderData = $root.kritor.message.ButtonRender.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.action = $root.kritor.message.ButtonAction.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Button message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Button message.
             * @function verify
             * @memberof kritor.message.Button
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Button.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.renderData != null && message.hasOwnProperty("renderData")) {
                    let error = $root.kritor.message.ButtonRender.verify(message.renderData);
                    if (error)
                        return "renderData." + error;
                }
                if (message.action != null && message.hasOwnProperty("action")) {
                    let error = $root.kritor.message.ButtonAction.verify(message.action);
                    if (error)
                        return "action." + error;
                }
                return null;
            };

            /**
             * Creates a Button message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.Button
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.Button} Button
             */
            Button.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.Button)
                    return object;
                let message = new $root.kritor.message.Button();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.renderData != null) {
                    if (typeof object.renderData !== "object")
                        throw TypeError(".kritor.message.Button.renderData: object expected");
                    message.renderData = $root.kritor.message.ButtonRender.fromObject(object.renderData);
                }
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".kritor.message.Button.action: object expected");
                    message.action = $root.kritor.message.ButtonAction.fromObject(object.action);
                }
                return message;
            };

            /**
             * Creates a plain object from a Button message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.Button
             * @static
             * @param {kritor.message.Button} message Button
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Button.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.renderData = null;
                    object.action = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.renderData != null && message.hasOwnProperty("renderData"))
                    object.renderData = $root.kritor.message.ButtonRender.toObject(message.renderData, options);
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = $root.kritor.message.ButtonAction.toObject(message.action, options);
                return object;
            };

            /**
             * Converts this Button to JSON.
             * @function toJSON
             * @memberof kritor.message.Button
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Button.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Button
             * @function getTypeUrl
             * @memberof kritor.message.Button
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Button.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.Button";
            };

            return Button;
        })();

        message.Row = (function() {

            /**
             * Properties of a Row.
             * @memberof kritor.message
             * @interface IRow
             * @property {Array.<kritor.message.IButton>|null} [buttons] Row buttons
             */

            /**
             * Constructs a new Row.
             * @memberof kritor.message
             * @classdesc Represents a Row.
             * @implements IRow
             * @constructor
             * @param {kritor.message.IRow=} [properties] Properties to set
             */
            function Row(properties) {
                this.buttons = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Row buttons.
             * @member {Array.<kritor.message.IButton>} buttons
             * @memberof kritor.message.Row
             * @instance
             */
            Row.prototype.buttons = $util.emptyArray;

            /**
             * Creates a new Row instance using the specified properties.
             * @function create
             * @memberof kritor.message.Row
             * @static
             * @param {kritor.message.IRow=} [properties] Properties to set
             * @returns {kritor.message.Row} Row instance
             */
            Row.create = function create(properties) {
                return new Row(properties);
            };

            /**
             * Encodes the specified Row message. Does not implicitly {@link kritor.message.Row.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.Row
             * @static
             * @param {kritor.message.IRow} message Row message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Row.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buttons != null && message.buttons.length)
                    for (let i = 0; i < message.buttons.length; ++i)
                        $root.kritor.message.Button.encode(message.buttons[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Row message, length delimited. Does not implicitly {@link kritor.message.Row.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.Row
             * @static
             * @param {kritor.message.IRow} message Row message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Row.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Row message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.Row
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.Row} Row
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Row.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.Row();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.buttons && message.buttons.length))
                                message.buttons = [];
                            message.buttons.push($root.kritor.message.Button.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Row message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.Row
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.Row} Row
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Row.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Row message.
             * @function verify
             * @memberof kritor.message.Row
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Row.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buttons != null && message.hasOwnProperty("buttons")) {
                    if (!Array.isArray(message.buttons))
                        return "buttons: array expected";
                    for (let i = 0; i < message.buttons.length; ++i) {
                        let error = $root.kritor.message.Button.verify(message.buttons[i]);
                        if (error)
                            return "buttons." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Row message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.Row
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.Row} Row
             */
            Row.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.Row)
                    return object;
                let message = new $root.kritor.message.Row();
                if (object.buttons) {
                    if (!Array.isArray(object.buttons))
                        throw TypeError(".kritor.message.Row.buttons: array expected");
                    message.buttons = [];
                    for (let i = 0; i < object.buttons.length; ++i) {
                        if (typeof object.buttons[i] !== "object")
                            throw TypeError(".kritor.message.Row.buttons: object expected");
                        message.buttons[i] = $root.kritor.message.Button.fromObject(object.buttons[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Row message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.Row
             * @static
             * @param {kritor.message.Row} message Row
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Row.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.buttons = [];
                if (message.buttons && message.buttons.length) {
                    object.buttons = [];
                    for (let j = 0; j < message.buttons.length; ++j)
                        object.buttons[j] = $root.kritor.message.Button.toObject(message.buttons[j], options);
                }
                return object;
            };

            /**
             * Converts this Row to JSON.
             * @function toJSON
             * @memberof kritor.message.Row
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Row.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Row
             * @function getTypeUrl
             * @memberof kritor.message.Row
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Row.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.Row";
            };

            return Row;
        })();

        message.ButtonElement = (function() {

            /**
             * Properties of a ButtonElement.
             * @memberof kritor.message
             * @interface IButtonElement
             * @property {Array.<kritor.message.IRow>|null} [rows] ButtonElement rows
             */

            /**
             * Constructs a new ButtonElement.
             * @memberof kritor.message
             * @classdesc Represents a ButtonElement.
             * @implements IButtonElement
             * @constructor
             * @param {kritor.message.IButtonElement=} [properties] Properties to set
             */
            function ButtonElement(properties) {
                this.rows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonElement rows.
             * @member {Array.<kritor.message.IRow>} rows
             * @memberof kritor.message.ButtonElement
             * @instance
             */
            ButtonElement.prototype.rows = $util.emptyArray;

            /**
             * Creates a new ButtonElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {kritor.message.IButtonElement=} [properties] Properties to set
             * @returns {kritor.message.ButtonElement} ButtonElement instance
             */
            ButtonElement.create = function create(properties) {
                return new ButtonElement(properties);
            };

            /**
             * Encodes the specified ButtonElement message. Does not implicitly {@link kritor.message.ButtonElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {kritor.message.IButtonElement} message ButtonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (let i = 0; i < message.rows.length; ++i)
                        $root.kritor.message.Row.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ButtonElement message, length delimited. Does not implicitly {@link kritor.message.ButtonElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {kritor.message.IButtonElement} message ButtonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ButtonElement} ButtonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ButtonElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.kritor.message.Row.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ButtonElement} ButtonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonElement message.
             * @function verify
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (let i = 0; i < message.rows.length; ++i) {
                        let error = $root.kritor.message.Row.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ButtonElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ButtonElement} ButtonElement
             */
            ButtonElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ButtonElement)
                    return object;
                let message = new $root.kritor.message.ButtonElement();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".kritor.message.ButtonElement.rows: array expected");
                    message.rows = [];
                    for (let i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".kritor.message.ButtonElement.rows: object expected");
                        message.rows[i] = $root.kritor.message.Row.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {kritor.message.ButtonElement} message ButtonElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (let j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.kritor.message.Row.toObject(message.rows[j], options);
                }
                return object;
            };

            /**
             * Converts this ButtonElement to JSON.
             * @function toJSON
             * @memberof kritor.message.ButtonElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonElement
             * @function getTypeUrl
             * @memberof kritor.message.ButtonElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ButtonElement";
            };

            return ButtonElement;
        })();

        message.NodeElement = (function() {

            /**
             * Properties of a NodeElement.
             * @memberof kritor.message
             * @interface INodeElement
             * @property {kritor.message.IContact|null} [scene] NodeElement scene
             * @property {number|Long|null} [messageId] NodeElement messageId
             */

            /**
             * Constructs a new NodeElement.
             * @memberof kritor.message
             * @classdesc Represents a NodeElement.
             * @implements INodeElement
             * @constructor
             * @param {kritor.message.INodeElement=} [properties] Properties to set
             */
            function NodeElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeElement scene.
             * @member {kritor.message.IContact|null|undefined} scene
             * @memberof kritor.message.NodeElement
             * @instance
             */
            NodeElement.prototype.scene = null;

            /**
             * NodeElement messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.NodeElement
             * @instance
             */
            NodeElement.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new NodeElement instance using the specified properties.
             * @function create
             * @memberof kritor.message.NodeElement
             * @static
             * @param {kritor.message.INodeElement=} [properties] Properties to set
             * @returns {kritor.message.NodeElement} NodeElement instance
             */
            NodeElement.create = function create(properties) {
                return new NodeElement(properties);
            };

            /**
             * Encodes the specified NodeElement message. Does not implicitly {@link kritor.message.NodeElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.NodeElement
             * @static
             * @param {kritor.message.INodeElement} message NodeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    $root.kritor.message.Contact.encode(message.scene, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified NodeElement message, length delimited. Does not implicitly {@link kritor.message.NodeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.NodeElement
             * @static
             * @param {kritor.message.INodeElement} message NodeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.NodeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.NodeElement} NodeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.NodeElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.NodeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.NodeElement} NodeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeElement message.
             * @function verify
             * @memberof kritor.message.NodeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scene != null && message.hasOwnProperty("scene")) {
                    let error = $root.kritor.message.Contact.verify(message.scene);
                    if (error)
                        return "scene." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a NodeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.NodeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.NodeElement} NodeElement
             */
            NodeElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.NodeElement)
                    return object;
                let message = new $root.kritor.message.NodeElement();
                if (object.scene != null) {
                    if (typeof object.scene !== "object")
                        throw TypeError(".kritor.message.NodeElement.scene: object expected");
                    message.scene = $root.kritor.message.Contact.fromObject(object.scene);
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a NodeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.NodeElement
             * @static
             * @param {kritor.message.NodeElement} message NodeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = $root.kritor.message.Contact.toObject(message.scene, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this NodeElement to JSON.
             * @function toJSON
             * @memberof kritor.message.NodeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NodeElement
             * @function getTypeUrl
             * @memberof kritor.message.NodeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.NodeElement";
            };

            return NodeElement;
        })();

        /**
         * Scene enum.
         * @name kritor.message.Scene
         * @enum {number}
         * @property {number} GROUP=0 GROUP value
         * @property {number} FRIEND=1 FRIEND value
         * @property {number} GUILD=2 GUILD value
         * @property {number} STRANGER_FROM_GROUP=10 STRANGER_FROM_GROUP value
         * @property {number} NEARBY=5 NEARBY value
         * @property {number} STRANGER=9 STRANGER value
         */
        message.Scene = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GROUP"] = 0;
            values[valuesById[1] = "FRIEND"] = 1;
            values[valuesById[2] = "GUILD"] = 2;
            values[valuesById[10] = "STRANGER_FROM_GROUP"] = 10;
            values[valuesById[5] = "NEARBY"] = 5;
            values[valuesById[9] = "STRANGER"] = 9;
            return values;
        })();

        message.Contact = (function() {

            /**
             * Properties of a Contact.
             * @memberof kritor.message
             * @interface IContact
             * @property {kritor.message.Scene|null} [scene] Contact scene
             * @property {string|null} [peer] Contact peer
             * @property {string|null} [subPeer] Contact subPeer
             */

            /**
             * Constructs a new Contact.
             * @memberof kritor.message
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {kritor.message.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contact scene.
             * @member {kritor.message.Scene} scene
             * @memberof kritor.message.Contact
             * @instance
             */
            Contact.prototype.scene = 0;

            /**
             * Contact peer.
             * @member {string} peer
             * @memberof kritor.message.Contact
             * @instance
             */
            Contact.prototype.peer = "";

            /**
             * Contact subPeer.
             * @member {string|null|undefined} subPeer
             * @memberof kritor.message.Contact
             * @instance
             */
            Contact.prototype.subPeer = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Contact _subPeer.
             * @member {"subPeer"|undefined} _subPeer
             * @memberof kritor.message.Contact
             * @instance
             */
            Object.defineProperty(Contact.prototype, "_subPeer", {
                get: $util.oneOfGetter($oneOfFields = ["subPeer"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof kritor.message.Contact
             * @static
             * @param {kritor.message.IContact=} [properties] Properties to set
             * @returns {kritor.message.Contact} Contact instance
             */
            Contact.create = function create(properties) {
                return new Contact(properties);
            };

            /**
             * Encodes the specified Contact message. Does not implicitly {@link kritor.message.Contact.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.Contact
             * @static
             * @param {kritor.message.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                if (message.subPeer != null && Object.hasOwnProperty.call(message, "subPeer"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subPeer);
                return writer;
            };

            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link kritor.message.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.Contact
             * @static
             * @param {kritor.message.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.Contact();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    case 3: {
                            message.subPeer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contact message.
             * @function verify
             * @memberof kritor.message.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                if (message.subPeer != null && message.hasOwnProperty("subPeer")) {
                    properties._subPeer = 1;
                    if (!$util.isString(message.subPeer))
                        return "subPeer: string expected";
                }
                return null;
            };

            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.Contact)
                    return object;
                let message = new $root.kritor.message.Contact();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                if (object.subPeer != null)
                    message.subPeer = String(object.subPeer);
                return message;
            };

            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.Contact
             * @static
             * @param {kritor.message.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.message.Scene[message.scene] === undefined ? message.scene : $root.kritor.message.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                if (message.subPeer != null && message.hasOwnProperty("subPeer")) {
                    object.subPeer = message.subPeer;
                    if (options.oneofs)
                        object._subPeer = "subPeer";
                }
                return object;
            };

            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof kritor.message.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Contact
             * @function getTypeUrl
             * @memberof kritor.message.Contact
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Contact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.Contact";
            };

            return Contact;
        })();

        message.ForwardMessageService = (function() {

            /**
             * Constructs a new ForwardMessageService service.
             * @memberof kritor.message
             * @classdesc Represents a ForwardMessageService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ForwardMessageService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ForwardMessageService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ForwardMessageService;

            /**
             * Creates new ForwardMessageService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.message.ForwardMessageService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ForwardMessageService} RPC service. Useful where requests and/or responses are streamed.
             */
            ForwardMessageService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.message.ForwardMessageService#forwardMessage}.
             * @memberof kritor.message.ForwardMessageService
             * @typedef ForwardMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.ForwardMessageResponse} [response] ForwardMessageResponse
             */

            /**
             * Calls ForwardMessage.
             * @function forwardMessage
             * @memberof kritor.message.ForwardMessageService
             * @instance
             * @param {kritor.message.IForwardMessageRequest} request ForwardMessageRequest message or plain object
             * @param {kritor.message.ForwardMessageService.ForwardMessageCallback} callback Node-style callback called with the error, if any, and ForwardMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ForwardMessageService.prototype.forwardMessage = function forwardMessage(request, callback) {
                return this.rpcCall(forwardMessage, $root.kritor.message.ForwardMessageRequest, $root.kritor.message.ForwardMessageResponse, request, callback);
            }, "name", { value: "ForwardMessage" });

            /**
             * Calls ForwardMessage.
             * @function forwardMessage
             * @memberof kritor.message.ForwardMessageService
             * @instance
             * @param {kritor.message.IForwardMessageRequest} request ForwardMessageRequest message or plain object
             * @returns {Promise<kritor.message.ForwardMessageResponse>} Promise
             * @variation 2
             */

            return ForwardMessageService;
        })();

        message.ForwardMessageRequest = (function() {

            /**
             * Properties of a ForwardMessageRequest.
             * @memberof kritor.message
             * @interface IForwardMessageRequest
             * @property {kritor.message.IContact|null} [contact] ForwardMessageRequest contact
             * @property {number|null} [retryCount] ForwardMessageRequest retryCount
             * @property {Array.<kritor.message.IForwardMessageBody>|null} [messages] ForwardMessageRequest messages
             * @property {boolean|null} [onlyUpload] ForwardMessageRequest onlyUpload
             */

            /**
             * Constructs a new ForwardMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a ForwardMessageRequest.
             * @implements IForwardMessageRequest
             * @constructor
             * @param {kritor.message.IForwardMessageRequest=} [properties] Properties to set
             */
            function ForwardMessageRequest(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardMessageRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             */
            ForwardMessageRequest.prototype.contact = null;

            /**
             * ForwardMessageRequest retryCount.
             * @member {number|null|undefined} retryCount
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             */
            ForwardMessageRequest.prototype.retryCount = null;

            /**
             * ForwardMessageRequest messages.
             * @member {Array.<kritor.message.IForwardMessageBody>} messages
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             */
            ForwardMessageRequest.prototype.messages = $util.emptyArray;

            /**
             * ForwardMessageRequest onlyUpload.
             * @member {boolean|null|undefined} onlyUpload
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             */
            ForwardMessageRequest.prototype.onlyUpload = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ForwardMessageRequest _retryCount.
             * @member {"retryCount"|undefined} _retryCount
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             */
            Object.defineProperty(ForwardMessageRequest.prototype, "_retryCount", {
                get: $util.oneOfGetter($oneOfFields = ["retryCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ForwardMessageRequest _onlyUpload.
             * @member {"onlyUpload"|undefined} _onlyUpload
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             */
            Object.defineProperty(ForwardMessageRequest.prototype, "_onlyUpload", {
                get: $util.oneOfGetter($oneOfFields = ["onlyUpload"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ForwardMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {kritor.message.IForwardMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.ForwardMessageRequest} ForwardMessageRequest instance
             */
            ForwardMessageRequest.create = function create(properties) {
                return new ForwardMessageRequest(properties);
            };

            /**
             * Encodes the specified ForwardMessageRequest message. Does not implicitly {@link kritor.message.ForwardMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {kritor.message.IForwardMessageRequest} message ForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.retryCount);
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.message.ForwardMessageBody.encode(message.messages[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.onlyUpload != null && Object.hasOwnProperty.call(message, "onlyUpload"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.onlyUpload);
                return writer;
            };

            /**
             * Encodes the specified ForwardMessageRequest message, length delimited. Does not implicitly {@link kritor.message.ForwardMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {kritor.message.IForwardMessageRequest} message ForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ForwardMessageRequest} ForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ForwardMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.retryCount = reader.uint32();
                            break;
                        }
                    case 3: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.message.ForwardMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.onlyUpload = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ForwardMessageRequest} ForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardMessageRequest message.
             * @function verify
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    properties._retryCount = 1;
                    if (!$util.isInteger(message.retryCount))
                        return "retryCount: integer expected";
                }
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.message.ForwardMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                if (message.onlyUpload != null && message.hasOwnProperty("onlyUpload")) {
                    properties._onlyUpload = 1;
                    if (typeof message.onlyUpload !== "boolean")
                        return "onlyUpload: boolean expected";
                }
                return null;
            };

            /**
             * Creates a ForwardMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ForwardMessageRequest} ForwardMessageRequest
             */
            ForwardMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ForwardMessageRequest)
                    return object;
                let message = new $root.kritor.message.ForwardMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.ForwardMessageRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.retryCount != null)
                    message.retryCount = object.retryCount >>> 0;
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.ForwardMessageRequest.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.ForwardMessageRequest.messages: object expected");
                        message.messages[i] = $root.kritor.message.ForwardMessageBody.fromObject(object.messages[i]);
                    }
                }
                if (object.onlyUpload != null)
                    message.onlyUpload = Boolean(object.onlyUpload);
                return message;
            };

            /**
             * Creates a plain object from a ForwardMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {kritor.message.ForwardMessageRequest} message ForwardMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    object.retryCount = message.retryCount;
                    if (options.oneofs)
                        object._retryCount = "retryCount";
                }
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.message.ForwardMessageBody.toObject(message.messages[j], options);
                }
                if (message.onlyUpload != null && message.hasOwnProperty("onlyUpload")) {
                    object.onlyUpload = message.onlyUpload;
                    if (options.oneofs)
                        object._onlyUpload = "onlyUpload";
                }
                return object;
            };

            /**
             * Converts this ForwardMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.ForwardMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.ForwardMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ForwardMessageRequest";
            };

            return ForwardMessageRequest;
        })();

        message.ForwardMessageResponse = (function() {

            /**
             * Properties of a ForwardMessageResponse.
             * @memberof kritor.message
             * @interface IForwardMessageResponse
             * @property {number|Long|null} [messageId] ForwardMessageResponse messageId
             * @property {string|null} [resId] ForwardMessageResponse resId
             */

            /**
             * Constructs a new ForwardMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a ForwardMessageResponse.
             * @implements IForwardMessageResponse
             * @constructor
             * @param {kritor.message.IForwardMessageResponse=} [properties] Properties to set
             */
            function ForwardMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardMessageResponse messageId.
             * @member {number|Long|null|undefined} messageId
             * @memberof kritor.message.ForwardMessageResponse
             * @instance
             */
            ForwardMessageResponse.prototype.messageId = null;

            /**
             * ForwardMessageResponse resId.
             * @member {string} resId
             * @memberof kritor.message.ForwardMessageResponse
             * @instance
             */
            ForwardMessageResponse.prototype.resId = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ForwardMessageResponse _messageId.
             * @member {"messageId"|undefined} _messageId
             * @memberof kritor.message.ForwardMessageResponse
             * @instance
             */
            Object.defineProperty(ForwardMessageResponse.prototype, "_messageId", {
                get: $util.oneOfGetter($oneOfFields = ["messageId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ForwardMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {kritor.message.IForwardMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.ForwardMessageResponse} ForwardMessageResponse instance
             */
            ForwardMessageResponse.create = function create(properties) {
                return new ForwardMessageResponse(properties);
            };

            /**
             * Encodes the specified ForwardMessageResponse message. Does not implicitly {@link kritor.message.ForwardMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {kritor.message.IForwardMessageResponse} message ForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.resId);
                return writer;
            };

            /**
             * Encodes the specified ForwardMessageResponse message, length delimited. Does not implicitly {@link kritor.message.ForwardMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {kritor.message.IForwardMessageResponse} message ForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ForwardMessageResponse} ForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ForwardMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.resId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ForwardMessageResponse} ForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardMessageResponse message.
             * @function verify
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.messageId != null && message.hasOwnProperty("messageId")) {
                    properties._messageId = 1;
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                }
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                return null;
            };

            /**
             * Creates a ForwardMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ForwardMessageResponse} ForwardMessageResponse
             */
            ForwardMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ForwardMessageResponse)
                    return object;
                let message = new $root.kritor.message.ForwardMessageResponse();
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.resId != null)
                    message.resId = String(object.resId);
                return message;
            };

            /**
             * Creates a plain object from a ForwardMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {kritor.message.ForwardMessageResponse} message ForwardMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.resId = "";
                if (message.messageId != null && message.hasOwnProperty("messageId")) {
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                    if (options.oneofs)
                        object._messageId = "messageId";
                }
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                return object;
            };

            /**
             * Converts this ForwardMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.ForwardMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.ForwardMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ForwardMessageResponse";
            };

            return ForwardMessageResponse;
        })();

        message.ForwardSender = (function() {

            /**
             * Properties of a ForwardSender.
             * @memberof kritor.message
             * @interface IForwardSender
             * @property {string|null} [uid] ForwardSender uid
             * @property {number|Long|null} [uin] ForwardSender uin
             * @property {string|null} [nick] ForwardSender nick
             */

            /**
             * Constructs a new ForwardSender.
             * @memberof kritor.message
             * @classdesc Represents a ForwardSender.
             * @implements IForwardSender
             * @constructor
             * @param {kritor.message.IForwardSender=} [properties] Properties to set
             */
            function ForwardSender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardSender uid.
             * @member {string} uid
             * @memberof kritor.message.ForwardSender
             * @instance
             */
            ForwardSender.prototype.uid = "";

            /**
             * ForwardSender uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.message.ForwardSender
             * @instance
             */
            ForwardSender.prototype.uin = null;

            /**
             * ForwardSender nick.
             * @member {string|null|undefined} nick
             * @memberof kritor.message.ForwardSender
             * @instance
             */
            ForwardSender.prototype.nick = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ForwardSender _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.message.ForwardSender
             * @instance
             */
            Object.defineProperty(ForwardSender.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ForwardSender _nick.
             * @member {"nick"|undefined} _nick
             * @memberof kritor.message.ForwardSender
             * @instance
             */
            Object.defineProperty(ForwardSender.prototype, "_nick", {
                get: $util.oneOfGetter($oneOfFields = ["nick"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ForwardSender instance using the specified properties.
             * @function create
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {kritor.message.IForwardSender=} [properties] Properties to set
             * @returns {kritor.message.ForwardSender} ForwardSender instance
             */
            ForwardSender.create = function create(properties) {
                return new ForwardSender(properties);
            };

            /**
             * Encodes the specified ForwardSender message. Does not implicitly {@link kritor.message.ForwardSender.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {kritor.message.IForwardSender} message ForwardSender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardSender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                return writer;
            };

            /**
             * Encodes the specified ForwardSender message, length delimited. Does not implicitly {@link kritor.message.ForwardSender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {kritor.message.IForwardSender} message ForwardSender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardSender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardSender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ForwardSender} ForwardSender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardSender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ForwardSender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardSender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ForwardSender} ForwardSender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardSender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardSender message.
             * @function verify
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardSender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                if (message.nick != null && message.hasOwnProperty("nick")) {
                    properties._nick = 1;
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                }
                return null;
            };

            /**
             * Creates a ForwardSender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ForwardSender} ForwardSender
             */
            ForwardSender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ForwardSender)
                    return object;
                let message = new $root.kritor.message.ForwardSender();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                return message;
            };

            /**
             * Creates a plain object from a ForwardSender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {kritor.message.ForwardSender} message ForwardSender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardSender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.uid = "";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                if (message.nick != null && message.hasOwnProperty("nick")) {
                    object.nick = message.nick;
                    if (options.oneofs)
                        object._nick = "nick";
                }
                return object;
            };

            /**
             * Converts this ForwardSender to JSON.
             * @function toJSON
             * @memberof kritor.message.ForwardSender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardSender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardSender
             * @function getTypeUrl
             * @memberof kritor.message.ForwardSender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardSender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ForwardSender";
            };

            return ForwardSender;
        })();

        message.ForwardMessageBody = (function() {

            /**
             * Properties of a ForwardMessageBody.
             * @memberof kritor.message
             * @interface IForwardMessageBody
             * @property {kritor.message.IContact|null} [contact] ForwardMessageBody contact
             * @property {kritor.message.IForwardSender|null} [sender] ForwardMessageBody sender
             * @property {number|null} [messageTime] ForwardMessageBody messageTime
             * @property {number|null} [messageSeq] ForwardMessageBody messageSeq
             * @property {Array.<kritor.message.IElement>|null} [elements] ForwardMessageBody elements
             */

            /**
             * Constructs a new ForwardMessageBody.
             * @memberof kritor.message
             * @classdesc Represents a ForwardMessageBody.
             * @implements IForwardMessageBody
             * @constructor
             * @param {kritor.message.IForwardMessageBody=} [properties] Properties to set
             */
            function ForwardMessageBody(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardMessageBody contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.contact = null;

            /**
             * ForwardMessageBody sender.
             * @member {kritor.message.IForwardSender|null|undefined} sender
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.sender = null;

            /**
             * ForwardMessageBody messageTime.
             * @member {number|null|undefined} messageTime
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.messageTime = null;

            /**
             * ForwardMessageBody messageSeq.
             * @member {number|null|undefined} messageSeq
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.messageSeq = null;

            /**
             * ForwardMessageBody elements.
             * @member {Array.<kritor.message.IElement>} elements
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.elements = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ForwardMessageBody _messageTime.
             * @member {"messageTime"|undefined} _messageTime
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            Object.defineProperty(ForwardMessageBody.prototype, "_messageTime", {
                get: $util.oneOfGetter($oneOfFields = ["messageTime"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ForwardMessageBody _messageSeq.
             * @member {"messageSeq"|undefined} _messageSeq
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             */
            Object.defineProperty(ForwardMessageBody.prototype, "_messageSeq", {
                get: $util.oneOfGetter($oneOfFields = ["messageSeq"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ForwardMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {kritor.message.IForwardMessageBody=} [properties] Properties to set
             * @returns {kritor.message.ForwardMessageBody} ForwardMessageBody instance
             */
            ForwardMessageBody.create = function create(properties) {
                return new ForwardMessageBody(properties);
            };

            /**
             * Encodes the specified ForwardMessageBody message. Does not implicitly {@link kritor.message.ForwardMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {kritor.message.IForwardMessageBody} message ForwardMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    $root.kritor.message.ForwardSender.encode(message.sender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageTime != null && Object.hasOwnProperty.call(message, "messageTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.messageTime);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.messageSeq);
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.message.Element.encode(message.elements[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForwardMessageBody message, length delimited. Does not implicitly {@link kritor.message.ForwardMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {kritor.message.IForwardMessageBody} message ForwardMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ForwardMessageBody} ForwardMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ForwardMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 5: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 1: {
                            message.sender = $root.kritor.message.ForwardSender.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageTime = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.messageSeq = reader.uint32();
                            break;
                        }
                    case 4: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.message.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ForwardMessageBody} ForwardMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardMessageBody message.
             * @function verify
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.sender != null && message.hasOwnProperty("sender")) {
                    let error = $root.kritor.message.ForwardSender.verify(message.sender);
                    if (error)
                        return "sender." + error;
                }
                if (message.messageTime != null && message.hasOwnProperty("messageTime")) {
                    properties._messageTime = 1;
                    if (!$util.isInteger(message.messageTime))
                        return "messageTime: integer expected";
                }
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq")) {
                    properties._messageSeq = 1;
                    if (!$util.isInteger(message.messageSeq))
                        return "messageSeq: integer expected";
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.message.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForwardMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ForwardMessageBody} ForwardMessageBody
             */
            ForwardMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ForwardMessageBody)
                    return object;
                let message = new $root.kritor.message.ForwardMessageBody();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.ForwardMessageBody.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.sender != null) {
                    if (typeof object.sender !== "object")
                        throw TypeError(".kritor.message.ForwardMessageBody.sender: object expected");
                    message.sender = $root.kritor.message.ForwardSender.fromObject(object.sender);
                }
                if (object.messageTime != null)
                    message.messageTime = object.messageTime >>> 0;
                if (object.messageSeq != null)
                    message.messageSeq = object.messageSeq >>> 0;
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.message.ForwardMessageBody.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.message.ForwardMessageBody.elements: object expected");
                        message.elements[i] = $root.kritor.message.Element.fromObject(object.elements[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ForwardMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {kritor.message.ForwardMessageBody} message ForwardMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults) {
                    object.sender = null;
                    object.contact = null;
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = $root.kritor.message.ForwardSender.toObject(message.sender, options);
                if (message.messageTime != null && message.hasOwnProperty("messageTime")) {
                    object.messageTime = message.messageTime;
                    if (options.oneofs)
                        object._messageTime = "messageTime";
                }
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq")) {
                    object.messageSeq = message.messageSeq;
                    if (options.oneofs)
                        object._messageSeq = "messageSeq";
                }
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.message.Element.toObject(message.elements[j], options);
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                return object;
            };

            /**
             * Converts this ForwardMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.message.ForwardMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardMessageBody
             * @function getTypeUrl
             * @memberof kritor.message.ForwardMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ForwardMessageBody";
            };

            return ForwardMessageBody;
        })();

        message.EssenceMessage = (function() {

            /**
             * Properties of an EssenceMessage.
             * @memberof kritor.message
             * @interface IEssenceMessage
             * @property {number|Long|null} [senderUin] EssenceMessage senderUin
             * @property {string|null} [senderNick] EssenceMessage senderNick
             * @property {number|null} [msgTime] EssenceMessage msgTime
             * @property {number|Long|null} [operatorUin] EssenceMessage operatorUin
             * @property {string|null} [operatorNick] EssenceMessage operatorNick
             * @property {number|null} [operationTime] EssenceMessage operationTime
             * @property {number|Long|null} [messageId] EssenceMessage messageId
             * @property {number|Long|null} [messageSeq] EssenceMessage messageSeq
             * @property {string|null} [jsonElements] EssenceMessage jsonElements
             */

            /**
             * Constructs a new EssenceMessage.
             * @memberof kritor.message
             * @classdesc Represents an EssenceMessage.
             * @implements IEssenceMessage
             * @constructor
             * @param {kritor.message.IEssenceMessage=} [properties] Properties to set
             */
            function EssenceMessage(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EssenceMessage senderUin.
             * @member {number|Long} senderUin
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.senderUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessage senderNick.
             * @member {string} senderNick
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.senderNick = "";

            /**
             * EssenceMessage msgTime.
             * @member {number} msgTime
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.msgTime = 0;

            /**
             * EssenceMessage operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessage operatorNick.
             * @member {string} operatorNick
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.operatorNick = "";

            /**
             * EssenceMessage operationTime.
             * @member {number} operationTime
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.operationTime = 0;

            /**
             * EssenceMessage messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessage messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessage jsonElements.
             * @member {string} jsonElements
             * @memberof kritor.message.EssenceMessage
             * @instance
             */
            EssenceMessage.prototype.jsonElements = "";

            /**
             * Creates a new EssenceMessage instance using the specified properties.
             * @function create
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {kritor.message.IEssenceMessage=} [properties] Properties to set
             * @returns {kritor.message.EssenceMessage} EssenceMessage instance
             */
            EssenceMessage.create = function create(properties) {
                return new EssenceMessage(properties);
            };

            /**
             * Encodes the specified EssenceMessage message. Does not implicitly {@link kritor.message.EssenceMessage.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {kritor.message.IEssenceMessage} message EssenceMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.senderUin != null && Object.hasOwnProperty.call(message, "senderUin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.senderUin);
                if (message.senderNick != null && Object.hasOwnProperty.call(message, "senderNick"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.senderNick);
                if (message.msgTime != null && Object.hasOwnProperty.call(message, "msgTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.msgTime);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.operatorUin);
                if (message.operatorNick != null && Object.hasOwnProperty.call(message, "operatorNick"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.operatorNick);
                if (message.operationTime != null && Object.hasOwnProperty.call(message, "operationTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.operationTime);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.messageId);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.messageSeq);
                if (message.jsonElements != null && Object.hasOwnProperty.call(message, "jsonElements"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.jsonElements);
                return writer;
            };

            /**
             * Encodes the specified EssenceMessage message, length delimited. Does not implicitly {@link kritor.message.EssenceMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {kritor.message.IEssenceMessage} message EssenceMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EssenceMessage message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.EssenceMessage} EssenceMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.EssenceMessage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.senderUin = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.senderNick = reader.string();
                            break;
                        }
                    case 3: {
                            message.msgTime = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.operatorNick = reader.string();
                            break;
                        }
                    case 6: {
                            message.operationTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.jsonElements = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EssenceMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.EssenceMessage} EssenceMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EssenceMessage message.
             * @function verify
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EssenceMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.senderUin != null && message.hasOwnProperty("senderUin"))
                    if (!$util.isInteger(message.senderUin) && !(message.senderUin && $util.isInteger(message.senderUin.low) && $util.isInteger(message.senderUin.high)))
                        return "senderUin: integer|Long expected";
                if (message.senderNick != null && message.hasOwnProperty("senderNick"))
                    if (!$util.isString(message.senderNick))
                        return "senderNick: string expected";
                if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                    if (!$util.isInteger(message.msgTime))
                        return "msgTime: integer expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.operatorNick != null && message.hasOwnProperty("operatorNick"))
                    if (!$util.isString(message.operatorNick))
                        return "operatorNick: string expected";
                if (message.operationTime != null && message.hasOwnProperty("operationTime"))
                    if (!$util.isInteger(message.operationTime))
                        return "operationTime: integer expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                if (message.jsonElements != null && message.hasOwnProperty("jsonElements"))
                    if (!$util.isString(message.jsonElements))
                        return "jsonElements: string expected";
                return null;
            };

            /**
             * Creates an EssenceMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.EssenceMessage} EssenceMessage
             */
            EssenceMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.EssenceMessage)
                    return object;
                let message = new $root.kritor.message.EssenceMessage();
                if (object.senderUin != null)
                    if ($util.Long)
                        (message.senderUin = $util.Long.fromValue(object.senderUin)).unsigned = true;
                    else if (typeof object.senderUin === "string")
                        message.senderUin = parseInt(object.senderUin, 10);
                    else if (typeof object.senderUin === "number")
                        message.senderUin = object.senderUin;
                    else if (typeof object.senderUin === "object")
                        message.senderUin = new $util.LongBits(object.senderUin.low >>> 0, object.senderUin.high >>> 0).toNumber(true);
                if (object.senderNick != null)
                    message.senderNick = String(object.senderNick);
                if (object.msgTime != null)
                    message.msgTime = object.msgTime >>> 0;
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.operatorNick != null)
                    message.operatorNick = String(object.operatorNick);
                if (object.operationTime != null)
                    message.operationTime = object.operationTime >>> 0;
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                if (object.jsonElements != null)
                    message.jsonElements = String(object.jsonElements);
                return message;
            };

            /**
             * Creates a plain object from an EssenceMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {kritor.message.EssenceMessage} message EssenceMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EssenceMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.senderUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.senderUin = options.longs === String ? "0" : 0;
                    object.senderNick = "";
                    object.msgTime = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.operatorNick = "";
                    object.operationTime = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                    object.jsonElements = "";
                }
                if (message.senderUin != null && message.hasOwnProperty("senderUin"))
                    if (typeof message.senderUin === "number")
                        object.senderUin = options.longs === String ? String(message.senderUin) : message.senderUin;
                    else
                        object.senderUin = options.longs === String ? $util.Long.prototype.toString.call(message.senderUin) : options.longs === Number ? new $util.LongBits(message.senderUin.low >>> 0, message.senderUin.high >>> 0).toNumber(true) : message.senderUin;
                if (message.senderNick != null && message.hasOwnProperty("senderNick"))
                    object.senderNick = message.senderNick;
                if (message.msgTime != null && message.hasOwnProperty("msgTime"))
                    object.msgTime = message.msgTime;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.operatorNick != null && message.hasOwnProperty("operatorNick"))
                    object.operatorNick = message.operatorNick;
                if (message.operationTime != null && message.hasOwnProperty("operationTime"))
                    object.operationTime = message.operationTime;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                if (message.jsonElements != null && message.hasOwnProperty("jsonElements"))
                    object.jsonElements = message.jsonElements;
                return object;
            };

            /**
             * Converts this EssenceMessage to JSON.
             * @function toJSON
             * @memberof kritor.message.EssenceMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EssenceMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EssenceMessage
             * @function getTypeUrl
             * @memberof kritor.message.EssenceMessage
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EssenceMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.EssenceMessage";
            };

            return EssenceMessage;
        })();

        message.MessageService = (function() {

            /**
             * Constructs a new MessageService service.
             * @memberof kritor.message
             * @classdesc Represents a MessageService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MessageService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MessageService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MessageService;

            /**
             * Creates new MessageService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.message.MessageService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MessageService} RPC service. Useful where requests and/or responses are streamed.
             */
            MessageService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.message.MessageService#sendMessage}.
             * @memberof kritor.message.MessageService
             * @typedef SendMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SendMessageResponse} [response] SendMessageResponse
             */

            /**
             * Calls SendMessage.
             * @function sendMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageRequest} request SendMessageRequest message or plain object
             * @param {kritor.message.MessageService.SendMessageCallback} callback Node-style callback called with the error, if any, and SendMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.sendMessage = function sendMessage(request, callback) {
                return this.rpcCall(sendMessage, $root.kritor.message.SendMessageRequest, $root.kritor.message.SendMessageResponse, request, callback);
            }, "name", { value: "SendMessage" });

            /**
             * Calls SendMessage.
             * @function sendMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageRequest} request SendMessageRequest message or plain object
             * @returns {Promise<kritor.message.SendMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#sendMessageByResId}.
             * @memberof kritor.message.MessageService
             * @typedef SendMessageByResIdCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SendMessageByResIdResponse} [response] SendMessageByResIdResponse
             */

            /**
             * Calls SendMessageByResId.
             * @function sendMessageByResId
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageByResIdRequest} request SendMessageByResIdRequest message or plain object
             * @param {kritor.message.MessageService.SendMessageByResIdCallback} callback Node-style callback called with the error, if any, and SendMessageByResIdResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.sendMessageByResId = function sendMessageByResId(request, callback) {
                return this.rpcCall(sendMessageByResId, $root.kritor.message.SendMessageByResIdRequest, $root.kritor.message.SendMessageByResIdResponse, request, callback);
            }, "name", { value: "SendMessageByResId" });

            /**
             * Calls SendMessageByResId.
             * @function sendMessageByResId
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageByResIdRequest} request SendMessageByResIdRequest message or plain object
             * @returns {Promise<kritor.message.SendMessageByResIdResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#clearMessages}.
             * @memberof kritor.message.MessageService
             * @typedef ClearMessagesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.ClearMessagesResponse} [response] ClearMessagesResponse
             */

            /**
             * Calls ClearMessages.
             * @function clearMessages
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IClearMessagesRequest} request ClearMessagesRequest message or plain object
             * @param {kritor.message.MessageService.ClearMessagesCallback} callback Node-style callback called with the error, if any, and ClearMessagesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.clearMessages = function clearMessages(request, callback) {
                return this.rpcCall(clearMessages, $root.kritor.message.ClearMessagesRequest, $root.kritor.message.ClearMessagesResponse, request, callback);
            }, "name", { value: "ClearMessages" });

            /**
             * Calls ClearMessages.
             * @function clearMessages
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IClearMessagesRequest} request ClearMessagesRequest message or plain object
             * @returns {Promise<kritor.message.ClearMessagesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#recallMessage}.
             * @memberof kritor.message.MessageService
             * @typedef RecallMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.RecallMessageResponse} [response] RecallMessageResponse
             */

            /**
             * Calls RecallMessage.
             * @function recallMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IRecallMessageRequest} request RecallMessageRequest message or plain object
             * @param {kritor.message.MessageService.RecallMessageCallback} callback Node-style callback called with the error, if any, and RecallMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.recallMessage = function recallMessage(request, callback) {
                return this.rpcCall(recallMessage, $root.kritor.message.RecallMessageRequest, $root.kritor.message.RecallMessageResponse, request, callback);
            }, "name", { value: "RecallMessage" });

            /**
             * Calls RecallMessage.
             * @function recallMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IRecallMessageRequest} request RecallMessageRequest message or plain object
             * @returns {Promise<kritor.message.RecallMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#setMessageCommentEmoji}.
             * @memberof kritor.message.MessageService
             * @typedef SetMessageCommentEmojiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SetMessageCommentEmojiResponse} [response] SetMessageCommentEmojiResponse
             */

            /**
             * Calls SetMessageCommentEmoji.
             * @function setMessageCommentEmoji
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetMessageCommentEmojiRequest} request SetMessageCommentEmojiRequest message or plain object
             * @param {kritor.message.MessageService.SetMessageCommentEmojiCallback} callback Node-style callback called with the error, if any, and SetMessageCommentEmojiResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.setMessageCommentEmoji = function setMessageCommentEmoji(request, callback) {
                return this.rpcCall(setMessageCommentEmoji, $root.kritor.message.SetMessageCommentEmojiRequest, $root.kritor.message.SetMessageCommentEmojiResponse, request, callback);
            }, "name", { value: "SetMessageCommentEmoji" });

            /**
             * Calls SetMessageCommentEmoji.
             * @function setMessageCommentEmoji
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetMessageCommentEmojiRequest} request SetMessageCommentEmojiRequest message or plain object
             * @returns {Promise<kritor.message.SetMessageCommentEmojiResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getForwardMessages}.
             * @memberof kritor.message.MessageService
             * @typedef GetForwardMessagesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetForwardMessagesResponse} [response] GetForwardMessagesResponse
             */

            /**
             * Calls GetForwardMessages.
             * @function getForwardMessages
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetForwardMessagesRequest} request GetForwardMessagesRequest message or plain object
             * @param {kritor.message.MessageService.GetForwardMessagesCallback} callback Node-style callback called with the error, if any, and GetForwardMessagesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getForwardMessages = function getForwardMessages(request, callback) {
                return this.rpcCall(getForwardMessages, $root.kritor.message.GetForwardMessagesRequest, $root.kritor.message.GetForwardMessagesResponse, request, callback);
            }, "name", { value: "GetForwardMessages" });

            /**
             * Calls GetForwardMessages.
             * @function getForwardMessages
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetForwardMessagesRequest} request GetForwardMessagesRequest message or plain object
             * @returns {Promise<kritor.message.GetForwardMessagesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getMessage}.
             * @memberof kritor.message.MessageService
             * @typedef GetMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetMessageResponse} [response] GetMessageResponse
             */

            /**
             * Calls GetMessage.
             * @function getMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageRequest} request GetMessageRequest message or plain object
             * @param {kritor.message.MessageService.GetMessageCallback} callback Node-style callback called with the error, if any, and GetMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessage = function getMessage(request, callback) {
                return this.rpcCall(getMessage, $root.kritor.message.GetMessageRequest, $root.kritor.message.GetMessageResponse, request, callback);
            }, "name", { value: "GetMessage" });

            /**
             * Calls GetMessage.
             * @function getMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageRequest} request GetMessageRequest message or plain object
             * @returns {Promise<kritor.message.GetMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getMessageBySeq}.
             * @memberof kritor.message.MessageService
             * @typedef GetMessageBySeqCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetMessageBySeqResponse} [response] GetMessageBySeqResponse
             */

            /**
             * Calls GetMessageBySeq.
             * @function getMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageBySeqRequest} request GetMessageBySeqRequest message or plain object
             * @param {kritor.message.MessageService.GetMessageBySeqCallback} callback Node-style callback called with the error, if any, and GetMessageBySeqResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessageBySeq = function getMessageBySeq(request, callback) {
                return this.rpcCall(getMessageBySeq, $root.kritor.message.GetMessageBySeqRequest, $root.kritor.message.GetMessageBySeqResponse, request, callback);
            }, "name", { value: "GetMessageBySeq" });

            /**
             * Calls GetMessageBySeq.
             * @function getMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageBySeqRequest} request GetMessageBySeqRequest message or plain object
             * @returns {Promise<kritor.message.GetMessageBySeqResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getHistoryMessage}.
             * @memberof kritor.message.MessageService
             * @typedef GetHistoryMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetHistoryMessageResponse} [response] GetHistoryMessageResponse
             */

            /**
             * Calls GetHistoryMessage.
             * @function getHistoryMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageRequest} request GetHistoryMessageRequest message or plain object
             * @param {kritor.message.MessageService.GetHistoryMessageCallback} callback Node-style callback called with the error, if any, and GetHistoryMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getHistoryMessage = function getHistoryMessage(request, callback) {
                return this.rpcCall(getHistoryMessage, $root.kritor.message.GetHistoryMessageRequest, $root.kritor.message.GetHistoryMessageResponse, request, callback);
            }, "name", { value: "GetHistoryMessage" });

            /**
             * Calls GetHistoryMessage.
             * @function getHistoryMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageRequest} request GetHistoryMessageRequest message or plain object
             * @returns {Promise<kritor.message.GetHistoryMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#deleteEssenceMsg}.
             * @memberof kritor.message.MessageService
             * @typedef DeleteEssenceMsgCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.DeleteEssenceMsgResponse} [response] DeleteEssenceMsgResponse
             */

            /**
             * Calls DeleteEssenceMsg.
             * @function deleteEssenceMsg
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDeleteEssenceMsgRequest} request DeleteEssenceMsgRequest message or plain object
             * @param {kritor.message.MessageService.DeleteEssenceMsgCallback} callback Node-style callback called with the error, if any, and DeleteEssenceMsgResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.deleteEssenceMsg = function deleteEssenceMsg(request, callback) {
                return this.rpcCall(deleteEssenceMsg, $root.kritor.message.DeleteEssenceMsgRequest, $root.kritor.message.DeleteEssenceMsgResponse, request, callback);
            }, "name", { value: "DeleteEssenceMsg" });

            /**
             * Calls DeleteEssenceMsg.
             * @function deleteEssenceMsg
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDeleteEssenceMsgRequest} request DeleteEssenceMsgRequest message or plain object
             * @returns {Promise<kritor.message.DeleteEssenceMsgResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getEssenceMessages}.
             * @memberof kritor.message.MessageService
             * @typedef GetEssenceMessagesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetEssenceMessagesResponse} [response] GetEssenceMessagesResponse
             */

            /**
             * Calls GetEssenceMessages.
             * @function getEssenceMessages
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetEssenceMessagesRequest} request GetEssenceMessagesRequest message or plain object
             * @param {kritor.message.MessageService.GetEssenceMessagesCallback} callback Node-style callback called with the error, if any, and GetEssenceMessagesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getEssenceMessages = function getEssenceMessages(request, callback) {
                return this.rpcCall(getEssenceMessages, $root.kritor.message.GetEssenceMessagesRequest, $root.kritor.message.GetEssenceMessagesResponse, request, callback);
            }, "name", { value: "GetEssenceMessages" });

            /**
             * Calls GetEssenceMessages.
             * @function getEssenceMessages
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetEssenceMessagesRequest} request GetEssenceMessagesRequest message or plain object
             * @returns {Promise<kritor.message.GetEssenceMessagesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#setEssenceMessage}.
             * @memberof kritor.message.MessageService
             * @typedef SetEssenceMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SetEssenceMessageResponse} [response] SetEssenceMessageResponse
             */

            /**
             * Calls SetEssenceMessage.
             * @function setEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetEssenceMessageRequest} request SetEssenceMessageRequest message or plain object
             * @param {kritor.message.MessageService.SetEssenceMessageCallback} callback Node-style callback called with the error, if any, and SetEssenceMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.setEssenceMessage = function setEssenceMessage(request, callback) {
                return this.rpcCall(setEssenceMessage, $root.kritor.message.SetEssenceMessageRequest, $root.kritor.message.SetEssenceMessageResponse, request, callback);
            }, "name", { value: "SetEssenceMessage" });

            /**
             * Calls SetEssenceMessage.
             * @function setEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetEssenceMessageRequest} request SetEssenceMessageRequest message or plain object
             * @returns {Promise<kritor.message.SetEssenceMessageResponse>} Promise
             * @variation 2
             */

            return MessageService;
        })();

        message.SendMessageRequest = (function() {

            /**
             * Properties of a SendMessageRequest.
             * @memberof kritor.message
             * @interface ISendMessageRequest
             * @property {kritor.message.IContact|null} [contact] SendMessageRequest contact
             * @property {Array.<kritor.message.IElement>|null} [elements] SendMessageRequest elements
             * @property {number|null} [retryCount] SendMessageRequest retryCount
             */

            /**
             * Constructs a new SendMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageRequest.
             * @implements ISendMessageRequest
             * @constructor
             * @param {kritor.message.ISendMessageRequest=} [properties] Properties to set
             */
            function SendMessageRequest(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.contact = null;

            /**
             * SendMessageRequest elements.
             * @member {Array.<kritor.message.IElement>} elements
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.elements = $util.emptyArray;

            /**
             * SendMessageRequest retryCount.
             * @member {number|null|undefined} retryCount
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.retryCount = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SendMessageRequest _retryCount.
             * @member {"retryCount"|undefined} _retryCount
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            Object.defineProperty(SendMessageRequest.prototype, "_retryCount", {
                get: $util.oneOfGetter($oneOfFields = ["retryCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SendMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest instance
             */
            SendMessageRequest.create = function create(properties) {
                return new SendMessageRequest(properties);
            };

            /**
             * Encodes the specified SendMessageRequest message. Does not implicitly {@link kritor.message.SendMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest} message SendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.message.Element.encode(message.elements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
                return writer;
            };

            /**
             * Encodes the specified SendMessageRequest message, length delimited. Does not implicitly {@link kritor.message.SendMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest} message SendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.message.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.retryCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageRequest message.
             * @function verify
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.message.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    properties._retryCount = 1;
                    if (!$util.isInteger(message.retryCount))
                        return "retryCount: integer expected";
                }
                return null;
            };

            /**
             * Creates a SendMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             */
            SendMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageRequest)
                    return object;
                let message = new $root.kritor.message.SendMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SendMessageRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.message.SendMessageRequest.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.message.SendMessageRequest.elements: object expected");
                        message.elements[i] = $root.kritor.message.Element.fromObject(object.elements[i]);
                    }
                }
                if (object.retryCount != null)
                    message.retryCount = object.retryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.SendMessageRequest} message SendMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.message.Element.toObject(message.elements[j], options);
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    object.retryCount = message.retryCount;
                    if (options.oneofs)
                        object._retryCount = "retryCount";
                }
                return object;
            };

            /**
             * Converts this SendMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageRequest";
            };

            return SendMessageRequest;
        })();

        message.SendMessageResponse = (function() {

            /**
             * Properties of a SendMessageResponse.
             * @memberof kritor.message
             * @interface ISendMessageResponse
             * @property {number|Long|null} [messageId] SendMessageResponse messageId
             * @property {number|null} [messageTime] SendMessageResponse messageTime
             */

            /**
             * Constructs a new SendMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageResponse.
             * @implements ISendMessageResponse
             * @constructor
             * @param {kritor.message.ISendMessageResponse=} [properties] Properties to set
             */
            function SendMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageResponse messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.SendMessageResponse
             * @instance
             */
            SendMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendMessageResponse messageTime.
             * @member {number} messageTime
             * @memberof kritor.message.SendMessageResponse
             * @instance
             */
            SendMessageResponse.prototype.messageTime = 0;

            /**
             * Creates a new SendMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse instance
             */
            SendMessageResponse.create = function create(properties) {
                return new SendMessageResponse(properties);
            };

            /**
             * Encodes the specified SendMessageResponse message. Does not implicitly {@link kritor.message.SendMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);
                if (message.messageTime != null && Object.hasOwnProperty.call(message, "messageTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.messageTime);
                return writer;
            };

            /**
             * Encodes the specified SendMessageResponse message, length delimited. Does not implicitly {@link kritor.message.SendMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageTime = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageResponse message.
             * @function verify
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    if (!$util.isInteger(message.messageTime))
                        return "messageTime: integer expected";
                return null;
            };

            /**
             * Creates a SendMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             */
            SendMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageResponse)
                    return object;
                let message = new $root.kritor.message.SendMessageResponse();
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.messageTime != null)
                    message.messageTime = object.messageTime >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.SendMessageResponse} message SendMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.messageTime = 0;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    object.messageTime = message.messageTime;
                return object;
            };

            /**
             * Converts this SendMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageResponse";
            };

            return SendMessageResponse;
        })();

        message.SendMessageByResIdRequest = (function() {

            /**
             * Properties of a SendMessageByResIdRequest.
             * @memberof kritor.message
             * @interface ISendMessageByResIdRequest
             * @property {string|null} [resId] SendMessageByResIdRequest resId
             * @property {kritor.message.IContact|null} [contact] SendMessageByResIdRequest contact
             * @property {number|null} [retryCount] SendMessageByResIdRequest retryCount
             */

            /**
             * Constructs a new SendMessageByResIdRequest.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageByResIdRequest.
             * @implements ISendMessageByResIdRequest
             * @constructor
             * @param {kritor.message.ISendMessageByResIdRequest=} [properties] Properties to set
             */
            function SendMessageByResIdRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageByResIdRequest resId.
             * @member {string} resId
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.resId = "";

            /**
             * SendMessageByResIdRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.contact = null;

            /**
             * SendMessageByResIdRequest retryCount.
             * @member {number|null|undefined} retryCount
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.retryCount = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SendMessageByResIdRequest _retryCount.
             * @member {"retryCount"|undefined} _retryCount
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            Object.defineProperty(SendMessageByResIdRequest.prototype, "_retryCount", {
                get: $util.oneOfGetter($oneOfFields = ["retryCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SendMessageByResIdRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest=} [properties] Properties to set
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest instance
             */
            SendMessageByResIdRequest.create = function create(properties) {
                return new SendMessageByResIdRequest(properties);
            };

            /**
             * Encodes the specified SendMessageByResIdRequest message. Does not implicitly {@link kritor.message.SendMessageByResIdRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest} message SendMessageByResIdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.resId);
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
                return writer;
            };

            /**
             * Encodes the specified SendMessageByResIdRequest message, length delimited. Does not implicitly {@link kritor.message.SendMessageByResIdRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest} message SendMessageByResIdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageByResIdRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageByResIdRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.resId = reader.string();
                            break;
                        }
                    case 2: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.retryCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageByResIdRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageByResIdRequest message.
             * @function verify
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageByResIdRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    properties._retryCount = 1;
                    if (!$util.isInteger(message.retryCount))
                        return "retryCount: integer expected";
                }
                return null;
            };

            /**
             * Creates a SendMessageByResIdRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             */
            SendMessageByResIdRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageByResIdRequest)
                    return object;
                let message = new $root.kritor.message.SendMessageByResIdRequest();
                if (object.resId != null)
                    message.resId = String(object.resId);
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SendMessageByResIdRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.retryCount != null)
                    message.retryCount = object.retryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageByResIdRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.SendMessageByResIdRequest} message SendMessageByResIdRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageByResIdRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.resId = "";
                    object.contact = null;
                }
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    object.retryCount = message.retryCount;
                    if (options.oneofs)
                        object._retryCount = "retryCount";
                }
                return object;
            };

            /**
             * Converts this SendMessageByResIdRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageByResIdRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageByResIdRequest
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageByResIdRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageByResIdRequest";
            };

            return SendMessageByResIdRequest;
        })();

        message.SendMessageByResIdResponse = (function() {

            /**
             * Properties of a SendMessageByResIdResponse.
             * @memberof kritor.message
             * @interface ISendMessageByResIdResponse
             * @property {number|Long|null} [messageId] SendMessageByResIdResponse messageId
             * @property {number|null} [messageTime] SendMessageByResIdResponse messageTime
             */

            /**
             * Constructs a new SendMessageByResIdResponse.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageByResIdResponse.
             * @implements ISendMessageByResIdResponse
             * @constructor
             * @param {kritor.message.ISendMessageByResIdResponse=} [properties] Properties to set
             */
            function SendMessageByResIdResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageByResIdResponse messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             */
            SendMessageByResIdResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendMessageByResIdResponse messageTime.
             * @member {number} messageTime
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             */
            SendMessageByResIdResponse.prototype.messageTime = 0;

            /**
             * Creates a new SendMessageByResIdResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse=} [properties] Properties to set
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse instance
             */
            SendMessageByResIdResponse.create = function create(properties) {
                return new SendMessageByResIdResponse(properties);
            };

            /**
             * Encodes the specified SendMessageByResIdResponse message. Does not implicitly {@link kritor.message.SendMessageByResIdResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse} message SendMessageByResIdResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);
                if (message.messageTime != null && Object.hasOwnProperty.call(message, "messageTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.messageTime);
                return writer;
            };

            /**
             * Encodes the specified SendMessageByResIdResponse message, length delimited. Does not implicitly {@link kritor.message.SendMessageByResIdResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse} message SendMessageByResIdResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageByResIdResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageByResIdResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageTime = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageByResIdResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageByResIdResponse message.
             * @function verify
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageByResIdResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    if (!$util.isInteger(message.messageTime))
                        return "messageTime: integer expected";
                return null;
            };

            /**
             * Creates a SendMessageByResIdResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             */
            SendMessageByResIdResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageByResIdResponse)
                    return object;
                let message = new $root.kritor.message.SendMessageByResIdResponse();
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.messageTime != null)
                    message.messageTime = object.messageTime >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageByResIdResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.SendMessageByResIdResponse} message SendMessageByResIdResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageByResIdResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.messageTime = 0;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    object.messageTime = message.messageTime;
                return object;
            };

            /**
             * Converts this SendMessageByResIdResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageByResIdResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageByResIdResponse
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageByResIdResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageByResIdResponse";
            };

            return SendMessageByResIdResponse;
        })();

        message.ClearMessagesRequest = (function() {

            /**
             * Properties of a ClearMessagesRequest.
             * @memberof kritor.message
             * @interface IClearMessagesRequest
             * @property {kritor.message.IContact|null} [contact] ClearMessagesRequest contact
             */

            /**
             * Constructs a new ClearMessagesRequest.
             * @memberof kritor.message
             * @classdesc Represents a ClearMessagesRequest.
             * @implements IClearMessagesRequest
             * @constructor
             * @param {kritor.message.IClearMessagesRequest=} [properties] Properties to set
             */
            function ClearMessagesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClearMessagesRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.ClearMessagesRequest
             * @instance
             */
            ClearMessagesRequest.prototype.contact = null;

            /**
             * Creates a new ClearMessagesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {kritor.message.IClearMessagesRequest=} [properties] Properties to set
             * @returns {kritor.message.ClearMessagesRequest} ClearMessagesRequest instance
             */
            ClearMessagesRequest.create = function create(properties) {
                return new ClearMessagesRequest(properties);
            };

            /**
             * Encodes the specified ClearMessagesRequest message. Does not implicitly {@link kritor.message.ClearMessagesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {kritor.message.IClearMessagesRequest} message ClearMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearMessagesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ClearMessagesRequest message, length delimited. Does not implicitly {@link kritor.message.ClearMessagesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {kritor.message.IClearMessagesRequest} message ClearMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearMessagesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearMessagesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ClearMessagesRequest} ClearMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearMessagesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ClearMessagesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearMessagesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ClearMessagesRequest} ClearMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearMessagesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearMessagesRequest message.
             * @function verify
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearMessagesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                return null;
            };

            /**
             * Creates a ClearMessagesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ClearMessagesRequest} ClearMessagesRequest
             */
            ClearMessagesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ClearMessagesRequest)
                    return object;
                let message = new $root.kritor.message.ClearMessagesRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.ClearMessagesRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                return message;
            };

            /**
             * Creates a plain object from a ClearMessagesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {kritor.message.ClearMessagesRequest} message ClearMessagesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearMessagesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                return object;
            };

            /**
             * Converts this ClearMessagesRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.ClearMessagesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearMessagesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearMessagesRequest
             * @function getTypeUrl
             * @memberof kritor.message.ClearMessagesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearMessagesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ClearMessagesRequest";
            };

            return ClearMessagesRequest;
        })();

        message.ClearMessagesResponse = (function() {

            /**
             * Properties of a ClearMessagesResponse.
             * @memberof kritor.message
             * @interface IClearMessagesResponse
             */

            /**
             * Constructs a new ClearMessagesResponse.
             * @memberof kritor.message
             * @classdesc Represents a ClearMessagesResponse.
             * @implements IClearMessagesResponse
             * @constructor
             * @param {kritor.message.IClearMessagesResponse=} [properties] Properties to set
             */
            function ClearMessagesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearMessagesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {kritor.message.IClearMessagesResponse=} [properties] Properties to set
             * @returns {kritor.message.ClearMessagesResponse} ClearMessagesResponse instance
             */
            ClearMessagesResponse.create = function create(properties) {
                return new ClearMessagesResponse(properties);
            };

            /**
             * Encodes the specified ClearMessagesResponse message. Does not implicitly {@link kritor.message.ClearMessagesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {kritor.message.IClearMessagesResponse} message ClearMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearMessagesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearMessagesResponse message, length delimited. Does not implicitly {@link kritor.message.ClearMessagesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {kritor.message.IClearMessagesResponse} message ClearMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearMessagesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearMessagesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ClearMessagesResponse} ClearMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearMessagesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ClearMessagesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearMessagesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ClearMessagesResponse} ClearMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearMessagesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearMessagesResponse message.
             * @function verify
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearMessagesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearMessagesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ClearMessagesResponse} ClearMessagesResponse
             */
            ClearMessagesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ClearMessagesResponse)
                    return object;
                return new $root.kritor.message.ClearMessagesResponse();
            };

            /**
             * Creates a plain object from a ClearMessagesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {kritor.message.ClearMessagesResponse} message ClearMessagesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearMessagesResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearMessagesResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.ClearMessagesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearMessagesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearMessagesResponse
             * @function getTypeUrl
             * @memberof kritor.message.ClearMessagesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearMessagesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ClearMessagesResponse";
            };

            return ClearMessagesResponse;
        })();

        message.RecallMessageRequest = (function() {

            /**
             * Properties of a RecallMessageRequest.
             * @memberof kritor.message
             * @interface IRecallMessageRequest
             * @property {kritor.message.IContact|null} [contact] RecallMessageRequest contact
             * @property {number|Long|null} [messageId] RecallMessageRequest messageId
             */

            /**
             * Constructs a new RecallMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a RecallMessageRequest.
             * @implements IRecallMessageRequest
             * @constructor
             * @param {kritor.message.IRecallMessageRequest=} [properties] Properties to set
             */
            function RecallMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RecallMessageRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             */
            RecallMessageRequest.prototype.contact = null;

            /**
             * RecallMessageRequest messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             */
            RecallMessageRequest.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new RecallMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest instance
             */
            RecallMessageRequest.create = function create(properties) {
                return new RecallMessageRequest(properties);
            };

            /**
             * Encodes the specified RecallMessageRequest message. Does not implicitly {@link kritor.message.RecallMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest} message RecallMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified RecallMessageRequest message, length delimited. Does not implicitly {@link kritor.message.RecallMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest} message RecallMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecallMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RecallMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecallMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecallMessageRequest message.
             * @function verify
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecallMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a RecallMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             */
            RecallMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RecallMessageRequest)
                    return object;
                let message = new $root.kritor.message.RecallMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.RecallMessageRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a RecallMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.RecallMessageRequest} message RecallMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecallMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this RecallMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecallMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RecallMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RecallMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RecallMessageRequest";
            };

            return RecallMessageRequest;
        })();

        message.RecallMessageResponse = (function() {

            /**
             * Properties of a RecallMessageResponse.
             * @memberof kritor.message
             * @interface IRecallMessageResponse
             */

            /**
             * Constructs a new RecallMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a RecallMessageResponse.
             * @implements IRecallMessageResponse
             * @constructor
             * @param {kritor.message.IRecallMessageResponse=} [properties] Properties to set
             */
            function RecallMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RecallMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse instance
             */
            RecallMessageResponse.create = function create(properties) {
                return new RecallMessageResponse(properties);
            };

            /**
             * Encodes the specified RecallMessageResponse message. Does not implicitly {@link kritor.message.RecallMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse} message RecallMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RecallMessageResponse message, length delimited. Does not implicitly {@link kritor.message.RecallMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse} message RecallMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecallMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RecallMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecallMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecallMessageResponse message.
             * @function verify
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecallMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RecallMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             */
            RecallMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RecallMessageResponse)
                    return object;
                return new $root.kritor.message.RecallMessageResponse();
            };

            /**
             * Creates a plain object from a RecallMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.RecallMessageResponse} message RecallMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecallMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RecallMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.RecallMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecallMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RecallMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RecallMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RecallMessageResponse";
            };

            return RecallMessageResponse;
        })();

        message.SetMessageCommentEmojiRequest = (function() {

            /**
             * Properties of a SetMessageCommentEmojiRequest.
             * @memberof kritor.message
             * @interface ISetMessageCommentEmojiRequest
             * @property {kritor.message.IContact|null} [contact] SetMessageCommentEmojiRequest contact
             * @property {number|Long|null} [messageId] SetMessageCommentEmojiRequest messageId
             * @property {number|null} [faceId] SetMessageCommentEmojiRequest faceId
             * @property {boolean|null} [isComment] SetMessageCommentEmojiRequest isComment
             */

            /**
             * Constructs a new SetMessageCommentEmojiRequest.
             * @memberof kritor.message
             * @classdesc Represents a SetMessageCommentEmojiRequest.
             * @implements ISetMessageCommentEmojiRequest
             * @constructor
             * @param {kritor.message.ISetMessageCommentEmojiRequest=} [properties] Properties to set
             */
            function SetMessageCommentEmojiRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetMessageCommentEmojiRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @instance
             */
            SetMessageCommentEmojiRequest.prototype.contact = null;

            /**
             * SetMessageCommentEmojiRequest messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @instance
             */
            SetMessageCommentEmojiRequest.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetMessageCommentEmojiRequest faceId.
             * @member {number} faceId
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @instance
             */
            SetMessageCommentEmojiRequest.prototype.faceId = 0;

            /**
             * SetMessageCommentEmojiRequest isComment.
             * @member {boolean|null|undefined} isComment
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @instance
             */
            SetMessageCommentEmojiRequest.prototype.isComment = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetMessageCommentEmojiRequest _isComment.
             * @member {"isComment"|undefined} _isComment
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @instance
             */
            Object.defineProperty(SetMessageCommentEmojiRequest.prototype, "_isComment", {
                get: $util.oneOfGetter($oneOfFields = ["isComment"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetMessageCommentEmojiRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {kritor.message.ISetMessageCommentEmojiRequest=} [properties] Properties to set
             * @returns {kritor.message.SetMessageCommentEmojiRequest} SetMessageCommentEmojiRequest instance
             */
            SetMessageCommentEmojiRequest.create = function create(properties) {
                return new SetMessageCommentEmojiRequest(properties);
            };

            /**
             * Encodes the specified SetMessageCommentEmojiRequest message. Does not implicitly {@link kritor.message.SetMessageCommentEmojiRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {kritor.message.ISetMessageCommentEmojiRequest} message SetMessageCommentEmojiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageCommentEmojiRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                if (message.faceId != null && Object.hasOwnProperty.call(message, "faceId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.faceId);
                if (message.isComment != null && Object.hasOwnProperty.call(message, "isComment"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isComment);
                return writer;
            };

            /**
             * Encodes the specified SetMessageCommentEmojiRequest message, length delimited. Does not implicitly {@link kritor.message.SetMessageCommentEmojiRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {kritor.message.ISetMessageCommentEmojiRequest} message SetMessageCommentEmojiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageCommentEmojiRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetMessageCommentEmojiRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetMessageCommentEmojiRequest} SetMessageCommentEmojiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageCommentEmojiRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetMessageCommentEmojiRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.faceId = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.isComment = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetMessageCommentEmojiRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetMessageCommentEmojiRequest} SetMessageCommentEmojiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageCommentEmojiRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetMessageCommentEmojiRequest message.
             * @function verify
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetMessageCommentEmojiRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.faceId != null && message.hasOwnProperty("faceId"))
                    if (!$util.isInteger(message.faceId))
                        return "faceId: integer expected";
                if (message.isComment != null && message.hasOwnProperty("isComment")) {
                    properties._isComment = 1;
                    if (typeof message.isComment !== "boolean")
                        return "isComment: boolean expected";
                }
                return null;
            };

            /**
             * Creates a SetMessageCommentEmojiRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetMessageCommentEmojiRequest} SetMessageCommentEmojiRequest
             */
            SetMessageCommentEmojiRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetMessageCommentEmojiRequest)
                    return object;
                let message = new $root.kritor.message.SetMessageCommentEmojiRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SetMessageCommentEmojiRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.faceId != null)
                    message.faceId = object.faceId >>> 0;
                if (object.isComment != null)
                    message.isComment = Boolean(object.isComment);
                return message;
            };

            /**
             * Creates a plain object from a SetMessageCommentEmojiRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {kritor.message.SetMessageCommentEmojiRequest} message SetMessageCommentEmojiRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetMessageCommentEmojiRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    object.faceId = 0;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.faceId != null && message.hasOwnProperty("faceId"))
                    object.faceId = message.faceId;
                if (message.isComment != null && message.hasOwnProperty("isComment")) {
                    object.isComment = message.isComment;
                    if (options.oneofs)
                        object._isComment = "isComment";
                }
                return object;
            };

            /**
             * Converts this SetMessageCommentEmojiRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetMessageCommentEmojiRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetMessageCommentEmojiRequest
             * @function getTypeUrl
             * @memberof kritor.message.SetMessageCommentEmojiRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetMessageCommentEmojiRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetMessageCommentEmojiRequest";
            };

            return SetMessageCommentEmojiRequest;
        })();

        message.SetMessageCommentEmojiResponse = (function() {

            /**
             * Properties of a SetMessageCommentEmojiResponse.
             * @memberof kritor.message
             * @interface ISetMessageCommentEmojiResponse
             */

            /**
             * Constructs a new SetMessageCommentEmojiResponse.
             * @memberof kritor.message
             * @classdesc Represents a SetMessageCommentEmojiResponse.
             * @implements ISetMessageCommentEmojiResponse
             * @constructor
             * @param {kritor.message.ISetMessageCommentEmojiResponse=} [properties] Properties to set
             */
            function SetMessageCommentEmojiResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetMessageCommentEmojiResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {kritor.message.ISetMessageCommentEmojiResponse=} [properties] Properties to set
             * @returns {kritor.message.SetMessageCommentEmojiResponse} SetMessageCommentEmojiResponse instance
             */
            SetMessageCommentEmojiResponse.create = function create(properties) {
                return new SetMessageCommentEmojiResponse(properties);
            };

            /**
             * Encodes the specified SetMessageCommentEmojiResponse message. Does not implicitly {@link kritor.message.SetMessageCommentEmojiResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {kritor.message.ISetMessageCommentEmojiResponse} message SetMessageCommentEmojiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageCommentEmojiResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetMessageCommentEmojiResponse message, length delimited. Does not implicitly {@link kritor.message.SetMessageCommentEmojiResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {kritor.message.ISetMessageCommentEmojiResponse} message SetMessageCommentEmojiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageCommentEmojiResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetMessageCommentEmojiResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetMessageCommentEmojiResponse} SetMessageCommentEmojiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageCommentEmojiResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetMessageCommentEmojiResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetMessageCommentEmojiResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetMessageCommentEmojiResponse} SetMessageCommentEmojiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageCommentEmojiResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetMessageCommentEmojiResponse message.
             * @function verify
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetMessageCommentEmojiResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetMessageCommentEmojiResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetMessageCommentEmojiResponse} SetMessageCommentEmojiResponse
             */
            SetMessageCommentEmojiResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetMessageCommentEmojiResponse)
                    return object;
                return new $root.kritor.message.SetMessageCommentEmojiResponse();
            };

            /**
             * Creates a plain object from a SetMessageCommentEmojiResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {kritor.message.SetMessageCommentEmojiResponse} message SetMessageCommentEmojiResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetMessageCommentEmojiResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetMessageCommentEmojiResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetMessageCommentEmojiResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetMessageCommentEmojiResponse
             * @function getTypeUrl
             * @memberof kritor.message.SetMessageCommentEmojiResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetMessageCommentEmojiResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetMessageCommentEmojiResponse";
            };

            return SetMessageCommentEmojiResponse;
        })();

        message.GetForwardMessagesRequest = (function() {

            /**
             * Properties of a GetForwardMessagesRequest.
             * @memberof kritor.message
             * @interface IGetForwardMessagesRequest
             * @property {string|null} [resId] GetForwardMessagesRequest resId
             */

            /**
             * Constructs a new GetForwardMessagesRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetForwardMessagesRequest.
             * @implements IGetForwardMessagesRequest
             * @constructor
             * @param {kritor.message.IGetForwardMessagesRequest=} [properties] Properties to set
             */
            function GetForwardMessagesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetForwardMessagesRequest resId.
             * @member {string} resId
             * @memberof kritor.message.GetForwardMessagesRequest
             * @instance
             */
            GetForwardMessagesRequest.prototype.resId = "";

            /**
             * Creates a new GetForwardMessagesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {kritor.message.IGetForwardMessagesRequest=} [properties] Properties to set
             * @returns {kritor.message.GetForwardMessagesRequest} GetForwardMessagesRequest instance
             */
            GetForwardMessagesRequest.create = function create(properties) {
                return new GetForwardMessagesRequest(properties);
            };

            /**
             * Encodes the specified GetForwardMessagesRequest message. Does not implicitly {@link kritor.message.GetForwardMessagesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {kritor.message.IGetForwardMessagesRequest} message GetForwardMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetForwardMessagesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.resId);
                return writer;
            };

            /**
             * Encodes the specified GetForwardMessagesRequest message, length delimited. Does not implicitly {@link kritor.message.GetForwardMessagesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {kritor.message.IGetForwardMessagesRequest} message GetForwardMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetForwardMessagesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetForwardMessagesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetForwardMessagesRequest} GetForwardMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetForwardMessagesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetForwardMessagesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.resId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetForwardMessagesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetForwardMessagesRequest} GetForwardMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetForwardMessagesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetForwardMessagesRequest message.
             * @function verify
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetForwardMessagesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                return null;
            };

            /**
             * Creates a GetForwardMessagesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetForwardMessagesRequest} GetForwardMessagesRequest
             */
            GetForwardMessagesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetForwardMessagesRequest)
                    return object;
                let message = new $root.kritor.message.GetForwardMessagesRequest();
                if (object.resId != null)
                    message.resId = String(object.resId);
                return message;
            };

            /**
             * Creates a plain object from a GetForwardMessagesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {kritor.message.GetForwardMessagesRequest} message GetForwardMessagesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetForwardMessagesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.resId = "";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                return object;
            };

            /**
             * Converts this GetForwardMessagesRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetForwardMessagesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetForwardMessagesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetForwardMessagesRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetForwardMessagesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetForwardMessagesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetForwardMessagesRequest";
            };

            return GetForwardMessagesRequest;
        })();

        message.GetForwardMessagesResponse = (function() {

            /**
             * Properties of a GetForwardMessagesResponse.
             * @memberof kritor.message
             * @interface IGetForwardMessagesResponse
             * @property {Array.<kritor.message.IMessageBody>|null} [messages] GetForwardMessagesResponse messages
             */

            /**
             * Constructs a new GetForwardMessagesResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetForwardMessagesResponse.
             * @implements IGetForwardMessagesResponse
             * @constructor
             * @param {kritor.message.IGetForwardMessagesResponse=} [properties] Properties to set
             */
            function GetForwardMessagesResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetForwardMessagesResponse messages.
             * @member {Array.<kritor.message.IMessageBody>} messages
             * @memberof kritor.message.GetForwardMessagesResponse
             * @instance
             */
            GetForwardMessagesResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetForwardMessagesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {kritor.message.IGetForwardMessagesResponse=} [properties] Properties to set
             * @returns {kritor.message.GetForwardMessagesResponse} GetForwardMessagesResponse instance
             */
            GetForwardMessagesResponse.create = function create(properties) {
                return new GetForwardMessagesResponse(properties);
            };

            /**
             * Encodes the specified GetForwardMessagesResponse message. Does not implicitly {@link kritor.message.GetForwardMessagesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {kritor.message.IGetForwardMessagesResponse} message GetForwardMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetForwardMessagesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.message.MessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetForwardMessagesResponse message, length delimited. Does not implicitly {@link kritor.message.GetForwardMessagesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {kritor.message.IGetForwardMessagesResponse} message GetForwardMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetForwardMessagesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetForwardMessagesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetForwardMessagesResponse} GetForwardMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetForwardMessagesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetForwardMessagesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.message.MessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetForwardMessagesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetForwardMessagesResponse} GetForwardMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetForwardMessagesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetForwardMessagesResponse message.
             * @function verify
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetForwardMessagesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.message.MessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetForwardMessagesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetForwardMessagesResponse} GetForwardMessagesResponse
             */
            GetForwardMessagesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetForwardMessagesResponse)
                    return object;
                let message = new $root.kritor.message.GetForwardMessagesResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetForwardMessagesResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetForwardMessagesResponse.messages: object expected");
                        message.messages[i] = $root.kritor.message.MessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetForwardMessagesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {kritor.message.GetForwardMessagesResponse} message GetForwardMessagesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetForwardMessagesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.message.MessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetForwardMessagesResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetForwardMessagesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetForwardMessagesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetForwardMessagesResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetForwardMessagesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetForwardMessagesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetForwardMessagesResponse";
            };

            return GetForwardMessagesResponse;
        })();

        message.GetMessageRequest = (function() {

            /**
             * Properties of a GetMessageRequest.
             * @memberof kritor.message
             * @interface IGetMessageRequest
             * @property {kritor.message.IContact|null} [contact] GetMessageRequest contact
             * @property {number|Long|null} [messageId] GetMessageRequest messageId
             */

            /**
             * Constructs a new GetMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageRequest.
             * @implements IGetMessageRequest
             * @constructor
             * @param {kritor.message.IGetMessageRequest=} [properties] Properties to set
             */
            function GetMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.GetMessageRequest
             * @instance
             */
            GetMessageRequest.prototype.contact = null;

            /**
             * GetMessageRequest messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.GetMessageRequest
             * @instance
             */
            GetMessageRequest.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest instance
             */
            GetMessageRequest.create = function create(properties) {
                return new GetMessageRequest(properties);
            };

            /**
             * Encodes the specified GetMessageRequest message. Does not implicitly {@link kritor.message.GetMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest} message GetMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified GetMessageRequest message, length delimited. Does not implicitly {@link kritor.message.GetMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest} message GetMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageRequest message.
             * @function verify
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             */
            GetMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageRequest)
                    return object;
                let message = new $root.kritor.message.GetMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetMessageRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.GetMessageRequest} message GetMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this GetMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageRequest";
            };

            return GetMessageRequest;
        })();

        message.GetMessageResponse = (function() {

            /**
             * Properties of a GetMessageResponse.
             * @memberof kritor.message
             * @interface IGetMessageResponse
             * @property {kritor.message.IMessageBody|null} [message] GetMessageResponse message
             */

            /**
             * Constructs a new GetMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageResponse.
             * @implements IGetMessageResponse
             * @constructor
             * @param {kritor.message.IGetMessageResponse=} [properties] Properties to set
             */
            function GetMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageResponse message.
             * @member {kritor.message.IMessageBody|null|undefined} message
             * @memberof kritor.message.GetMessageResponse
             * @instance
             */
            GetMessageResponse.prototype.message = null;

            /**
             * Creates a new GetMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse instance
             */
            GetMessageResponse.create = function create(properties) {
                return new GetMessageResponse(properties);
            };

            /**
             * Encodes the specified GetMessageResponse message. Does not implicitly {@link kritor.message.GetMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse} message GetMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.message.MessageBody.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMessageResponse message, length delimited. Does not implicitly {@link kritor.message.GetMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse} message GetMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message = $root.kritor.message.MessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageResponse message.
             * @function verify
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.kritor.message.MessageBody.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a GetMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             */
            GetMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageResponse)
                    return object;
                let message = new $root.kritor.message.GetMessageResponse();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.message.GetMessageResponse.message: object expected");
                    message.message = $root.kritor.message.MessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.GetMessageResponse} message GetMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.kritor.message.MessageBody.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this GetMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageResponse";
            };

            return GetMessageResponse;
        })();

        message.GetMessageBySeqRequest = (function() {

            /**
             * Properties of a GetMessageBySeqRequest.
             * @memberof kritor.message
             * @interface IGetMessageBySeqRequest
             * @property {kritor.message.IContact|null} [contact] GetMessageBySeqRequest contact
             * @property {number|Long|null} [messageSeq] GetMessageBySeqRequest messageSeq
             */

            /**
             * Constructs a new GetMessageBySeqRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageBySeqRequest.
             * @implements IGetMessageBySeqRequest
             * @constructor
             * @param {kritor.message.IGetMessageBySeqRequest=} [properties] Properties to set
             */
            function GetMessageBySeqRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageBySeqRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             */
            GetMessageBySeqRequest.prototype.contact = null;

            /**
             * GetMessageBySeqRequest messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             */
            GetMessageBySeqRequest.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetMessageBySeqRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest=} [properties] Properties to set
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest instance
             */
            GetMessageBySeqRequest.create = function create(properties) {
                return new GetMessageBySeqRequest(properties);
            };

            /**
             * Encodes the specified GetMessageBySeqRequest message. Does not implicitly {@link kritor.message.GetMessageBySeqRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest} message GetMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageSeq);
                return writer;
            };

            /**
             * Encodes the specified GetMessageBySeqRequest message, length delimited. Does not implicitly {@link kritor.message.GetMessageBySeqRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest} message GetMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageBySeqRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageBySeqRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageBySeqRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageBySeqRequest message.
             * @function verify
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageBySeqRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetMessageBySeqRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             */
            GetMessageBySeqRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageBySeqRequest)
                    return object;
                let message = new $root.kritor.message.GetMessageBySeqRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetMessageBySeqRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetMessageBySeqRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.GetMessageBySeqRequest} message GetMessageBySeqRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageBySeqRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                return object;
            };

            /**
             * Converts this GetMessageBySeqRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageBySeqRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageBySeqRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageBySeqRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageBySeqRequest";
            };

            return GetMessageBySeqRequest;
        })();

        message.GetMessageBySeqResponse = (function() {

            /**
             * Properties of a GetMessageBySeqResponse.
             * @memberof kritor.message
             * @interface IGetMessageBySeqResponse
             * @property {kritor.message.IMessageBody|null} [message] GetMessageBySeqResponse message
             */

            /**
             * Constructs a new GetMessageBySeqResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageBySeqResponse.
             * @implements IGetMessageBySeqResponse
             * @constructor
             * @param {kritor.message.IGetMessageBySeqResponse=} [properties] Properties to set
             */
            function GetMessageBySeqResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageBySeqResponse message.
             * @member {kritor.message.IMessageBody|null|undefined} message
             * @memberof kritor.message.GetMessageBySeqResponse
             * @instance
             */
            GetMessageBySeqResponse.prototype.message = null;

            /**
             * Creates a new GetMessageBySeqResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse=} [properties] Properties to set
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse instance
             */
            GetMessageBySeqResponse.create = function create(properties) {
                return new GetMessageBySeqResponse(properties);
            };

            /**
             * Encodes the specified GetMessageBySeqResponse message. Does not implicitly {@link kritor.message.GetMessageBySeqResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse} message GetMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.message.MessageBody.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMessageBySeqResponse message, length delimited. Does not implicitly {@link kritor.message.GetMessageBySeqResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse} message GetMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageBySeqResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageBySeqResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message = $root.kritor.message.MessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageBySeqResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageBySeqResponse message.
             * @function verify
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageBySeqResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.kritor.message.MessageBody.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a GetMessageBySeqResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             */
            GetMessageBySeqResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageBySeqResponse)
                    return object;
                let message = new $root.kritor.message.GetMessageBySeqResponse();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.message.GetMessageBySeqResponse.message: object expected");
                    message.message = $root.kritor.message.MessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMessageBySeqResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.GetMessageBySeqResponse} message GetMessageBySeqResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageBySeqResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.kritor.message.MessageBody.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this GetMessageBySeqResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageBySeqResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageBySeqResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageBySeqResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageBySeqResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageBySeqResponse";
            };

            return GetMessageBySeqResponse;
        })();

        message.GetHistoryMessageRequest = (function() {

            /**
             * Properties of a GetHistoryMessageRequest.
             * @memberof kritor.message
             * @interface IGetHistoryMessageRequest
             * @property {kritor.message.IContact|null} [contact] GetHistoryMessageRequest contact
             * @property {number|Long|null} [startMessageId] GetHistoryMessageRequest startMessageId
             * @property {number|null} [count] GetHistoryMessageRequest count
             */

            /**
             * Constructs a new GetHistoryMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageRequest.
             * @implements IGetHistoryMessageRequest
             * @constructor
             * @param {kritor.message.IGetHistoryMessageRequest=} [properties] Properties to set
             */
            function GetHistoryMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageRequest contact.
             * @member {kritor.message.IContact|null|undefined} contact
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.contact = null;

            /**
             * GetHistoryMessageRequest startMessageId.
             * @member {number|Long|null|undefined} startMessageId
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.startMessageId = null;

            /**
             * GetHistoryMessageRequest count.
             * @member {number|null|undefined} count
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetHistoryMessageRequest _startMessageId.
             * @member {"startMessageId"|undefined} _startMessageId
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageRequest.prototype, "_startMessageId", {
                get: $util.oneOfGetter($oneOfFields = ["startMessageId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetHistoryMessageRequest _count.
             * @member {"count"|undefined} _count
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageRequest.prototype, "_count", {
                get: $util.oneOfGetter($oneOfFields = ["count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetHistoryMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest instance
             */
            GetHistoryMessageRequest.create = function create(properties) {
                return new GetHistoryMessageRequest(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageRequest message. Does not implicitly {@link kritor.message.GetHistoryMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest} message GetHistoryMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.message.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.startMessageId != null && Object.hasOwnProperty.call(message, "startMessageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.startMessageId);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageRequest message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest} message GetHistoryMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.message.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.startMessageId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageRequest message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.message.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.startMessageId != null && message.hasOwnProperty("startMessageId")) {
                    properties._startMessageId = 1;
                    if (!$util.isInteger(message.startMessageId) && !(message.startMessageId && $util.isInteger(message.startMessageId.low) && $util.isInteger(message.startMessageId.high)))
                        return "startMessageId: integer|Long expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    properties._count = 1;
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             */
            GetHistoryMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageRequest)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetHistoryMessageRequest.contact: object expected");
                    message.contact = $root.kritor.message.Contact.fromObject(object.contact);
                }
                if (object.startMessageId != null)
                    if ($util.Long)
                        (message.startMessageId = $util.Long.fromValue(object.startMessageId)).unsigned = true;
                    else if (typeof object.startMessageId === "string")
                        message.startMessageId = parseInt(object.startMessageId, 10);
                    else if (typeof object.startMessageId === "number")
                        message.startMessageId = object.startMessageId;
                    else if (typeof object.startMessageId === "object")
                        message.startMessageId = new $util.LongBits(object.startMessageId.low >>> 0, object.startMessageId.high >>> 0).toNumber(true);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.GetHistoryMessageRequest} message GetHistoryMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.message.Contact.toObject(message.contact, options);
                if (message.startMessageId != null && message.hasOwnProperty("startMessageId")) {
                    if (typeof message.startMessageId === "number")
                        object.startMessageId = options.longs === String ? String(message.startMessageId) : message.startMessageId;
                    else
                        object.startMessageId = options.longs === String ? $util.Long.prototype.toString.call(message.startMessageId) : options.longs === Number ? new $util.LongBits(message.startMessageId.low >>> 0, message.startMessageId.high >>> 0).toNumber(true) : message.startMessageId;
                    if (options.oneofs)
                        object._startMessageId = "startMessageId";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    object.count = message.count;
                    if (options.oneofs)
                        object._count = "count";
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageRequest";
            };

            return GetHistoryMessageRequest;
        })();

        message.GetHistoryMessageResponse = (function() {

            /**
             * Properties of a GetHistoryMessageResponse.
             * @memberof kritor.message
             * @interface IGetHistoryMessageResponse
             * @property {Array.<kritor.message.IMessageBody>|null} [messages] GetHistoryMessageResponse messages
             */

            /**
             * Constructs a new GetHistoryMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageResponse.
             * @implements IGetHistoryMessageResponse
             * @constructor
             * @param {kritor.message.IGetHistoryMessageResponse=} [properties] Properties to set
             */
            function GetHistoryMessageResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageResponse messages.
             * @member {Array.<kritor.message.IMessageBody>} messages
             * @memberof kritor.message.GetHistoryMessageResponse
             * @instance
             */
            GetHistoryMessageResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetHistoryMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse instance
             */
            GetHistoryMessageResponse.create = function create(properties) {
                return new GetHistoryMessageResponse(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageResponse message. Does not implicitly {@link kritor.message.GetHistoryMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse} message GetHistoryMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.message.MessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageResponse message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse} message GetHistoryMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.message.MessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageResponse message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.message.MessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             */
            GetHistoryMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageResponse)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetHistoryMessageResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetHistoryMessageResponse.messages: object expected");
                        message.messages[i] = $root.kritor.message.MessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.GetHistoryMessageResponse} message GetHistoryMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.message.MessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageResponse";
            };

            return GetHistoryMessageResponse;
        })();

        message.DeleteEssenceMsgRequest = (function() {

            /**
             * Properties of a DeleteEssenceMsgRequest.
             * @memberof kritor.message
             * @interface IDeleteEssenceMsgRequest
             * @property {number|Long|null} [groupId] DeleteEssenceMsgRequest groupId
             * @property {number|Long|null} [messageId] DeleteEssenceMsgRequest messageId
             */

            /**
             * Constructs a new DeleteEssenceMsgRequest.
             * @memberof kritor.message
             * @classdesc Represents a DeleteEssenceMsgRequest.
             * @implements IDeleteEssenceMsgRequest
             * @constructor
             * @param {kritor.message.IDeleteEssenceMsgRequest=} [properties] Properties to set
             */
            function DeleteEssenceMsgRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteEssenceMsgRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @instance
             */
            DeleteEssenceMsgRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteEssenceMsgRequest messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @instance
             */
            DeleteEssenceMsgRequest.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new DeleteEssenceMsgRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMsgRequest=} [properties] Properties to set
             * @returns {kritor.message.DeleteEssenceMsgRequest} DeleteEssenceMsgRequest instance
             */
            DeleteEssenceMsgRequest.create = function create(properties) {
                return new DeleteEssenceMsgRequest(properties);
            };

            /**
             * Encodes the specified DeleteEssenceMsgRequest message. Does not implicitly {@link kritor.message.DeleteEssenceMsgRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMsgRequest} message DeleteEssenceMsgRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMsgRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified DeleteEssenceMsgRequest message, length delimited. Does not implicitly {@link kritor.message.DeleteEssenceMsgRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMsgRequest} message DeleteEssenceMsgRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMsgRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteEssenceMsgRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DeleteEssenceMsgRequest} DeleteEssenceMsgRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMsgRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DeleteEssenceMsgRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteEssenceMsgRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DeleteEssenceMsgRequest} DeleteEssenceMsgRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMsgRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteEssenceMsgRequest message.
             * @function verify
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteEssenceMsgRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a DeleteEssenceMsgRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DeleteEssenceMsgRequest} DeleteEssenceMsgRequest
             */
            DeleteEssenceMsgRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DeleteEssenceMsgRequest)
                    return object;
                let message = new $root.kritor.message.DeleteEssenceMsgRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a DeleteEssenceMsgRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {kritor.message.DeleteEssenceMsgRequest} message DeleteEssenceMsgRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteEssenceMsgRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this DeleteEssenceMsgRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteEssenceMsgRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteEssenceMsgRequest
             * @function getTypeUrl
             * @memberof kritor.message.DeleteEssenceMsgRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteEssenceMsgRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DeleteEssenceMsgRequest";
            };

            return DeleteEssenceMsgRequest;
        })();

        message.DeleteEssenceMsgResponse = (function() {

            /**
             * Properties of a DeleteEssenceMsgResponse.
             * @memberof kritor.message
             * @interface IDeleteEssenceMsgResponse
             */

            /**
             * Constructs a new DeleteEssenceMsgResponse.
             * @memberof kritor.message
             * @classdesc Represents a DeleteEssenceMsgResponse.
             * @implements IDeleteEssenceMsgResponse
             * @constructor
             * @param {kritor.message.IDeleteEssenceMsgResponse=} [properties] Properties to set
             */
            function DeleteEssenceMsgResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteEssenceMsgResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMsgResponse=} [properties] Properties to set
             * @returns {kritor.message.DeleteEssenceMsgResponse} DeleteEssenceMsgResponse instance
             */
            DeleteEssenceMsgResponse.create = function create(properties) {
                return new DeleteEssenceMsgResponse(properties);
            };

            /**
             * Encodes the specified DeleteEssenceMsgResponse message. Does not implicitly {@link kritor.message.DeleteEssenceMsgResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMsgResponse} message DeleteEssenceMsgResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMsgResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteEssenceMsgResponse message, length delimited. Does not implicitly {@link kritor.message.DeleteEssenceMsgResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMsgResponse} message DeleteEssenceMsgResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMsgResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteEssenceMsgResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DeleteEssenceMsgResponse} DeleteEssenceMsgResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMsgResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DeleteEssenceMsgResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteEssenceMsgResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DeleteEssenceMsgResponse} DeleteEssenceMsgResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMsgResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteEssenceMsgResponse message.
             * @function verify
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteEssenceMsgResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteEssenceMsgResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DeleteEssenceMsgResponse} DeleteEssenceMsgResponse
             */
            DeleteEssenceMsgResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DeleteEssenceMsgResponse)
                    return object;
                return new $root.kritor.message.DeleteEssenceMsgResponse();
            };

            /**
             * Creates a plain object from a DeleteEssenceMsgResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {kritor.message.DeleteEssenceMsgResponse} message DeleteEssenceMsgResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteEssenceMsgResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteEssenceMsgResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteEssenceMsgResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteEssenceMsgResponse
             * @function getTypeUrl
             * @memberof kritor.message.DeleteEssenceMsgResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteEssenceMsgResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DeleteEssenceMsgResponse";
            };

            return DeleteEssenceMsgResponse;
        })();

        message.GetEssenceMessagesRequest = (function() {

            /**
             * Properties of a GetEssenceMessagesRequest.
             * @memberof kritor.message
             * @interface IGetEssenceMessagesRequest
             * @property {number|Long|null} [groupId] GetEssenceMessagesRequest groupId
             * @property {number|null} [page] GetEssenceMessagesRequest page
             * @property {number|null} [pageSize] GetEssenceMessagesRequest pageSize
             */

            /**
             * Constructs a new GetEssenceMessagesRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetEssenceMessagesRequest.
             * @implements IGetEssenceMessagesRequest
             * @constructor
             * @param {kritor.message.IGetEssenceMessagesRequest=} [properties] Properties to set
             */
            function GetEssenceMessagesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEssenceMessagesRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @instance
             */
            GetEssenceMessagesRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetEssenceMessagesRequest page.
             * @member {number} page
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @instance
             */
            GetEssenceMessagesRequest.prototype.page = 0;

            /**
             * GetEssenceMessagesRequest pageSize.
             * @member {number} pageSize
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @instance
             */
            GetEssenceMessagesRequest.prototype.pageSize = 0;

            /**
             * Creates a new GetEssenceMessagesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {kritor.message.IGetEssenceMessagesRequest=} [properties] Properties to set
             * @returns {kritor.message.GetEssenceMessagesRequest} GetEssenceMessagesRequest instance
             */
            GetEssenceMessagesRequest.create = function create(properties) {
                return new GetEssenceMessagesRequest(properties);
            };

            /**
             * Encodes the specified GetEssenceMessagesRequest message. Does not implicitly {@link kritor.message.GetEssenceMessagesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {kritor.message.IGetEssenceMessagesRequest} message GetEssenceMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessagesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.page);
                if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.pageSize);
                return writer;
            };

            /**
             * Encodes the specified GetEssenceMessagesRequest message, length delimited. Does not implicitly {@link kritor.message.GetEssenceMessagesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {kritor.message.IGetEssenceMessagesRequest} message GetEssenceMessagesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessagesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEssenceMessagesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetEssenceMessagesRequest} GetEssenceMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessagesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetEssenceMessagesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.page = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.pageSize = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEssenceMessagesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetEssenceMessagesRequest} GetEssenceMessagesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessagesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEssenceMessagesRequest message.
             * @function verify
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEssenceMessagesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize))
                        return "pageSize: integer expected";
                return null;
            };

            /**
             * Creates a GetEssenceMessagesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetEssenceMessagesRequest} GetEssenceMessagesRequest
             */
            GetEssenceMessagesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetEssenceMessagesRequest)
                    return object;
                let message = new $root.kritor.message.GetEssenceMessagesRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.page != null)
                    message.page = object.page >>> 0;
                if (object.pageSize != null)
                    message.pageSize = object.pageSize >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetEssenceMessagesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {kritor.message.GetEssenceMessagesRequest} message GetEssenceMessagesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEssenceMessagesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.page = 0;
                    object.pageSize = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    object.pageSize = message.pageSize;
                return object;
            };

            /**
             * Converts this GetEssenceMessagesRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEssenceMessagesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEssenceMessagesRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetEssenceMessagesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEssenceMessagesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetEssenceMessagesRequest";
            };

            return GetEssenceMessagesRequest;
        })();

        message.GetEssenceMessagesResponse = (function() {

            /**
             * Properties of a GetEssenceMessagesResponse.
             * @memberof kritor.message
             * @interface IGetEssenceMessagesResponse
             * @property {Array.<kritor.message.IEssenceMessage>|null} [essenceMessage] GetEssenceMessagesResponse essenceMessage
             */

            /**
             * Constructs a new GetEssenceMessagesResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetEssenceMessagesResponse.
             * @implements IGetEssenceMessagesResponse
             * @constructor
             * @param {kritor.message.IGetEssenceMessagesResponse=} [properties] Properties to set
             */
            function GetEssenceMessagesResponse(properties) {
                this.essenceMessage = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEssenceMessagesResponse essenceMessage.
             * @member {Array.<kritor.message.IEssenceMessage>} essenceMessage
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @instance
             */
            GetEssenceMessagesResponse.prototype.essenceMessage = $util.emptyArray;

            /**
             * Creates a new GetEssenceMessagesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {kritor.message.IGetEssenceMessagesResponse=} [properties] Properties to set
             * @returns {kritor.message.GetEssenceMessagesResponse} GetEssenceMessagesResponse instance
             */
            GetEssenceMessagesResponse.create = function create(properties) {
                return new GetEssenceMessagesResponse(properties);
            };

            /**
             * Encodes the specified GetEssenceMessagesResponse message. Does not implicitly {@link kritor.message.GetEssenceMessagesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {kritor.message.IGetEssenceMessagesResponse} message GetEssenceMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessagesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.essenceMessage != null && message.essenceMessage.length)
                    for (let i = 0; i < message.essenceMessage.length; ++i)
                        $root.kritor.message.EssenceMessage.encode(message.essenceMessage[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetEssenceMessagesResponse message, length delimited. Does not implicitly {@link kritor.message.GetEssenceMessagesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {kritor.message.IGetEssenceMessagesResponse} message GetEssenceMessagesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessagesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEssenceMessagesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetEssenceMessagesResponse} GetEssenceMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessagesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetEssenceMessagesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.essenceMessage && message.essenceMessage.length))
                                message.essenceMessage = [];
                            message.essenceMessage.push($root.kritor.message.EssenceMessage.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEssenceMessagesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetEssenceMessagesResponse} GetEssenceMessagesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessagesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEssenceMessagesResponse message.
             * @function verify
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEssenceMessagesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.essenceMessage != null && message.hasOwnProperty("essenceMessage")) {
                    if (!Array.isArray(message.essenceMessage))
                        return "essenceMessage: array expected";
                    for (let i = 0; i < message.essenceMessage.length; ++i) {
                        let error = $root.kritor.message.EssenceMessage.verify(message.essenceMessage[i]);
                        if (error)
                            return "essenceMessage." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetEssenceMessagesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetEssenceMessagesResponse} GetEssenceMessagesResponse
             */
            GetEssenceMessagesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetEssenceMessagesResponse)
                    return object;
                let message = new $root.kritor.message.GetEssenceMessagesResponse();
                if (object.essenceMessage) {
                    if (!Array.isArray(object.essenceMessage))
                        throw TypeError(".kritor.message.GetEssenceMessagesResponse.essenceMessage: array expected");
                    message.essenceMessage = [];
                    for (let i = 0; i < object.essenceMessage.length; ++i) {
                        if (typeof object.essenceMessage[i] !== "object")
                            throw TypeError(".kritor.message.GetEssenceMessagesResponse.essenceMessage: object expected");
                        message.essenceMessage[i] = $root.kritor.message.EssenceMessage.fromObject(object.essenceMessage[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetEssenceMessagesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {kritor.message.GetEssenceMessagesResponse} message GetEssenceMessagesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEssenceMessagesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.essenceMessage = [];
                if (message.essenceMessage && message.essenceMessage.length) {
                    object.essenceMessage = [];
                    for (let j = 0; j < message.essenceMessage.length; ++j)
                        object.essenceMessage[j] = $root.kritor.message.EssenceMessage.toObject(message.essenceMessage[j], options);
                }
                return object;
            };

            /**
             * Converts this GetEssenceMessagesResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEssenceMessagesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEssenceMessagesResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetEssenceMessagesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEssenceMessagesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetEssenceMessagesResponse";
            };

            return GetEssenceMessagesResponse;
        })();

        message.SetEssenceMessageRequest = (function() {

            /**
             * Properties of a SetEssenceMessageRequest.
             * @memberof kritor.message
             * @interface ISetEssenceMessageRequest
             * @property {number|Long|null} [groupId] SetEssenceMessageRequest groupId
             * @property {number|Long|null} [messageId] SetEssenceMessageRequest messageId
             */

            /**
             * Constructs a new SetEssenceMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a SetEssenceMessageRequest.
             * @implements ISetEssenceMessageRequest
             * @constructor
             * @param {kritor.message.ISetEssenceMessageRequest=} [properties] Properties to set
             */
            function SetEssenceMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetEssenceMessageRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             */
            SetEssenceMessageRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetEssenceMessageRequest messageId.
             * @member {number|Long} messageId
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             */
            SetEssenceMessageRequest.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new SetEssenceMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest instance
             */
            SetEssenceMessageRequest.create = function create(properties) {
                return new SetEssenceMessageRequest(properties);
            };

            /**
             * Encodes the specified SetEssenceMessageRequest message. Does not implicitly {@link kritor.message.SetEssenceMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest} message SetEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified SetEssenceMessageRequest message, length delimited. Does not implicitly {@link kritor.message.SetEssenceMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest} message SetEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEssenceMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetEssenceMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEssenceMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEssenceMessageRequest message.
             * @function verify
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEssenceMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                return null;
            };

            /**
             * Creates a SetEssenceMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             */
            SetEssenceMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetEssenceMessageRequest)
                    return object;
                let message = new $root.kritor.message.SetEssenceMessageRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a SetEssenceMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.SetEssenceMessageRequest} message SetEssenceMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEssenceMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                return object;
            };

            /**
             * Converts this SetEssenceMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEssenceMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEssenceMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEssenceMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetEssenceMessageRequest";
            };

            return SetEssenceMessageRequest;
        })();

        message.SetEssenceMessageResponse = (function() {

            /**
             * Properties of a SetEssenceMessageResponse.
             * @memberof kritor.message
             * @interface ISetEssenceMessageResponse
             */

            /**
             * Constructs a new SetEssenceMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a SetEssenceMessageResponse.
             * @implements ISetEssenceMessageResponse
             * @constructor
             * @param {kritor.message.ISetEssenceMessageResponse=} [properties] Properties to set
             */
            function SetEssenceMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetEssenceMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse instance
             */
            SetEssenceMessageResponse.create = function create(properties) {
                return new SetEssenceMessageResponse(properties);
            };

            /**
             * Encodes the specified SetEssenceMessageResponse message. Does not implicitly {@link kritor.message.SetEssenceMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse} message SetEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetEssenceMessageResponse message, length delimited. Does not implicitly {@link kritor.message.SetEssenceMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse} message SetEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEssenceMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetEssenceMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEssenceMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEssenceMessageResponse message.
             * @function verify
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEssenceMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetEssenceMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             */
            SetEssenceMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetEssenceMessageResponse)
                    return object;
                return new $root.kritor.message.SetEssenceMessageResponse();
            };

            /**
             * Creates a plain object from a SetEssenceMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.SetEssenceMessageResponse} message SetEssenceMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEssenceMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetEssenceMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SetEssenceMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEssenceMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEssenceMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEssenceMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetEssenceMessageResponse";
            };

            return SetEssenceMessageResponse;
        })();

        return message;
    })();

    kritor.guild = (function() {

        /**
         * Namespace guild.
         * @memberof kritor
         * @namespace
         */
        const guild = {};

        guild.GuildInfo = (function() {

            /**
             * Properties of a GuildInfo.
             * @memberof kritor.guild
             * @interface IGuildInfo
             * @property {number|Long|null} [guildId] GuildInfo guildId
             * @property {string|null} [guildName] GuildInfo guildName
             * @property {string|null} [guildDisplayId] GuildInfo guildDisplayId
             * @property {string|null} [profile] GuildInfo profile
             * @property {boolean|null} [isEnable] GuildInfo isEnable
             * @property {boolean|null} [isBanned] GuildInfo isBanned
             * @property {boolean|null} [isFrozen] GuildInfo isFrozen
             * @property {number|Long|null} [ownerId] GuildInfo ownerId
             * @property {number|Long|null} [shutupExpireTime] GuildInfo shutupExpireTime
             * @property {boolean|null} [allowSearch] GuildInfo allowSearch
             */

            /**
             * Constructs a new GuildInfo.
             * @memberof kritor.guild
             * @classdesc Represents a GuildInfo.
             * @implements IGuildInfo
             * @constructor
             * @param {kritor.guild.IGuildInfo=} [properties] Properties to set
             */
            function GuildInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GuildInfo guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo guildName.
             * @member {string} guildName
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guildName = "";

            /**
             * GuildInfo guildDisplayId.
             * @member {string} guildDisplayId
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guildDisplayId = "";

            /**
             * GuildInfo profile.
             * @member {string} profile
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.profile = "";

            /**
             * GuildInfo isEnable.
             * @member {boolean} isEnable
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.isEnable = false;

            /**
             * GuildInfo isBanned.
             * @member {boolean} isBanned
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.isBanned = false;

            /**
             * GuildInfo isFrozen.
             * @member {boolean} isFrozen
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.isFrozen = false;

            /**
             * GuildInfo ownerId.
             * @member {number|Long} ownerId
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.ownerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo shutupExpireTime.
             * @member {number|Long} shutupExpireTime
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.shutupExpireTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo allowSearch.
             * @member {boolean} allowSearch
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.allowSearch = false;

            /**
             * Creates a new GuildInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo=} [properties] Properties to set
             * @returns {kritor.guild.GuildInfo} GuildInfo instance
             */
            GuildInfo.create = function create(properties) {
                return new GuildInfo(properties);
            };

            /**
             * Encodes the specified GuildInfo message. Does not implicitly {@link kritor.guild.GuildInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo} message GuildInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GuildInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.guildName != null && Object.hasOwnProperty.call(message, "guildName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.guildName);
                if (message.guildDisplayId != null && Object.hasOwnProperty.call(message, "guildDisplayId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.guildDisplayId);
                if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.profile);
                if (message.isEnable != null && Object.hasOwnProperty.call(message, "isEnable"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isEnable);
                if (message.isBanned != null && Object.hasOwnProperty.call(message, "isBanned"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isBanned);
                if (message.isFrozen != null && Object.hasOwnProperty.call(message, "isFrozen"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isFrozen);
                if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.ownerId);
                if (message.shutupExpireTime != null && Object.hasOwnProperty.call(message, "shutupExpireTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.shutupExpireTime);
                if (message.allowSearch != null && Object.hasOwnProperty.call(message, "allowSearch"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.allowSearch);
                return writer;
            };

            /**
             * Encodes the specified GuildInfo message, length delimited. Does not implicitly {@link kritor.guild.GuildInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo} message GuildInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GuildInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GuildInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GuildInfo} GuildInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GuildInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GuildInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guildName = reader.string();
                            break;
                        }
                    case 3: {
                            message.guildDisplayId = reader.string();
                            break;
                        }
                    case 4: {
                            message.profile = reader.string();
                            break;
                        }
                    case 5: {
                            message.isEnable = reader.bool();
                            break;
                        }
                    case 6: {
                            message.isBanned = reader.bool();
                            break;
                        }
                    case 7: {
                            message.isFrozen = reader.bool();
                            break;
                        }
                    case 8: {
                            message.ownerId = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.shutupExpireTime = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.allowSearch = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GuildInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GuildInfo} GuildInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GuildInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GuildInfo message.
             * @function verify
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GuildInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    if (!$util.isString(message.guildName))
                        return "guildName: string expected";
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    if (!$util.isString(message.guildDisplayId))
                        return "guildDisplayId: string expected";
                if (message.profile != null && message.hasOwnProperty("profile"))
                    if (!$util.isString(message.profile))
                        return "profile: string expected";
                if (message.isEnable != null && message.hasOwnProperty("isEnable"))
                    if (typeof message.isEnable !== "boolean")
                        return "isEnable: boolean expected";
                if (message.isBanned != null && message.hasOwnProperty("isBanned"))
                    if (typeof message.isBanned !== "boolean")
                        return "isBanned: boolean expected";
                if (message.isFrozen != null && message.hasOwnProperty("isFrozen"))
                    if (typeof message.isFrozen !== "boolean")
                        return "isFrozen: boolean expected";
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (!$util.isInteger(message.ownerId) && !(message.ownerId && $util.isInteger(message.ownerId.low) && $util.isInteger(message.ownerId.high)))
                        return "ownerId: integer|Long expected";
                if (message.shutupExpireTime != null && message.hasOwnProperty("shutupExpireTime"))
                    if (!$util.isInteger(message.shutupExpireTime) && !(message.shutupExpireTime && $util.isInteger(message.shutupExpireTime.low) && $util.isInteger(message.shutupExpireTime.high)))
                        return "shutupExpireTime: integer|Long expected";
                if (message.allowSearch != null && message.hasOwnProperty("allowSearch"))
                    if (typeof message.allowSearch !== "boolean")
                        return "allowSearch: boolean expected";
                return null;
            };

            /**
             * Creates a GuildInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GuildInfo} GuildInfo
             */
            GuildInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GuildInfo)
                    return object;
                let message = new $root.kritor.guild.GuildInfo();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.guildName != null)
                    message.guildName = String(object.guildName);
                if (object.guildDisplayId != null)
                    message.guildDisplayId = String(object.guildDisplayId);
                if (object.profile != null)
                    message.profile = String(object.profile);
                if (object.isEnable != null)
                    message.isEnable = Boolean(object.isEnable);
                if (object.isBanned != null)
                    message.isBanned = Boolean(object.isBanned);
                if (object.isFrozen != null)
                    message.isFrozen = Boolean(object.isFrozen);
                if (object.ownerId != null)
                    if ($util.Long)
                        (message.ownerId = $util.Long.fromValue(object.ownerId)).unsigned = true;
                    else if (typeof object.ownerId === "string")
                        message.ownerId = parseInt(object.ownerId, 10);
                    else if (typeof object.ownerId === "number")
                        message.ownerId = object.ownerId;
                    else if (typeof object.ownerId === "object")
                        message.ownerId = new $util.LongBits(object.ownerId.low >>> 0, object.ownerId.high >>> 0).toNumber(true);
                if (object.shutupExpireTime != null)
                    if ($util.Long)
                        (message.shutupExpireTime = $util.Long.fromValue(object.shutupExpireTime)).unsigned = true;
                    else if (typeof object.shutupExpireTime === "string")
                        message.shutupExpireTime = parseInt(object.shutupExpireTime, 10);
                    else if (typeof object.shutupExpireTime === "number")
                        message.shutupExpireTime = object.shutupExpireTime;
                    else if (typeof object.shutupExpireTime === "object")
                        message.shutupExpireTime = new $util.LongBits(object.shutupExpireTime.low >>> 0, object.shutupExpireTime.high >>> 0).toNumber(true);
                if (object.allowSearch != null)
                    message.allowSearch = Boolean(object.allowSearch);
                return message;
            };

            /**
             * Creates a plain object from a GuildInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.GuildInfo} message GuildInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GuildInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.guildName = "";
                    object.guildDisplayId = "";
                    object.profile = "";
                    object.isEnable = false;
                    object.isBanned = false;
                    object.isFrozen = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.ownerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ownerId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.shutupExpireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.shutupExpireTime = options.longs === String ? "0" : 0;
                    object.allowSearch = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    object.guildName = message.guildName;
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    object.guildDisplayId = message.guildDisplayId;
                if (message.profile != null && message.hasOwnProperty("profile"))
                    object.profile = message.profile;
                if (message.isEnable != null && message.hasOwnProperty("isEnable"))
                    object.isEnable = message.isEnable;
                if (message.isBanned != null && message.hasOwnProperty("isBanned"))
                    object.isBanned = message.isBanned;
                if (message.isFrozen != null && message.hasOwnProperty("isFrozen"))
                    object.isFrozen = message.isFrozen;
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (typeof message.ownerId === "number")
                        object.ownerId = options.longs === String ? String(message.ownerId) : message.ownerId;
                    else
                        object.ownerId = options.longs === String ? $util.Long.prototype.toString.call(message.ownerId) : options.longs === Number ? new $util.LongBits(message.ownerId.low >>> 0, message.ownerId.high >>> 0).toNumber(true) : message.ownerId;
                if (message.shutupExpireTime != null && message.hasOwnProperty("shutupExpireTime"))
                    if (typeof message.shutupExpireTime === "number")
                        object.shutupExpireTime = options.longs === String ? String(message.shutupExpireTime) : message.shutupExpireTime;
                    else
                        object.shutupExpireTime = options.longs === String ? $util.Long.prototype.toString.call(message.shutupExpireTime) : options.longs === Number ? new $util.LongBits(message.shutupExpireTime.low >>> 0, message.shutupExpireTime.high >>> 0).toNumber(true) : message.shutupExpireTime;
                if (message.allowSearch != null && message.hasOwnProperty("allowSearch"))
                    object.allowSearch = message.allowSearch;
                return object;
            };

            /**
             * Converts this GuildInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.GuildInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GuildInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GuildInfo
             * @function getTypeUrl
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GuildInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GuildInfo";
            };

            return GuildInfo;
        })();

        guild.ChannelInfo = (function() {

            /**
             * Properties of a ChannelInfo.
             * @memberof kritor.guild
             * @interface IChannelInfo
             * @property {number|Long|null} [channelId] ChannelInfo channelId
             * @property {number|Long|null} [guildId] ChannelInfo guildId
             * @property {string|null} [channelName] ChannelInfo channelName
             * @property {number|Long|null} [createTime] ChannelInfo createTime
             * @property {number|Long|null} [maxMemberCount] ChannelInfo maxMemberCount
             * @property {number|Long|null} [creatorTinyId] ChannelInfo creatorTinyId
             * @property {number|Long|null} [talkPermission] ChannelInfo talkPermission
             * @property {number|Long|null} [visibleType] ChannelInfo visibleType
             * @property {number|Long|null} [currentSlowMode] ChannelInfo currentSlowMode
             * @property {Array.<kritor.guild.ISlowModes>|null} [slowModes] ChannelInfo slowModes
             * @property {string|null} [iconUrl] ChannelInfo iconUrl
             * @property {number|Long|null} [jumpSwitch] ChannelInfo jumpSwitch
             * @property {number|Long|null} [jumpType] ChannelInfo jumpType
             * @property {string|null} [jumpUrl] ChannelInfo jumpUrl
             * @property {number|Long|null} [categoryId] ChannelInfo categoryId
             * @property {number|Long|null} [myTalkPermission] ChannelInfo myTalkPermission
             */

            /**
             * Constructs a new ChannelInfo.
             * @memberof kritor.guild
             * @classdesc Represents a ChannelInfo.
             * @implements IChannelInfo
             * @constructor
             * @param {kritor.guild.IChannelInfo=} [properties] Properties to set
             */
            function ChannelInfo(properties) {
                this.slowModes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChannelInfo channelId.
             * @member {number|Long} channelId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo channelName.
             * @member {string} channelName
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channelName = "";

            /**
             * ChannelInfo createTime.
             * @member {number|Long} createTime
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo maxMemberCount.
             * @member {number|Long} maxMemberCount
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.maxMemberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo creatorTinyId.
             * @member {number|Long} creatorTinyId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.creatorTinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo talkPermission.
             * @member {number|Long} talkPermission
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.talkPermission = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo visibleType.
             * @member {number|Long} visibleType
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.visibleType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo currentSlowMode.
             * @member {number|Long} currentSlowMode
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.currentSlowMode = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo slowModes.
             * @member {Array.<kritor.guild.ISlowModes>} slowModes
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.slowModes = $util.emptyArray;

            /**
             * ChannelInfo iconUrl.
             * @member {string} iconUrl
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.iconUrl = "";

            /**
             * ChannelInfo jumpSwitch.
             * @member {number|Long} jumpSwitch
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jumpSwitch = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo jumpType.
             * @member {number|Long} jumpType
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jumpType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo jumpUrl.
             * @member {string} jumpUrl
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jumpUrl = "";

            /**
             * ChannelInfo categoryId.
             * @member {number|Long} categoryId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.categoryId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo myTalkPermission.
             * @member {number|Long} myTalkPermission
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.myTalkPermission = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ChannelInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo=} [properties] Properties to set
             * @returns {kritor.guild.ChannelInfo} ChannelInfo instance
             */
            ChannelInfo.create = function create(properties) {
                return new ChannelInfo(properties);
            };

            /**
             * Encodes the specified ChannelInfo message. Does not implicitly {@link kritor.guild.ChannelInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.guildId);
                if (message.channelName != null && Object.hasOwnProperty.call(message, "channelName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelName);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.createTime);
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxMemberCount);
                if (message.creatorTinyId != null && Object.hasOwnProperty.call(message, "creatorTinyId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.creatorTinyId);
                if (message.talkPermission != null && Object.hasOwnProperty.call(message, "talkPermission"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.talkPermission);
                if (message.visibleType != null && Object.hasOwnProperty.call(message, "visibleType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.visibleType);
                if (message.currentSlowMode != null && Object.hasOwnProperty.call(message, "currentSlowMode"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.currentSlowMode);
                if (message.slowModes != null && message.slowModes.length)
                    for (let i = 0; i < message.slowModes.length; ++i)
                        $root.kritor.guild.SlowModes.encode(message.slowModes[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.iconUrl);
                if (message.jumpSwitch != null && Object.hasOwnProperty.call(message, "jumpSwitch"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.jumpSwitch);
                if (message.jumpType != null && Object.hasOwnProperty.call(message, "jumpType"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.jumpType);
                if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.jumpUrl);
                if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.categoryId);
                if (message.myTalkPermission != null && Object.hasOwnProperty.call(message, "myTalkPermission"))
                    writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.myTalkPermission);
                return writer;
            };

            /**
             * Encodes the specified ChannelInfo message, length delimited. Does not implicitly {@link kritor.guild.ChannelInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChannelInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.ChannelInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.channelId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.channelName = reader.string();
                            break;
                        }
                    case 4: {
                            message.createTime = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.maxMemberCount = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.creatorTinyId = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.talkPermission = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.visibleType = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.currentSlowMode = reader.uint64();
                            break;
                        }
                    case 10: {
                            if (!(message.slowModes && message.slowModes.length))
                                message.slowModes = [];
                            message.slowModes.push($root.kritor.guild.SlowModes.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.iconUrl = reader.string();
                            break;
                        }
                    case 12: {
                            message.jumpSwitch = reader.uint64();
                            break;
                        }
                    case 13: {
                            message.jumpType = reader.uint64();
                            break;
                        }
                    case 14: {
                            message.jumpUrl = reader.string();
                            break;
                        }
                    case 15: {
                            message.categoryId = reader.uint64();
                            break;
                        }
                    case 16: {
                            message.myTalkPermission = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChannelInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChannelInfo message.
             * @function verify
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                        return "channelId: integer|Long expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.channelName != null && message.hasOwnProperty("channelName"))
                    if (!$util.isString(message.channelName))
                        return "channelName: string expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                        return "createTime: integer|Long expected";
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount) && !(message.maxMemberCount && $util.isInteger(message.maxMemberCount.low) && $util.isInteger(message.maxMemberCount.high)))
                        return "maxMemberCount: integer|Long expected";
                if (message.creatorTinyId != null && message.hasOwnProperty("creatorTinyId"))
                    if (!$util.isInteger(message.creatorTinyId) && !(message.creatorTinyId && $util.isInteger(message.creatorTinyId.low) && $util.isInteger(message.creatorTinyId.high)))
                        return "creatorTinyId: integer|Long expected";
                if (message.talkPermission != null && message.hasOwnProperty("talkPermission"))
                    if (!$util.isInteger(message.talkPermission) && !(message.talkPermission && $util.isInteger(message.talkPermission.low) && $util.isInteger(message.talkPermission.high)))
                        return "talkPermission: integer|Long expected";
                if (message.visibleType != null && message.hasOwnProperty("visibleType"))
                    if (!$util.isInteger(message.visibleType) && !(message.visibleType && $util.isInteger(message.visibleType.low) && $util.isInteger(message.visibleType.high)))
                        return "visibleType: integer|Long expected";
                if (message.currentSlowMode != null && message.hasOwnProperty("currentSlowMode"))
                    if (!$util.isInteger(message.currentSlowMode) && !(message.currentSlowMode && $util.isInteger(message.currentSlowMode.low) && $util.isInteger(message.currentSlowMode.high)))
                        return "currentSlowMode: integer|Long expected";
                if (message.slowModes != null && message.hasOwnProperty("slowModes")) {
                    if (!Array.isArray(message.slowModes))
                        return "slowModes: array expected";
                    for (let i = 0; i < message.slowModes.length; ++i) {
                        let error = $root.kritor.guild.SlowModes.verify(message.slowModes[i]);
                        if (error)
                            return "slowModes." + error;
                    }
                }
                if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                    if (!$util.isString(message.iconUrl))
                        return "iconUrl: string expected";
                if (message.jumpSwitch != null && message.hasOwnProperty("jumpSwitch"))
                    if (!$util.isInteger(message.jumpSwitch) && !(message.jumpSwitch && $util.isInteger(message.jumpSwitch.low) && $util.isInteger(message.jumpSwitch.high)))
                        return "jumpSwitch: integer|Long expected";
                if (message.jumpType != null && message.hasOwnProperty("jumpType"))
                    if (!$util.isInteger(message.jumpType) && !(message.jumpType && $util.isInteger(message.jumpType.low) && $util.isInteger(message.jumpType.high)))
                        return "jumpType: integer|Long expected";
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    if (!$util.isString(message.jumpUrl))
                        return "jumpUrl: string expected";
                if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                    if (!$util.isInteger(message.categoryId) && !(message.categoryId && $util.isInteger(message.categoryId.low) && $util.isInteger(message.categoryId.high)))
                        return "categoryId: integer|Long expected";
                if (message.myTalkPermission != null && message.hasOwnProperty("myTalkPermission"))
                    if (!$util.isInteger(message.myTalkPermission) && !(message.myTalkPermission && $util.isInteger(message.myTalkPermission.low) && $util.isInteger(message.myTalkPermission.high)))
                        return "myTalkPermission: integer|Long expected";
                return null;
            };

            /**
             * Creates a ChannelInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             */
            ChannelInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.ChannelInfo)
                    return object;
                let message = new $root.kritor.guild.ChannelInfo();
                if (object.channelId != null)
                    if ($util.Long)
                        (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                    else if (typeof object.channelId === "string")
                        message.channelId = parseInt(object.channelId, 10);
                    else if (typeof object.channelId === "number")
                        message.channelId = object.channelId;
                    else if (typeof object.channelId === "object")
                        message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.channelName != null)
                    message.channelName = String(object.channelName);
                if (object.createTime != null)
                    if ($util.Long)
                        (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = true;
                    else if (typeof object.createTime === "string")
                        message.createTime = parseInt(object.createTime, 10);
                    else if (typeof object.createTime === "number")
                        message.createTime = object.createTime;
                    else if (typeof object.createTime === "object")
                        message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber(true);
                if (object.maxMemberCount != null)
                    if ($util.Long)
                        (message.maxMemberCount = $util.Long.fromValue(object.maxMemberCount)).unsigned = true;
                    else if (typeof object.maxMemberCount === "string")
                        message.maxMemberCount = parseInt(object.maxMemberCount, 10);
                    else if (typeof object.maxMemberCount === "number")
                        message.maxMemberCount = object.maxMemberCount;
                    else if (typeof object.maxMemberCount === "object")
                        message.maxMemberCount = new $util.LongBits(object.maxMemberCount.low >>> 0, object.maxMemberCount.high >>> 0).toNumber(true);
                if (object.creatorTinyId != null)
                    if ($util.Long)
                        (message.creatorTinyId = $util.Long.fromValue(object.creatorTinyId)).unsigned = true;
                    else if (typeof object.creatorTinyId === "string")
                        message.creatorTinyId = parseInt(object.creatorTinyId, 10);
                    else if (typeof object.creatorTinyId === "number")
                        message.creatorTinyId = object.creatorTinyId;
                    else if (typeof object.creatorTinyId === "object")
                        message.creatorTinyId = new $util.LongBits(object.creatorTinyId.low >>> 0, object.creatorTinyId.high >>> 0).toNumber(true);
                if (object.talkPermission != null)
                    if ($util.Long)
                        (message.talkPermission = $util.Long.fromValue(object.talkPermission)).unsigned = true;
                    else if (typeof object.talkPermission === "string")
                        message.talkPermission = parseInt(object.talkPermission, 10);
                    else if (typeof object.talkPermission === "number")
                        message.talkPermission = object.talkPermission;
                    else if (typeof object.talkPermission === "object")
                        message.talkPermission = new $util.LongBits(object.talkPermission.low >>> 0, object.talkPermission.high >>> 0).toNumber(true);
                if (object.visibleType != null)
                    if ($util.Long)
                        (message.visibleType = $util.Long.fromValue(object.visibleType)).unsigned = true;
                    else if (typeof object.visibleType === "string")
                        message.visibleType = parseInt(object.visibleType, 10);
                    else if (typeof object.visibleType === "number")
                        message.visibleType = object.visibleType;
                    else if (typeof object.visibleType === "object")
                        message.visibleType = new $util.LongBits(object.visibleType.low >>> 0, object.visibleType.high >>> 0).toNumber(true);
                if (object.currentSlowMode != null)
                    if ($util.Long)
                        (message.currentSlowMode = $util.Long.fromValue(object.currentSlowMode)).unsigned = true;
                    else if (typeof object.currentSlowMode === "string")
                        message.currentSlowMode = parseInt(object.currentSlowMode, 10);
                    else if (typeof object.currentSlowMode === "number")
                        message.currentSlowMode = object.currentSlowMode;
                    else if (typeof object.currentSlowMode === "object")
                        message.currentSlowMode = new $util.LongBits(object.currentSlowMode.low >>> 0, object.currentSlowMode.high >>> 0).toNumber(true);
                if (object.slowModes) {
                    if (!Array.isArray(object.slowModes))
                        throw TypeError(".kritor.guild.ChannelInfo.slowModes: array expected");
                    message.slowModes = [];
                    for (let i = 0; i < object.slowModes.length; ++i) {
                        if (typeof object.slowModes[i] !== "object")
                            throw TypeError(".kritor.guild.ChannelInfo.slowModes: object expected");
                        message.slowModes[i] = $root.kritor.guild.SlowModes.fromObject(object.slowModes[i]);
                    }
                }
                if (object.iconUrl != null)
                    message.iconUrl = String(object.iconUrl);
                if (object.jumpSwitch != null)
                    if ($util.Long)
                        (message.jumpSwitch = $util.Long.fromValue(object.jumpSwitch)).unsigned = true;
                    else if (typeof object.jumpSwitch === "string")
                        message.jumpSwitch = parseInt(object.jumpSwitch, 10);
                    else if (typeof object.jumpSwitch === "number")
                        message.jumpSwitch = object.jumpSwitch;
                    else if (typeof object.jumpSwitch === "object")
                        message.jumpSwitch = new $util.LongBits(object.jumpSwitch.low >>> 0, object.jumpSwitch.high >>> 0).toNumber(true);
                if (object.jumpType != null)
                    if ($util.Long)
                        (message.jumpType = $util.Long.fromValue(object.jumpType)).unsigned = true;
                    else if (typeof object.jumpType === "string")
                        message.jumpType = parseInt(object.jumpType, 10);
                    else if (typeof object.jumpType === "number")
                        message.jumpType = object.jumpType;
                    else if (typeof object.jumpType === "object")
                        message.jumpType = new $util.LongBits(object.jumpType.low >>> 0, object.jumpType.high >>> 0).toNumber(true);
                if (object.jumpUrl != null)
                    message.jumpUrl = String(object.jumpUrl);
                if (object.categoryId != null)
                    if ($util.Long)
                        (message.categoryId = $util.Long.fromValue(object.categoryId)).unsigned = true;
                    else if (typeof object.categoryId === "string")
                        message.categoryId = parseInt(object.categoryId, 10);
                    else if (typeof object.categoryId === "number")
                        message.categoryId = object.categoryId;
                    else if (typeof object.categoryId === "object")
                        message.categoryId = new $util.LongBits(object.categoryId.low >>> 0, object.categoryId.high >>> 0).toNumber(true);
                if (object.myTalkPermission != null)
                    if ($util.Long)
                        (message.myTalkPermission = $util.Long.fromValue(object.myTalkPermission)).unsigned = true;
                    else if (typeof object.myTalkPermission === "string")
                        message.myTalkPermission = parseInt(object.myTalkPermission, 10);
                    else if (typeof object.myTalkPermission === "number")
                        message.myTalkPermission = object.myTalkPermission;
                    else if (typeof object.myTalkPermission === "object")
                        message.myTalkPermission = new $util.LongBits(object.myTalkPermission.low >>> 0, object.myTalkPermission.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ChannelInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.ChannelInfo} message ChannelInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.slowModes = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.channelId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.channelName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.createTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxMemberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxMemberCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.creatorTinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creatorTinyId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.talkPermission = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.talkPermission = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.visibleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.visibleType = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.currentSlowMode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.currentSlowMode = options.longs === String ? "0" : 0;
                    object.iconUrl = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.jumpSwitch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jumpSwitch = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.jumpType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jumpType = options.longs === String ? "0" : 0;
                    object.jumpUrl = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.categoryId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.categoryId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.myTalkPermission = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.myTalkPermission = options.longs === String ? "0" : 0;
                }
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (typeof message.channelId === "number")
                        object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                    else
                        object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.channelName != null && message.hasOwnProperty("channelName"))
                    object.channelName = message.channelName;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (typeof message.createTime === "number")
                        object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                    else
                        object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber(true) : message.createTime;
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (typeof message.maxMemberCount === "number")
                        object.maxMemberCount = options.longs === String ? String(message.maxMemberCount) : message.maxMemberCount;
                    else
                        object.maxMemberCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxMemberCount) : options.longs === Number ? new $util.LongBits(message.maxMemberCount.low >>> 0, message.maxMemberCount.high >>> 0).toNumber(true) : message.maxMemberCount;
                if (message.creatorTinyId != null && message.hasOwnProperty("creatorTinyId"))
                    if (typeof message.creatorTinyId === "number")
                        object.creatorTinyId = options.longs === String ? String(message.creatorTinyId) : message.creatorTinyId;
                    else
                        object.creatorTinyId = options.longs === String ? $util.Long.prototype.toString.call(message.creatorTinyId) : options.longs === Number ? new $util.LongBits(message.creatorTinyId.low >>> 0, message.creatorTinyId.high >>> 0).toNumber(true) : message.creatorTinyId;
                if (message.talkPermission != null && message.hasOwnProperty("talkPermission"))
                    if (typeof message.talkPermission === "number")
                        object.talkPermission = options.longs === String ? String(message.talkPermission) : message.talkPermission;
                    else
                        object.talkPermission = options.longs === String ? $util.Long.prototype.toString.call(message.talkPermission) : options.longs === Number ? new $util.LongBits(message.talkPermission.low >>> 0, message.talkPermission.high >>> 0).toNumber(true) : message.talkPermission;
                if (message.visibleType != null && message.hasOwnProperty("visibleType"))
                    if (typeof message.visibleType === "number")
                        object.visibleType = options.longs === String ? String(message.visibleType) : message.visibleType;
                    else
                        object.visibleType = options.longs === String ? $util.Long.prototype.toString.call(message.visibleType) : options.longs === Number ? new $util.LongBits(message.visibleType.low >>> 0, message.visibleType.high >>> 0).toNumber(true) : message.visibleType;
                if (message.currentSlowMode != null && message.hasOwnProperty("currentSlowMode"))
                    if (typeof message.currentSlowMode === "number")
                        object.currentSlowMode = options.longs === String ? String(message.currentSlowMode) : message.currentSlowMode;
                    else
                        object.currentSlowMode = options.longs === String ? $util.Long.prototype.toString.call(message.currentSlowMode) : options.longs === Number ? new $util.LongBits(message.currentSlowMode.low >>> 0, message.currentSlowMode.high >>> 0).toNumber(true) : message.currentSlowMode;
                if (message.slowModes && message.slowModes.length) {
                    object.slowModes = [];
                    for (let j = 0; j < message.slowModes.length; ++j)
                        object.slowModes[j] = $root.kritor.guild.SlowModes.toObject(message.slowModes[j], options);
                }
                if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                    object.iconUrl = message.iconUrl;
                if (message.jumpSwitch != null && message.hasOwnProperty("jumpSwitch"))
                    if (typeof message.jumpSwitch === "number")
                        object.jumpSwitch = options.longs === String ? String(message.jumpSwitch) : message.jumpSwitch;
                    else
                        object.jumpSwitch = options.longs === String ? $util.Long.prototype.toString.call(message.jumpSwitch) : options.longs === Number ? new $util.LongBits(message.jumpSwitch.low >>> 0, message.jumpSwitch.high >>> 0).toNumber(true) : message.jumpSwitch;
                if (message.jumpType != null && message.hasOwnProperty("jumpType"))
                    if (typeof message.jumpType === "number")
                        object.jumpType = options.longs === String ? String(message.jumpType) : message.jumpType;
                    else
                        object.jumpType = options.longs === String ? $util.Long.prototype.toString.call(message.jumpType) : options.longs === Number ? new $util.LongBits(message.jumpType.low >>> 0, message.jumpType.high >>> 0).toNumber(true) : message.jumpType;
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    object.jumpUrl = message.jumpUrl;
                if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                    if (typeof message.categoryId === "number")
                        object.categoryId = options.longs === String ? String(message.categoryId) : message.categoryId;
                    else
                        object.categoryId = options.longs === String ? $util.Long.prototype.toString.call(message.categoryId) : options.longs === Number ? new $util.LongBits(message.categoryId.low >>> 0, message.categoryId.high >>> 0).toNumber(true) : message.categoryId;
                if (message.myTalkPermission != null && message.hasOwnProperty("myTalkPermission"))
                    if (typeof message.myTalkPermission === "number")
                        object.myTalkPermission = options.longs === String ? String(message.myTalkPermission) : message.myTalkPermission;
                    else
                        object.myTalkPermission = options.longs === String ? $util.Long.prototype.toString.call(message.myTalkPermission) : options.longs === Number ? new $util.LongBits(message.myTalkPermission.low >>> 0, message.myTalkPermission.high >>> 0).toNumber(true) : message.myTalkPermission;
                return object;
            };

            /**
             * Converts this ChannelInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.ChannelInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChannelInfo
             * @function getTypeUrl
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChannelInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.ChannelInfo";
            };

            return ChannelInfo;
        })();

        guild.SlowModes = (function() {

            /**
             * Properties of a SlowModes.
             * @memberof kritor.guild
             * @interface ISlowModes
             * @property {number|Long|null} [slowModeKey] SlowModes slowModeKey
             * @property {string|null} [slowModeText] SlowModes slowModeText
             * @property {number|Long|null} [speakFrequency] SlowModes speakFrequency
             * @property {number|Long|null} [slowModeCircle] SlowModes slowModeCircle
             */

            /**
             * Constructs a new SlowModes.
             * @memberof kritor.guild
             * @classdesc Represents a SlowModes.
             * @implements ISlowModes
             * @constructor
             * @param {kritor.guild.ISlowModes=} [properties] Properties to set
             */
            function SlowModes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SlowModes slowModeKey.
             * @member {number|Long} slowModeKey
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slowModeKey = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SlowModes slowModeText.
             * @member {string} slowModeText
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slowModeText = "";

            /**
             * SlowModes speakFrequency.
             * @member {number|Long} speakFrequency
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.speakFrequency = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SlowModes slowModeCircle.
             * @member {number|Long} slowModeCircle
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slowModeCircle = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new SlowModes instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes=} [properties] Properties to set
             * @returns {kritor.guild.SlowModes} SlowModes instance
             */
            SlowModes.create = function create(properties) {
                return new SlowModes(properties);
            };

            /**
             * Encodes the specified SlowModes message. Does not implicitly {@link kritor.guild.SlowModes.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes} message SlowModes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlowModes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.slowModeKey != null && Object.hasOwnProperty.call(message, "slowModeKey"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slowModeKey);
                if (message.slowModeText != null && Object.hasOwnProperty.call(message, "slowModeText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.slowModeText);
                if (message.speakFrequency != null && Object.hasOwnProperty.call(message, "speakFrequency"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.speakFrequency);
                if (message.slowModeCircle != null && Object.hasOwnProperty.call(message, "slowModeCircle"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.slowModeCircle);
                return writer;
            };

            /**
             * Encodes the specified SlowModes message, length delimited. Does not implicitly {@link kritor.guild.SlowModes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes} message SlowModes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlowModes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SlowModes message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SlowModes} SlowModes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlowModes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SlowModes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.slowModeKey = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.slowModeText = reader.string();
                            break;
                        }
                    case 3: {
                            message.speakFrequency = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.slowModeCircle = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SlowModes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SlowModes} SlowModes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlowModes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SlowModes message.
             * @function verify
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SlowModes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.slowModeKey != null && message.hasOwnProperty("slowModeKey"))
                    if (!$util.isInteger(message.slowModeKey) && !(message.slowModeKey && $util.isInteger(message.slowModeKey.low) && $util.isInteger(message.slowModeKey.high)))
                        return "slowModeKey: integer|Long expected";
                if (message.slowModeText != null && message.hasOwnProperty("slowModeText"))
                    if (!$util.isString(message.slowModeText))
                        return "slowModeText: string expected";
                if (message.speakFrequency != null && message.hasOwnProperty("speakFrequency"))
                    if (!$util.isInteger(message.speakFrequency) && !(message.speakFrequency && $util.isInteger(message.speakFrequency.low) && $util.isInteger(message.speakFrequency.high)))
                        return "speakFrequency: integer|Long expected";
                if (message.slowModeCircle != null && message.hasOwnProperty("slowModeCircle"))
                    if (!$util.isInteger(message.slowModeCircle) && !(message.slowModeCircle && $util.isInteger(message.slowModeCircle.low) && $util.isInteger(message.slowModeCircle.high)))
                        return "slowModeCircle: integer|Long expected";
                return null;
            };

            /**
             * Creates a SlowModes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SlowModes} SlowModes
             */
            SlowModes.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SlowModes)
                    return object;
                let message = new $root.kritor.guild.SlowModes();
                if (object.slowModeKey != null)
                    if ($util.Long)
                        (message.slowModeKey = $util.Long.fromValue(object.slowModeKey)).unsigned = true;
                    else if (typeof object.slowModeKey === "string")
                        message.slowModeKey = parseInt(object.slowModeKey, 10);
                    else if (typeof object.slowModeKey === "number")
                        message.slowModeKey = object.slowModeKey;
                    else if (typeof object.slowModeKey === "object")
                        message.slowModeKey = new $util.LongBits(object.slowModeKey.low >>> 0, object.slowModeKey.high >>> 0).toNumber(true);
                if (object.slowModeText != null)
                    message.slowModeText = String(object.slowModeText);
                if (object.speakFrequency != null)
                    if ($util.Long)
                        (message.speakFrequency = $util.Long.fromValue(object.speakFrequency)).unsigned = true;
                    else if (typeof object.speakFrequency === "string")
                        message.speakFrequency = parseInt(object.speakFrequency, 10);
                    else if (typeof object.speakFrequency === "number")
                        message.speakFrequency = object.speakFrequency;
                    else if (typeof object.speakFrequency === "object")
                        message.speakFrequency = new $util.LongBits(object.speakFrequency.low >>> 0, object.speakFrequency.high >>> 0).toNumber(true);
                if (object.slowModeCircle != null)
                    if ($util.Long)
                        (message.slowModeCircle = $util.Long.fromValue(object.slowModeCircle)).unsigned = true;
                    else if (typeof object.slowModeCircle === "string")
                        message.slowModeCircle = parseInt(object.slowModeCircle, 10);
                    else if (typeof object.slowModeCircle === "number")
                        message.slowModeCircle = object.slowModeCircle;
                    else if (typeof object.slowModeCircle === "object")
                        message.slowModeCircle = new $util.LongBits(object.slowModeCircle.low >>> 0, object.slowModeCircle.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a SlowModes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.SlowModes} message SlowModes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SlowModes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.slowModeKey = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.slowModeKey = options.longs === String ? "0" : 0;
                    object.slowModeText = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.speakFrequency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.speakFrequency = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.slowModeCircle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.slowModeCircle = options.longs === String ? "0" : 0;
                }
                if (message.slowModeKey != null && message.hasOwnProperty("slowModeKey"))
                    if (typeof message.slowModeKey === "number")
                        object.slowModeKey = options.longs === String ? String(message.slowModeKey) : message.slowModeKey;
                    else
                        object.slowModeKey = options.longs === String ? $util.Long.prototype.toString.call(message.slowModeKey) : options.longs === Number ? new $util.LongBits(message.slowModeKey.low >>> 0, message.slowModeKey.high >>> 0).toNumber(true) : message.slowModeKey;
                if (message.slowModeText != null && message.hasOwnProperty("slowModeText"))
                    object.slowModeText = message.slowModeText;
                if (message.speakFrequency != null && message.hasOwnProperty("speakFrequency"))
                    if (typeof message.speakFrequency === "number")
                        object.speakFrequency = options.longs === String ? String(message.speakFrequency) : message.speakFrequency;
                    else
                        object.speakFrequency = options.longs === String ? $util.Long.prototype.toString.call(message.speakFrequency) : options.longs === Number ? new $util.LongBits(message.speakFrequency.low >>> 0, message.speakFrequency.high >>> 0).toNumber(true) : message.speakFrequency;
                if (message.slowModeCircle != null && message.hasOwnProperty("slowModeCircle"))
                    if (typeof message.slowModeCircle === "number")
                        object.slowModeCircle = options.longs === String ? String(message.slowModeCircle) : message.slowModeCircle;
                    else
                        object.slowModeCircle = options.longs === String ? $util.Long.prototype.toString.call(message.slowModeCircle) : options.longs === Number ? new $util.LongBits(message.slowModeCircle.low >>> 0, message.slowModeCircle.high >>> 0).toNumber(true) : message.slowModeCircle;
                return object;
            };

            /**
             * Converts this SlowModes to JSON.
             * @function toJSON
             * @memberof kritor.guild.SlowModes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SlowModes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SlowModes
             * @function getTypeUrl
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SlowModes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SlowModes";
            };

            return SlowModes;
        })();

        guild.MemberInfo = (function() {

            /**
             * Properties of a MemberInfo.
             * @memberof kritor.guild
             * @interface IMemberInfo
             * @property {number|Long|null} [tinyId] MemberInfo tinyId
             * @property {string|null} [title] MemberInfo title
             * @property {string|null} [nickname] MemberInfo nickname
             * @property {number|Long|null} [roleId] MemberInfo roleId
             * @property {string|null} [roleName] MemberInfo roleName
             * @property {number|Long|null} [roleColor] MemberInfo roleColor
             * @property {number|Long|null} [joinTime] MemberInfo joinTime
             * @property {number|Long|null} [robotType] MemberInfo robotType
             * @property {number|Long|null} [type] MemberInfo type
             * @property {boolean|null} [inBlack] MemberInfo inBlack
             * @property {number|Long|null} [platform] MemberInfo platform
             */

            /**
             * Constructs a new MemberInfo.
             * @memberof kritor.guild
             * @classdesc Represents a MemberInfo.
             * @implements IMemberInfo
             * @constructor
             * @param {kritor.guild.IMemberInfo=} [properties] Properties to set
             */
            function MemberInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberInfo tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo title.
             * @member {string} title
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.title = "";

            /**
             * MemberInfo nickname.
             * @member {string} nickname
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.nickname = "";

            /**
             * MemberInfo roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo roleName.
             * @member {string} roleName
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.roleName = "";

            /**
             * MemberInfo roleColor.
             * @member {number|Long} roleColor
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.roleColor = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo joinTime.
             * @member {number|Long} joinTime
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo robotType.
             * @member {number|Long} robotType
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.robotType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo type.
             * @member {number|Long} type
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo inBlack.
             * @member {boolean} inBlack
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.inBlack = false;

            /**
             * MemberInfo platform.
             * @member {number|Long} platform
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.platform = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new MemberInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo=} [properties] Properties to set
             * @returns {kritor.guild.MemberInfo} MemberInfo instance
             */
            MemberInfo.create = function create(properties) {
                return new MemberInfo(properties);
            };

            /**
             * Encodes the specified MemberInfo message. Does not implicitly {@link kritor.guild.MemberInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo} message MemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tinyId);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nickname);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.roleId);
                if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.roleName);
                if (message.roleColor != null && Object.hasOwnProperty.call(message, "roleColor"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.roleColor);
                if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.joinTime);
                if (message.robotType != null && Object.hasOwnProperty.call(message, "robotType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.robotType);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.type);
                if (message.inBlack != null && Object.hasOwnProperty.call(message, "inBlack"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.inBlack);
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.platform);
                return writer;
            };

            /**
             * Encodes the specified MemberInfo message, length delimited. Does not implicitly {@link kritor.guild.MemberInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo} message MemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberInfo} MemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 4: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.roleName = reader.string();
                            break;
                        }
                    case 6: {
                            message.roleColor = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.joinTime = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.robotType = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.type = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.inBlack = reader.bool();
                            break;
                        }
                    case 11: {
                            message.platform = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberInfo} MemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberInfo message.
             * @function verify
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    if (!$util.isString(message.roleName))
                        return "roleName: string expected";
                if (message.roleColor != null && message.hasOwnProperty("roleColor"))
                    if (!$util.isInteger(message.roleColor) && !(message.roleColor && $util.isInteger(message.roleColor.low) && $util.isInteger(message.roleColor.high)))
                        return "roleColor: integer|Long expected";
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                        return "joinTime: integer|Long expected";
                if (message.robotType != null && message.hasOwnProperty("robotType"))
                    if (!$util.isInteger(message.robotType) && !(message.robotType && $util.isInteger(message.robotType.low) && $util.isInteger(message.robotType.high)))
                        return "robotType: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.inBlack != null && message.hasOwnProperty("inBlack"))
                    if (typeof message.inBlack !== "boolean")
                        return "inBlack: boolean expected";
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (!$util.isInteger(message.platform) && !(message.platform && $util.isInteger(message.platform.low) && $util.isInteger(message.platform.high)))
                        return "platform: integer|Long expected";
                return null;
            };

            /**
             * Creates a MemberInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberInfo} MemberInfo
             */
            MemberInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberInfo)
                    return object;
                let message = new $root.kritor.guild.MemberInfo();
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.roleName != null)
                    message.roleName = String(object.roleName);
                if (object.roleColor != null)
                    if ($util.Long)
                        (message.roleColor = $util.Long.fromValue(object.roleColor)).unsigned = true;
                    else if (typeof object.roleColor === "string")
                        message.roleColor = parseInt(object.roleColor, 10);
                    else if (typeof object.roleColor === "number")
                        message.roleColor = object.roleColor;
                    else if (typeof object.roleColor === "object")
                        message.roleColor = new $util.LongBits(object.roleColor.low >>> 0, object.roleColor.high >>> 0).toNumber(true);
                if (object.joinTime != null)
                    if ($util.Long)
                        (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = true;
                    else if (typeof object.joinTime === "string")
                        message.joinTime = parseInt(object.joinTime, 10);
                    else if (typeof object.joinTime === "number")
                        message.joinTime = object.joinTime;
                    else if (typeof object.joinTime === "object")
                        message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber(true);
                if (object.robotType != null)
                    if ($util.Long)
                        (message.robotType = $util.Long.fromValue(object.robotType)).unsigned = true;
                    else if (typeof object.robotType === "string")
                        message.robotType = parseInt(object.robotType, 10);
                    else if (typeof object.robotType === "number")
                        message.robotType = object.robotType;
                    else if (typeof object.robotType === "object")
                        message.robotType = new $util.LongBits(object.robotType.low >>> 0, object.robotType.high >>> 0).toNumber(true);
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = true;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber(true);
                if (object.inBlack != null)
                    message.inBlack = Boolean(object.inBlack);
                if (object.platform != null)
                    if ($util.Long)
                        (message.platform = $util.Long.fromValue(object.platform)).unsigned = true;
                    else if (typeof object.platform === "string")
                        message.platform = parseInt(object.platform, 10);
                    else if (typeof object.platform === "number")
                        message.platform = object.platform;
                    else if (typeof object.platform === "object")
                        message.platform = new $util.LongBits(object.platform.low >>> 0, object.platform.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a MemberInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.MemberInfo} message MemberInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                    object.title = "";
                    object.nickname = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.roleName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleColor = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleColor = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.joinTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.robotType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.robotType = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    object.inBlack = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.platform = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.platform = options.longs === String ? "0" : 0;
                }
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    object.roleName = message.roleName;
                if (message.roleColor != null && message.hasOwnProperty("roleColor"))
                    if (typeof message.roleColor === "number")
                        object.roleColor = options.longs === String ? String(message.roleColor) : message.roleColor;
                    else
                        object.roleColor = options.longs === String ? $util.Long.prototype.toString.call(message.roleColor) : options.longs === Number ? new $util.LongBits(message.roleColor.low >>> 0, message.roleColor.high >>> 0).toNumber(true) : message.roleColor;
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (typeof message.joinTime === "number")
                        object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                    else
                        object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber(true) : message.joinTime;
                if (message.robotType != null && message.hasOwnProperty("robotType"))
                    if (typeof message.robotType === "number")
                        object.robotType = options.longs === String ? String(message.robotType) : message.robotType;
                    else
                        object.robotType = options.longs === String ? $util.Long.prototype.toString.call(message.robotType) : options.longs === Number ? new $util.LongBits(message.robotType.low >>> 0, message.robotType.high >>> 0).toNumber(true) : message.robotType;
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber(true) : message.type;
                if (message.inBlack != null && message.hasOwnProperty("inBlack"))
                    object.inBlack = message.inBlack;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (typeof message.platform === "number")
                        object.platform = options.longs === String ? String(message.platform) : message.platform;
                    else
                        object.platform = options.longs === String ? $util.Long.prototype.toString.call(message.platform) : options.longs === Number ? new $util.LongBits(message.platform.low >>> 0, message.platform.high >>> 0).toNumber(true) : message.platform;
                return object;
            };

            /**
             * Converts this MemberInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberInfo
             * @function getTypeUrl
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberInfo";
            };

            return MemberInfo;
        })();

        guild.MemberProfile = (function() {

            /**
             * Properties of a MemberProfile.
             * @memberof kritor.guild
             * @interface IMemberProfile
             * @property {number|Long|null} [tinyId] MemberProfile tinyId
             * @property {string|null} [nickname] MemberProfile nickname
             * @property {string|null} [avatarUrl] MemberProfile avatarUrl
             * @property {number|Long|null} [joinTime] MemberProfile joinTime
             * @property {Array.<kritor.guild.IRoleInfo>|null} [roles] MemberProfile roles
             */

            /**
             * Constructs a new MemberProfile.
             * @memberof kritor.guild
             * @classdesc Represents a MemberProfile.
             * @implements IMemberProfile
             * @constructor
             * @param {kritor.guild.IMemberProfile=} [properties] Properties to set
             */
            function MemberProfile(properties) {
                this.roles = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberProfile tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberProfile nickname.
             * @member {string} nickname
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.nickname = "";

            /**
             * MemberProfile avatarUrl.
             * @member {string} avatarUrl
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.avatarUrl = "";

            /**
             * MemberProfile joinTime.
             * @member {number|Long} joinTime
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberProfile roles.
             * @member {Array.<kritor.guild.IRoleInfo>} roles
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.roles = $util.emptyArray;

            /**
             * Creates a new MemberProfile instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile=} [properties] Properties to set
             * @returns {kritor.guild.MemberProfile} MemberProfile instance
             */
            MemberProfile.create = function create(properties) {
                return new MemberProfile(properties);
            };

            /**
             * Encodes the specified MemberProfile message. Does not implicitly {@link kritor.guild.MemberProfile.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile} message MemberProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberProfile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tinyId);
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
                if (message.avatarUrl != null && Object.hasOwnProperty.call(message, "avatarUrl"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarUrl);
                if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.joinTime);
                if (message.roles != null && message.roles.length)
                    for (let i = 0; i < message.roles.length; ++i)
                        $root.kritor.guild.RoleInfo.encode(message.roles[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MemberProfile message, length delimited. Does not implicitly {@link kritor.guild.MemberProfile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile} message MemberProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberProfile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberProfile message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberProfile} MemberProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberProfile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberProfile();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 3: {
                            message.avatarUrl = reader.string();
                            break;
                        }
                    case 4: {
                            message.joinTime = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.roles && message.roles.length))
                                message.roles = [];
                            message.roles.push($root.kritor.guild.RoleInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberProfile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberProfile} MemberProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberProfile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberProfile message.
             * @function verify
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberProfile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                    if (!$util.isString(message.avatarUrl))
                        return "avatarUrl: string expected";
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                        return "joinTime: integer|Long expected";
                if (message.roles != null && message.hasOwnProperty("roles")) {
                    if (!Array.isArray(message.roles))
                        return "roles: array expected";
                    for (let i = 0; i < message.roles.length; ++i) {
                        let error = $root.kritor.guild.RoleInfo.verify(message.roles[i]);
                        if (error)
                            return "roles." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MemberProfile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberProfile} MemberProfile
             */
            MemberProfile.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberProfile)
                    return object;
                let message = new $root.kritor.guild.MemberProfile();
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.avatarUrl != null)
                    message.avatarUrl = String(object.avatarUrl);
                if (object.joinTime != null)
                    if ($util.Long)
                        (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = true;
                    else if (typeof object.joinTime === "string")
                        message.joinTime = parseInt(object.joinTime, 10);
                    else if (typeof object.joinTime === "number")
                        message.joinTime = object.joinTime;
                    else if (typeof object.joinTime === "object")
                        message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber(true);
                if (object.roles) {
                    if (!Array.isArray(object.roles))
                        throw TypeError(".kritor.guild.MemberProfile.roles: array expected");
                    message.roles = [];
                    for (let i = 0; i < object.roles.length; ++i) {
                        if (typeof object.roles[i] !== "object")
                            throw TypeError(".kritor.guild.MemberProfile.roles: object expected");
                        message.roles[i] = $root.kritor.guild.RoleInfo.fromObject(object.roles[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MemberProfile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.MemberProfile} message MemberProfile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberProfile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.roles = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                    object.nickname = "";
                    object.avatarUrl = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.joinTime = options.longs === String ? "0" : 0;
                }
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                    object.avatarUrl = message.avatarUrl;
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (typeof message.joinTime === "number")
                        object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                    else
                        object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber(true) : message.joinTime;
                if (message.roles && message.roles.length) {
                    object.roles = [];
                    for (let j = 0; j < message.roles.length; ++j)
                        object.roles[j] = $root.kritor.guild.RoleInfo.toObject(message.roles[j], options);
                }
                return object;
            };

            /**
             * Converts this MemberProfile to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberProfile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberProfile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberProfile
             * @function getTypeUrl
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberProfile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberProfile";
            };

            return MemberProfile;
        })();

        guild.RoleInfo = (function() {

            /**
             * Properties of a RoleInfo.
             * @memberof kritor.guild
             * @interface IRoleInfo
             * @property {number|Long|null} [roleId] RoleInfo roleId
             * @property {string|null} [roleName] RoleInfo roleName
             * @property {number|Long|null} [color] RoleInfo color
             * @property {Array.<kritor.guild.IPermissionInfo>|null} [permissions] RoleInfo permissions
             * @property {number|Long|null} [type] RoleInfo type
             * @property {string|null} [displayName] RoleInfo displayName
             */

            /**
             * Constructs a new RoleInfo.
             * @memberof kritor.guild
             * @classdesc Represents a RoleInfo.
             * @implements IRoleInfo
             * @constructor
             * @param {kritor.guild.IRoleInfo=} [properties] Properties to set
             */
            function RoleInfo(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleInfo roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo roleName.
             * @member {string} roleName
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.roleName = "";

            /**
             * RoleInfo color.
             * @member {number|Long} color
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.color = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo permissions.
             * @member {Array.<kritor.guild.IPermissionInfo>} permissions
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.permissions = $util.emptyArray;

            /**
             * RoleInfo type.
             * @member {number|Long} type
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo displayName.
             * @member {string} displayName
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.displayName = "";

            /**
             * Creates a new RoleInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo=} [properties] Properties to set
             * @returns {kritor.guild.RoleInfo} RoleInfo instance
             */
            RoleInfo.create = function create(properties) {
                return new RoleInfo(properties);
            };

            /**
             * Encodes the specified RoleInfo message. Does not implicitly {@link kritor.guild.RoleInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo} message RoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roleId);
                if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleName);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.color);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.kritor.guild.PermissionInfo.encode(message.permissions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.type);
                if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.displayName);
                return writer;
            };

            /**
             * Encodes the specified RoleInfo message, length delimited. Does not implicitly {@link kritor.guild.RoleInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo} message RoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.RoleInfo} RoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.RoleInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleName = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.uint64();
                            break;
                        }
                    case 4: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.kritor.guild.PermissionInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.type = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.displayName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoleInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.RoleInfo} RoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleInfo message.
             * @function verify
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    if (!$util.isString(message.roleName))
                        return "roleName: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.kritor.guild.PermissionInfo.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                return null;
            };

            /**
             * Creates a RoleInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.RoleInfo} RoleInfo
             */
            RoleInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.RoleInfo)
                    return object;
                let message = new $root.kritor.guild.RoleInfo();
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.roleName != null)
                    message.roleName = String(object.roleName);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = true;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber(true);
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".kritor.guild.RoleInfo.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".kritor.guild.RoleInfo.permissions: object expected");
                        message.permissions[i] = $root.kritor.guild.PermissionInfo.fromObject(object.permissions[i]);
                    }
                }
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = true;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber(true);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                return message;
            };

            /**
             * Creates a plain object from a RoleInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.RoleInfo} message RoleInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoleInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.roleName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    object.displayName = "";
                }
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    object.roleName = message.roleName;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber(true) : message.color;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.kritor.guild.PermissionInfo.toObject(message.permissions[j], options);
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber(true) : message.type;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                return object;
            };

            /**
             * Converts this RoleInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.RoleInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoleInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RoleInfo
             * @function getTypeUrl
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.RoleInfo";
            };

            return RoleInfo;
        })();

        guild.PermissionInfo = (function() {

            /**
             * Properties of a PermissionInfo.
             * @memberof kritor.guild
             * @interface IPermissionInfo
             * @property {number|Long|null} [rootId] PermissionInfo rootId
             * @property {Array.<number|Long>|null} [childIds] PermissionInfo childIds
             */

            /**
             * Constructs a new PermissionInfo.
             * @memberof kritor.guild
             * @classdesc Represents a PermissionInfo.
             * @implements IPermissionInfo
             * @constructor
             * @param {kritor.guild.IPermissionInfo=} [properties] Properties to set
             */
            function PermissionInfo(properties) {
                this.childIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PermissionInfo rootId.
             * @member {number|Long} rootId
             * @memberof kritor.guild.PermissionInfo
             * @instance
             */
            PermissionInfo.prototype.rootId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PermissionInfo childIds.
             * @member {Array.<number|Long>} childIds
             * @memberof kritor.guild.PermissionInfo
             * @instance
             */
            PermissionInfo.prototype.childIds = $util.emptyArray;

            /**
             * Creates a new PermissionInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo=} [properties] Properties to set
             * @returns {kritor.guild.PermissionInfo} PermissionInfo instance
             */
            PermissionInfo.create = function create(properties) {
                return new PermissionInfo(properties);
            };

            /**
             * Encodes the specified PermissionInfo message. Does not implicitly {@link kritor.guild.PermissionInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo} message PermissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rootId != null && Object.hasOwnProperty.call(message, "rootId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rootId);
                if (message.childIds != null && message.childIds.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.childIds.length; ++i)
                        writer.uint64(message.childIds[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified PermissionInfo message, length delimited. Does not implicitly {@link kritor.guild.PermissionInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo} message PermissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PermissionInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.PermissionInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.rootId = reader.uint64();
                            break;
                        }
                    case 2: {
                            if (!(message.childIds && message.childIds.length))
                                message.childIds = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.childIds.push(reader.uint64());
                            } else
                                message.childIds.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PermissionInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PermissionInfo message.
             * @function verify
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PermissionInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rootId != null && message.hasOwnProperty("rootId"))
                    if (!$util.isInteger(message.rootId) && !(message.rootId && $util.isInteger(message.rootId.low) && $util.isInteger(message.rootId.high)))
                        return "rootId: integer|Long expected";
                if (message.childIds != null && message.hasOwnProperty("childIds")) {
                    if (!Array.isArray(message.childIds))
                        return "childIds: array expected";
                    for (let i = 0; i < message.childIds.length; ++i)
                        if (!$util.isInteger(message.childIds[i]) && !(message.childIds[i] && $util.isInteger(message.childIds[i].low) && $util.isInteger(message.childIds[i].high)))
                            return "childIds: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a PermissionInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             */
            PermissionInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.PermissionInfo)
                    return object;
                let message = new $root.kritor.guild.PermissionInfo();
                if (object.rootId != null)
                    if ($util.Long)
                        (message.rootId = $util.Long.fromValue(object.rootId)).unsigned = true;
                    else if (typeof object.rootId === "string")
                        message.rootId = parseInt(object.rootId, 10);
                    else if (typeof object.rootId === "number")
                        message.rootId = object.rootId;
                    else if (typeof object.rootId === "object")
                        message.rootId = new $util.LongBits(object.rootId.low >>> 0, object.rootId.high >>> 0).toNumber(true);
                if (object.childIds) {
                    if (!Array.isArray(object.childIds))
                        throw TypeError(".kritor.guild.PermissionInfo.childIds: array expected");
                    message.childIds = [];
                    for (let i = 0; i < object.childIds.length; ++i)
                        if ($util.Long)
                            (message.childIds[i] = $util.Long.fromValue(object.childIds[i])).unsigned = true;
                        else if (typeof object.childIds[i] === "string")
                            message.childIds[i] = parseInt(object.childIds[i], 10);
                        else if (typeof object.childIds[i] === "number")
                            message.childIds[i] = object.childIds[i];
                        else if (typeof object.childIds[i] === "object")
                            message.childIds[i] = new $util.LongBits(object.childIds[i].low >>> 0, object.childIds[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a PermissionInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.PermissionInfo} message PermissionInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PermissionInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.childIds = [];
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.rootId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rootId = options.longs === String ? "0" : 0;
                if (message.rootId != null && message.hasOwnProperty("rootId"))
                    if (typeof message.rootId === "number")
                        object.rootId = options.longs === String ? String(message.rootId) : message.rootId;
                    else
                        object.rootId = options.longs === String ? $util.Long.prototype.toString.call(message.rootId) : options.longs === Number ? new $util.LongBits(message.rootId.low >>> 0, message.rootId.high >>> 0).toNumber(true) : message.rootId;
                if (message.childIds && message.childIds.length) {
                    object.childIds = [];
                    for (let j = 0; j < message.childIds.length; ++j)
                        if (typeof message.childIds[j] === "number")
                            object.childIds[j] = options.longs === String ? String(message.childIds[j]) : message.childIds[j];
                        else
                            object.childIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.childIds[j]) : options.longs === Number ? new $util.LongBits(message.childIds[j].low >>> 0, message.childIds[j].high >>> 0).toNumber(true) : message.childIds[j];
                }
                return object;
            };

            /**
             * Converts this PermissionInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.PermissionInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PermissionInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PermissionInfo
             * @function getTypeUrl
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PermissionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.PermissionInfo";
            };

            return PermissionInfo;
        })();

        guild.RolesInfo = (function() {

            /**
             * Properties of a RolesInfo.
             * @memberof kritor.guild
             * @interface IRolesInfo
             * @property {number|Long|null} [roleId] RolesInfo roleId
             * @property {string|null} [roleName] RolesInfo roleName
             * @property {number|Long|null} [argbColor] RolesInfo argbColor
             * @property {boolean|null} [disabled] RolesInfo disabled
             * @property {boolean|null} [independent] RolesInfo independent
             * @property {number|Long|null} [maxCount] RolesInfo maxCount
             * @property {number|Long|null} [memberCount] RolesInfo memberCount
             * @property {boolean|null} [owned] RolesInfo owned
             * @property {Array.<kritor.guild.IPermissionInfo>|null} [permissions] RolesInfo permissions
             */

            /**
             * Constructs a new RolesInfo.
             * @memberof kritor.guild
             * @classdesc Represents a RolesInfo.
             * @implements IRolesInfo
             * @constructor
             * @param {kritor.guild.IRolesInfo=} [properties] Properties to set
             */
            function RolesInfo(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RolesInfo roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RolesInfo roleName.
             * @member {string} roleName
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.roleName = "";

            /**
             * RolesInfo argbColor.
             * @member {number|Long} argbColor
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.argbColor = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RolesInfo disabled.
             * @member {boolean} disabled
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.disabled = false;

            /**
             * RolesInfo independent.
             * @member {boolean} independent
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.independent = false;

            /**
             * RolesInfo maxCount.
             * @member {number|Long} maxCount
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.maxCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RolesInfo memberCount.
             * @member {number|Long} memberCount
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.memberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RolesInfo owned.
             * @member {boolean} owned
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.owned = false;

            /**
             * RolesInfo permissions.
             * @member {Array.<kritor.guild.IPermissionInfo>} permissions
             * @memberof kritor.guild.RolesInfo
             * @instance
             */
            RolesInfo.prototype.permissions = $util.emptyArray;

            /**
             * Creates a new RolesInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {kritor.guild.IRolesInfo=} [properties] Properties to set
             * @returns {kritor.guild.RolesInfo} RolesInfo instance
             */
            RolesInfo.create = function create(properties) {
                return new RolesInfo(properties);
            };

            /**
             * Encodes the specified RolesInfo message. Does not implicitly {@link kritor.guild.RolesInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {kritor.guild.IRolesInfo} message RolesInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RolesInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roleId);
                if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleName);
                if (message.argbColor != null && Object.hasOwnProperty.call(message, "argbColor"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.argbColor);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.disabled);
                if (message.independent != null && Object.hasOwnProperty.call(message, "independent"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.independent);
                if (message.maxCount != null && Object.hasOwnProperty.call(message, "maxCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.memberCount);
                if (message.owned != null && Object.hasOwnProperty.call(message, "owned"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.owned);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.kritor.guild.PermissionInfo.encode(message.permissions[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RolesInfo message, length delimited. Does not implicitly {@link kritor.guild.RolesInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {kritor.guild.IRolesInfo} message RolesInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RolesInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RolesInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.RolesInfo} RolesInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RolesInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.RolesInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleName = reader.string();
                            break;
                        }
                    case 3: {
                            message.argbColor = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 5: {
                            message.independent = reader.bool();
                            break;
                        }
                    case 6: {
                            message.maxCount = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.memberCount = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.owned = reader.bool();
                            break;
                        }
                    case 9: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.kritor.guild.PermissionInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RolesInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.RolesInfo} RolesInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RolesInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RolesInfo message.
             * @function verify
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RolesInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    if (!$util.isString(message.roleName))
                        return "roleName: string expected";
                if (message.argbColor != null && message.hasOwnProperty("argbColor"))
                    if (!$util.isInteger(message.argbColor) && !(message.argbColor && $util.isInteger(message.argbColor.low) && $util.isInteger(message.argbColor.high)))
                        return "argbColor: integer|Long expected";
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.independent != null && message.hasOwnProperty("independent"))
                    if (typeof message.independent !== "boolean")
                        return "independent: boolean expected";
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    if (!$util.isInteger(message.maxCount) && !(message.maxCount && $util.isInteger(message.maxCount.low) && $util.isInteger(message.maxCount.high)))
                        return "maxCount: integer|Long expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount) && !(message.memberCount && $util.isInteger(message.memberCount.low) && $util.isInteger(message.memberCount.high)))
                        return "memberCount: integer|Long expected";
                if (message.owned != null && message.hasOwnProperty("owned"))
                    if (typeof message.owned !== "boolean")
                        return "owned: boolean expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.kritor.guild.PermissionInfo.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RolesInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.RolesInfo} RolesInfo
             */
            RolesInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.RolesInfo)
                    return object;
                let message = new $root.kritor.guild.RolesInfo();
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.roleName != null)
                    message.roleName = String(object.roleName);
                if (object.argbColor != null)
                    if ($util.Long)
                        (message.argbColor = $util.Long.fromValue(object.argbColor)).unsigned = true;
                    else if (typeof object.argbColor === "string")
                        message.argbColor = parseInt(object.argbColor, 10);
                    else if (typeof object.argbColor === "number")
                        message.argbColor = object.argbColor;
                    else if (typeof object.argbColor === "object")
                        message.argbColor = new $util.LongBits(object.argbColor.low >>> 0, object.argbColor.high >>> 0).toNumber(true);
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.independent != null)
                    message.independent = Boolean(object.independent);
                if (object.maxCount != null)
                    if ($util.Long)
                        (message.maxCount = $util.Long.fromValue(object.maxCount)).unsigned = true;
                    else if (typeof object.maxCount === "string")
                        message.maxCount = parseInt(object.maxCount, 10);
                    else if (typeof object.maxCount === "number")
                        message.maxCount = object.maxCount;
                    else if (typeof object.maxCount === "object")
                        message.maxCount = new $util.LongBits(object.maxCount.low >>> 0, object.maxCount.high >>> 0).toNumber(true);
                if (object.memberCount != null)
                    if ($util.Long)
                        (message.memberCount = $util.Long.fromValue(object.memberCount)).unsigned = true;
                    else if (typeof object.memberCount === "string")
                        message.memberCount = parseInt(object.memberCount, 10);
                    else if (typeof object.memberCount === "number")
                        message.memberCount = object.memberCount;
                    else if (typeof object.memberCount === "object")
                        message.memberCount = new $util.LongBits(object.memberCount.low >>> 0, object.memberCount.high >>> 0).toNumber(true);
                if (object.owned != null)
                    message.owned = Boolean(object.owned);
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".kritor.guild.RolesInfo.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".kritor.guild.RolesInfo.permissions: object expected");
                        message.permissions[i] = $root.kritor.guild.PermissionInfo.fromObject(object.permissions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a RolesInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {kritor.guild.RolesInfo} message RolesInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RolesInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.roleName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.argbColor = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.argbColor = options.longs === String ? "0" : 0;
                    object.disabled = false;
                    object.independent = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.memberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memberCount = options.longs === String ? "0" : 0;
                    object.owned = false;
                }
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    object.roleName = message.roleName;
                if (message.argbColor != null && message.hasOwnProperty("argbColor"))
                    if (typeof message.argbColor === "number")
                        object.argbColor = options.longs === String ? String(message.argbColor) : message.argbColor;
                    else
                        object.argbColor = options.longs === String ? $util.Long.prototype.toString.call(message.argbColor) : options.longs === Number ? new $util.LongBits(message.argbColor.low >>> 0, message.argbColor.high >>> 0).toNumber(true) : message.argbColor;
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.independent != null && message.hasOwnProperty("independent"))
                    object.independent = message.independent;
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    if (typeof message.maxCount === "number")
                        object.maxCount = options.longs === String ? String(message.maxCount) : message.maxCount;
                    else
                        object.maxCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxCount) : options.longs === Number ? new $util.LongBits(message.maxCount.low >>> 0, message.maxCount.high >>> 0).toNumber(true) : message.maxCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (typeof message.memberCount === "number")
                        object.memberCount = options.longs === String ? String(message.memberCount) : message.memberCount;
                    else
                        object.memberCount = options.longs === String ? $util.Long.prototype.toString.call(message.memberCount) : options.longs === Number ? new $util.LongBits(message.memberCount.low >>> 0, message.memberCount.high >>> 0).toNumber(true) : message.memberCount;
                if (message.owned != null && message.hasOwnProperty("owned"))
                    object.owned = message.owned;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.kritor.guild.PermissionInfo.toObject(message.permissions[j], options);
                }
                return object;
            };

            /**
             * Converts this RolesInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.RolesInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RolesInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RolesInfo
             * @function getTypeUrl
             * @memberof kritor.guild.RolesInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RolesInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.RolesInfo";
            };

            return RolesInfo;
        })();

        guild.GuildService = (function() {

            /**
             * Constructs a new GuildService service.
             * @memberof kritor.guild
             * @classdesc Represents a GuildService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GuildService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GuildService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GuildService;

            /**
             * Creates new GuildService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.guild.GuildService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GuildService} RPC service. Useful where requests and/or responses are streamed.
             */
            GuildService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.guild.GuildService#getBotInfo}.
             * @memberof kritor.guild.GuildService
             * @typedef GetBotInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetBotInfoResponse} [response] GetBotInfoResponse
             */

            /**
             * Calls GetBotInfo.
             * @function getBotInfo
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetBotInfoRequest} request GetBotInfoRequest message or plain object
             * @param {kritor.guild.GuildService.GetBotInfoCallback} callback Node-style callback called with the error, if any, and GetBotInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getBotInfo = function getBotInfo(request, callback) {
                return this.rpcCall(getBotInfo, $root.kritor.guild.GetBotInfoRequest, $root.kritor.guild.GetBotInfoResponse, request, callback);
            }, "name", { value: "GetBotInfo" });

            /**
             * Calls GetBotInfo.
             * @function getBotInfo
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetBotInfoRequest} request GetBotInfoRequest message or plain object
             * @returns {Promise<kritor.guild.GetBotInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getChannelList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetChannelListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetChannelListResponse} [response] GetChannelListResponse
             */

            /**
             * Calls GetChannelList.
             * @function getChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetChannelListRequest} request GetChannelListRequest message or plain object
             * @param {kritor.guild.GuildService.GetChannelListCallback} callback Node-style callback called with the error, if any, and GetChannelListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getChannelList = function getChannelList(request, callback) {
                return this.rpcCall(getChannelList, $root.kritor.guild.GetChannelListRequest, $root.kritor.guild.GetChannelListResponse, request, callback);
            }, "name", { value: "GetChannelList" });

            /**
             * Calls GetChannelList.
             * @function getChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetChannelListRequest} request GetChannelListRequest message or plain object
             * @returns {Promise<kritor.guild.GetChannelListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMetaByGuest}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMetaByGuestCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMetaByGuestResponse} [response] GetGuildMetaByGuestResponse
             */

            /**
             * Calls GetGuildMetaByGuest.
             * @function getGuildMetaByGuest
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} request GetGuildMetaByGuestRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMetaByGuestCallback} callback Node-style callback called with the error, if any, and GetGuildMetaByGuestResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMetaByGuest = function getGuildMetaByGuest(request, callback) {
                return this.rpcCall(getGuildMetaByGuest, $root.kritor.guild.GetGuildMetaByGuestRequest, $root.kritor.guild.GetGuildMetaByGuestResponse, request, callback);
            }, "name", { value: "GetGuildMetaByGuest" });

            /**
             * Calls GetGuildMetaByGuest.
             * @function getGuildMetaByGuest
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} request GetGuildMetaByGuestRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMetaByGuestResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildChannelList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildChannelListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildChannelListResponse} [response] GetGuildChannelListResponse
             */

            /**
             * Calls GetGuildChannelList.
             * @function getGuildChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildChannelListRequest} request GetGuildChannelListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildChannelListCallback} callback Node-style callback called with the error, if any, and GetGuildChannelListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildChannelList = function getGuildChannelList(request, callback) {
                return this.rpcCall(getGuildChannelList, $root.kritor.guild.GetGuildChannelListRequest, $root.kritor.guild.GetGuildChannelListResponse, request, callback);
            }, "name", { value: "GetGuildChannelList" });

            /**
             * Calls GetGuildChannelList.
             * @function getGuildChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildChannelListRequest} request GetGuildChannelListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildChannelListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMemberList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMemberListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMemberListResponse} [response] GetGuildMemberListResponse
             */

            /**
             * Calls GetGuildMemberList.
             * @function getGuildMemberList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberListRequest} request GetGuildMemberListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMemberListCallback} callback Node-style callback called with the error, if any, and GetGuildMemberListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMemberList = function getGuildMemberList(request, callback) {
                return this.rpcCall(getGuildMemberList, $root.kritor.guild.GetGuildMemberListRequest, $root.kritor.guild.GetGuildMemberListResponse, request, callback);
            }, "name", { value: "GetGuildMemberList" });

            /**
             * Calls GetGuildMemberList.
             * @function getGuildMemberList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberListRequest} request GetGuildMemberListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMemberListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMember}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMemberResponse} [response] GetGuildMemberResponse
             */

            /**
             * Calls GetGuildMember.
             * @function getGuildMember
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberRequest} request GetGuildMemberRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMemberCallback} callback Node-style callback called with the error, if any, and GetGuildMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMember = function getGuildMember(request, callback) {
                return this.rpcCall(getGuildMember, $root.kritor.guild.GetGuildMemberRequest, $root.kritor.guild.GetGuildMemberResponse, request, callback);
            }, "name", { value: "GetGuildMember" });

            /**
             * Calls GetGuildMember.
             * @function getGuildMember
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberRequest} request GetGuildMemberRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#sendChannelMessage}.
             * @memberof kritor.guild.GuildService
             * @typedef SendChannelMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.SendChannelMessageResponse} [response] SendChannelMessageResponse
             */

            /**
             * Calls SendChannelMessage.
             * @function sendChannelMessage
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISendChannelMessageRequest} request SendChannelMessageRequest message or plain object
             * @param {kritor.guild.GuildService.SendChannelMessageCallback} callback Node-style callback called with the error, if any, and SendChannelMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.sendChannelMessage = function sendChannelMessage(request, callback) {
                return this.rpcCall(sendChannelMessage, $root.kritor.guild.SendChannelMessageRequest, $root.kritor.guild.SendChannelMessageResponse, request, callback);
            }, "name", { value: "SendChannelMessage" });

            /**
             * Calls SendChannelMessage.
             * @function sendChannelMessage
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISendChannelMessageRequest} request SendChannelMessageRequest message or plain object
             * @returns {Promise<kritor.guild.SendChannelMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildFeeds}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildFeedsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildFeedsResponse} [response] GetGuildFeedsResponse
             */

            /**
             * Calls GetGuildFeeds.
             * @function getGuildFeeds
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildFeedsRequest} request GetGuildFeedsRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildFeedsCallback} callback Node-style callback called with the error, if any, and GetGuildFeedsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildFeeds = function getGuildFeeds(request, callback) {
                return this.rpcCall(getGuildFeeds, $root.kritor.guild.GetGuildFeedsRequest, $root.kritor.guild.GetGuildFeedsResponse, request, callback);
            }, "name", { value: "GetGuildFeeds" });

            /**
             * Calls GetGuildFeeds.
             * @function getGuildFeeds
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildFeedsRequest} request GetGuildFeedsRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildFeedsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildRoles}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildRolesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildRolesResponse} [response] GetGuildRolesResponse
             */

            /**
             * Calls GetGuildRoles.
             * @function getGuildRoles
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildRolesRequest} request GetGuildRolesRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildRolesCallback} callback Node-style callback called with the error, if any, and GetGuildRolesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildRoles = function getGuildRoles(request, callback) {
                return this.rpcCall(getGuildRoles, $root.kritor.guild.GetGuildRolesRequest, $root.kritor.guild.GetGuildRolesResponse, request, callback);
            }, "name", { value: "GetGuildRoles" });

            /**
             * Calls GetGuildRoles.
             * @function getGuildRoles
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildRolesRequest} request GetGuildRolesRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildRolesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#deleteGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef DeleteGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.DeleteGuildRoleResponse} [response] DeleteGuildRoleResponse
             */

            /**
             * Calls DeleteGuildRole.
             * @function deleteGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IDeleteGuildRoleRequest} request DeleteGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.DeleteGuildRoleCallback} callback Node-style callback called with the error, if any, and DeleteGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.deleteGuildRole = function deleteGuildRole(request, callback) {
                return this.rpcCall(deleteGuildRole, $root.kritor.guild.DeleteGuildRoleRequest, $root.kritor.guild.DeleteGuildRoleResponse, request, callback);
            }, "name", { value: "DeleteGuildRole" });

            /**
             * Calls DeleteGuildRole.
             * @function deleteGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IDeleteGuildRoleRequest} request DeleteGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.DeleteGuildRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#setGuildMemberRole}.
             * @memberof kritor.guild.GuildService
             * @typedef SetGuildMemberRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.SetGuildMemberRoleResponse} [response] SetGuildMemberRoleResponse
             */

            /**
             * Calls SetGuildMemberRole.
             * @function setGuildMemberRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISetGuildMemberRoleRequest} request SetGuildMemberRoleRequest message or plain object
             * @param {kritor.guild.GuildService.SetGuildMemberRoleCallback} callback Node-style callback called with the error, if any, and SetGuildMemberRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.setGuildMemberRole = function setGuildMemberRole(request, callback) {
                return this.rpcCall(setGuildMemberRole, $root.kritor.guild.SetGuildMemberRoleRequest, $root.kritor.guild.SetGuildMemberRoleResponse, request, callback);
            }, "name", { value: "SetGuildMemberRole" });

            /**
             * Calls SetGuildMemberRole.
             * @function setGuildMemberRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISetGuildMemberRoleRequest} request SetGuildMemberRoleRequest message or plain object
             * @returns {Promise<kritor.guild.SetGuildMemberRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#updateGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef UpdateGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.UpdateGuildRoleResponse} [response] UpdateGuildRoleResponse
             */

            /**
             * Calls UpdateGuildRole.
             * @function updateGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IUpdateGuildRoleRequest} request UpdateGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.UpdateGuildRoleCallback} callback Node-style callback called with the error, if any, and UpdateGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.updateGuildRole = function updateGuildRole(request, callback) {
                return this.rpcCall(updateGuildRole, $root.kritor.guild.UpdateGuildRoleRequest, $root.kritor.guild.UpdateGuildRoleResponse, request, callback);
            }, "name", { value: "UpdateGuildRole" });

            /**
             * Calls UpdateGuildRole.
             * @function updateGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IUpdateGuildRoleRequest} request UpdateGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.UpdateGuildRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#createGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef CreateGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.CreateGuildRoleResponse} [response] CreateGuildRoleResponse
             */

            /**
             * Calls CreateGuildRole.
             * @function createGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ICreateGuildRoleRequest} request CreateGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.CreateGuildRoleCallback} callback Node-style callback called with the error, if any, and CreateGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.createGuildRole = function createGuildRole(request, callback) {
                return this.rpcCall(createGuildRole, $root.kritor.guild.CreateGuildRoleRequest, $root.kritor.guild.CreateGuildRoleResponse, request, callback);
            }, "name", { value: "CreateGuildRole" });

            /**
             * Calls CreateGuildRole.
             * @function createGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ICreateGuildRoleRequest} request CreateGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.CreateGuildRoleResponse>} Promise
             * @variation 2
             */

            return GuildService;
        })();

        guild.GetBotInfoRequest = (function() {

            /**
             * Properties of a GetBotInfoRequest.
             * @memberof kritor.guild
             * @interface IGetBotInfoRequest
             */

            /**
             * Constructs a new GetBotInfoRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetBotInfoRequest.
             * @implements IGetBotInfoRequest
             * @constructor
             * @param {kritor.guild.IGetBotInfoRequest=} [properties] Properties to set
             */
            function GetBotInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetBotInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest instance
             */
            GetBotInfoRequest.create = function create(properties) {
                return new GetBotInfoRequest(properties);
            };

            /**
             * Encodes the specified GetBotInfoRequest message. Does not implicitly {@link kritor.guild.GetBotInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest} message GetBotInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetBotInfoRequest message, length delimited. Does not implicitly {@link kritor.guild.GetBotInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest} message GetBotInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBotInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetBotInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBotInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBotInfoRequest message.
             * @function verify
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBotInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetBotInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             */
            GetBotInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetBotInfoRequest)
                    return object;
                return new $root.kritor.guild.GetBotInfoRequest();
            };

            /**
             * Creates a plain object from a GetBotInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.GetBotInfoRequest} message GetBotInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBotInfoRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetBotInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetBotInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBotInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBotInfoRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBotInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetBotInfoRequest";
            };

            return GetBotInfoRequest;
        })();

        guild.GetBotInfoResponse = (function() {

            /**
             * Properties of a GetBotInfoResponse.
             * @memberof kritor.guild
             * @interface IGetBotInfoResponse
             * @property {string|null} [nickname] GetBotInfoResponse nickname
             * @property {number|Long|null} [tinyId] GetBotInfoResponse tinyId
             * @property {string|null} [avatar] GetBotInfoResponse avatar
             */

            /**
             * Constructs a new GetBotInfoResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetBotInfoResponse.
             * @implements IGetBotInfoResponse
             * @constructor
             * @param {kritor.guild.IGetBotInfoResponse=} [properties] Properties to set
             */
            function GetBotInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetBotInfoResponse nickname.
             * @member {string} nickname
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.nickname = "";

            /**
             * GetBotInfoResponse tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetBotInfoResponse avatar.
             * @member {string} avatar
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.avatar = "";

            /**
             * Creates a new GetBotInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse instance
             */
            GetBotInfoResponse.create = function create(properties) {
                return new GetBotInfoResponse(properties);
            };

            /**
             * Encodes the specified GetBotInfoResponse message. Does not implicitly {@link kritor.guild.GetBotInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse} message GetBotInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickname);
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tinyId);
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatar);
                return writer;
            };

            /**
             * Encodes the specified GetBotInfoResponse message, length delimited. Does not implicitly {@link kritor.guild.GetBotInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse} message GetBotInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBotInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetBotInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 2: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.avatar = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBotInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBotInfoResponse message.
             * @function verify
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBotInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                return null;
            };

            /**
             * Creates a GetBotInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             */
            GetBotInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetBotInfoResponse)
                    return object;
                let message = new $root.kritor.guild.GetBotInfoResponse();
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                return message;
            };

            /**
             * Creates a plain object from a GetBotInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.GetBotInfoResponse} message GetBotInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBotInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nickname = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                    object.avatar = "";
                }
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                return object;
            };

            /**
             * Converts this GetBotInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBotInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBotInfoResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBotInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetBotInfoResponse";
            };

            return GetBotInfoResponse;
        })();

        guild.GetChannelListRequest = (function() {

            /**
             * Properties of a GetChannelListRequest.
             * @memberof kritor.guild
             * @interface IGetChannelListRequest
             */

            /**
             * Constructs a new GetChannelListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetChannelListRequest.
             * @implements IGetChannelListRequest
             * @constructor
             * @param {kritor.guild.IGetChannelListRequest=} [properties] Properties to set
             */
            function GetChannelListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetChannelListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest instance
             */
            GetChannelListRequest.create = function create(properties) {
                return new GetChannelListRequest(properties);
            };

            /**
             * Encodes the specified GetChannelListRequest message. Does not implicitly {@link kritor.guild.GetChannelListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest} message GetChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetChannelListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetChannelListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest} message GetChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetChannelListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetChannelListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetChannelListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetChannelListRequest message.
             * @function verify
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChannelListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetChannelListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             */
            GetChannelListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetChannelListRequest)
                    return object;
                return new $root.kritor.guild.GetChannelListRequest();
            };

            /**
             * Creates a plain object from a GetChannelListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.GetChannelListRequest} message GetChannelListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChannelListRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetChannelListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetChannelListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChannelListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetChannelListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetChannelListRequest";
            };

            return GetChannelListRequest;
        })();

        guild.GetChannelListResponse = (function() {

            /**
             * Properties of a GetChannelListResponse.
             * @memberof kritor.guild
             * @interface IGetChannelListResponse
             * @property {Array.<kritor.guild.IGuildInfo>|null} [getGuildList] GetChannelListResponse getGuildList
             */

            /**
             * Constructs a new GetChannelListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetChannelListResponse.
             * @implements IGetChannelListResponse
             * @constructor
             * @param {kritor.guild.IGetChannelListResponse=} [properties] Properties to set
             */
            function GetChannelListResponse(properties) {
                this.getGuildList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetChannelListResponse getGuildList.
             * @member {Array.<kritor.guild.IGuildInfo>} getGuildList
             * @memberof kritor.guild.GetChannelListResponse
             * @instance
             */
            GetChannelListResponse.prototype.getGuildList = $util.emptyArray;

            /**
             * Creates a new GetChannelListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse instance
             */
            GetChannelListResponse.create = function create(properties) {
                return new GetChannelListResponse(properties);
            };

            /**
             * Encodes the specified GetChannelListResponse message. Does not implicitly {@link kritor.guild.GetChannelListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse} message GetChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.getGuildList != null && message.getGuildList.length)
                    for (let i = 0; i < message.getGuildList.length; ++i)
                        $root.kritor.guild.GuildInfo.encode(message.getGuildList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetChannelListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetChannelListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse} message GetChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetChannelListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetChannelListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.getGuildList && message.getGuildList.length))
                                message.getGuildList = [];
                            message.getGuildList.push($root.kritor.guild.GuildInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetChannelListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetChannelListResponse message.
             * @function verify
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChannelListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.getGuildList != null && message.hasOwnProperty("getGuildList")) {
                    if (!Array.isArray(message.getGuildList))
                        return "getGuildList: array expected";
                    for (let i = 0; i < message.getGuildList.length; ++i) {
                        let error = $root.kritor.guild.GuildInfo.verify(message.getGuildList[i]);
                        if (error)
                            return "getGuildList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetChannelListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             */
            GetChannelListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetChannelListResponse)
                    return object;
                let message = new $root.kritor.guild.GetChannelListResponse();
                if (object.getGuildList) {
                    if (!Array.isArray(object.getGuildList))
                        throw TypeError(".kritor.guild.GetChannelListResponse.getGuildList: array expected");
                    message.getGuildList = [];
                    for (let i = 0; i < object.getGuildList.length; ++i) {
                        if (typeof object.getGuildList[i] !== "object")
                            throw TypeError(".kritor.guild.GetChannelListResponse.getGuildList: object expected");
                        message.getGuildList[i] = $root.kritor.guild.GuildInfo.fromObject(object.getGuildList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetChannelListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.GetChannelListResponse} message GetChannelListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChannelListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.getGuildList = [];
                if (message.getGuildList && message.getGuildList.length) {
                    object.getGuildList = [];
                    for (let j = 0; j < message.getGuildList.length; ++j)
                        object.getGuildList[j] = $root.kritor.guild.GuildInfo.toObject(message.getGuildList[j], options);
                }
                return object;
            };

            /**
             * Converts this GetChannelListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetChannelListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChannelListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetChannelListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetChannelListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetChannelListResponse";
            };

            return GetChannelListResponse;
        })();

        guild.GetGuildMetaByGuestRequest = (function() {

            /**
             * Properties of a GetGuildMetaByGuestRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMetaByGuestRequest
             * @property {number|Long|null} [guildId] GetGuildMetaByGuestRequest guildId
             */

            /**
             * Constructs a new GetGuildMetaByGuestRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMetaByGuestRequest.
             * @implements IGetGuildMetaByGuestRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMetaByGuestRequest=} [properties] Properties to set
             */
            function GetGuildMetaByGuestRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMetaByGuestRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @instance
             */
            GetGuildMetaByGuestRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildMetaByGuestRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest instance
             */
            GetGuildMetaByGuestRequest.create = function create(properties) {
                return new GetGuildMetaByGuestRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMetaByGuestRequest message. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMetaByGuestRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMetaByGuestRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMetaByGuestRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMetaByGuestRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMetaByGuestRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMetaByGuestRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildMetaByGuestRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             */
            GetGuildMetaByGuestRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMetaByGuestRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMetaByGuestRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMetaByGuestRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.GetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMetaByGuestRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                return object;
            };

            /**
             * Converts this GetGuildMetaByGuestRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMetaByGuestRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMetaByGuestRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMetaByGuestRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMetaByGuestRequest";
            };

            return GetGuildMetaByGuestRequest;
        })();

        guild.GetGuildMetaByGuestResponse = (function() {

            /**
             * Properties of a GetGuildMetaByGuestResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMetaByGuestResponse
             * @property {number|Long|null} [guildId] GetGuildMetaByGuestResponse guildId
             * @property {string|null} [guildName] GetGuildMetaByGuestResponse guildName
             * @property {string|null} [guildProfile] GetGuildMetaByGuestResponse guildProfile
             * @property {number|Long|null} [createTime] GetGuildMetaByGuestResponse createTime
             * @property {number|Long|null} [maxMemberCount] GetGuildMetaByGuestResponse maxMemberCount
             * @property {number|Long|null} [maxRobotCount] GetGuildMetaByGuestResponse maxRobotCount
             * @property {number|Long|null} [maxAdminCount] GetGuildMetaByGuestResponse maxAdminCount
             * @property {number|Long|null} [memberCount] GetGuildMetaByGuestResponse memberCount
             * @property {number|Long|null} [ownerId] GetGuildMetaByGuestResponse ownerId
             * @property {string|null} [guildDisplayId] GetGuildMetaByGuestResponse guildDisplayId
             */

            /**
             * Constructs a new GetGuildMetaByGuestResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMetaByGuestResponse.
             * @implements IGetGuildMetaByGuestResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMetaByGuestResponse=} [properties] Properties to set
             */
            function GetGuildMetaByGuestResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMetaByGuestResponse guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse guildName.
             * @member {string} guildName
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildName = "";

            /**
             * GetGuildMetaByGuestResponse guildProfile.
             * @member {string} guildProfile
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildProfile = "";

            /**
             * GetGuildMetaByGuestResponse createTime.
             * @member {number|Long} createTime
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse maxMemberCount.
             * @member {number|Long} maxMemberCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.maxMemberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse maxRobotCount.
             * @member {number|Long} maxRobotCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.maxRobotCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse maxAdminCount.
             * @member {number|Long} maxAdminCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.maxAdminCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse memberCount.
             * @member {number|Long} memberCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.memberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse ownerId.
             * @member {number|Long} ownerId
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.ownerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse guildDisplayId.
             * @member {string} guildDisplayId
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildDisplayId = "";

            /**
             * Creates a new GetGuildMetaByGuestResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse instance
             */
            GetGuildMetaByGuestResponse.create = function create(properties) {
                return new GetGuildMetaByGuestResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMetaByGuestResponse message. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.guildName != null && Object.hasOwnProperty.call(message, "guildName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.guildName);
                if (message.guildProfile != null && Object.hasOwnProperty.call(message, "guildProfile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.guildProfile);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.createTime);
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxMemberCount);
                if (message.maxRobotCount != null && Object.hasOwnProperty.call(message, "maxRobotCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxRobotCount);
                if (message.maxAdminCount != null && Object.hasOwnProperty.call(message, "maxAdminCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.maxAdminCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.memberCount);
                if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.ownerId);
                if (message.guildDisplayId != null && Object.hasOwnProperty.call(message, "guildDisplayId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.guildDisplayId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMetaByGuestResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMetaByGuestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMetaByGuestResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guildName = reader.string();
                            break;
                        }
                    case 3: {
                            message.guildProfile = reader.string();
                            break;
                        }
                    case 4: {
                            message.createTime = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.maxMemberCount = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.maxRobotCount = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.maxAdminCount = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.memberCount = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.ownerId = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.guildDisplayId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMetaByGuestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMetaByGuestResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMetaByGuestResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    if (!$util.isString(message.guildName))
                        return "guildName: string expected";
                if (message.guildProfile != null && message.hasOwnProperty("guildProfile"))
                    if (!$util.isString(message.guildProfile))
                        return "guildProfile: string expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                        return "createTime: integer|Long expected";
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount) && !(message.maxMemberCount && $util.isInteger(message.maxMemberCount.low) && $util.isInteger(message.maxMemberCount.high)))
                        return "maxMemberCount: integer|Long expected";
                if (message.maxRobotCount != null && message.hasOwnProperty("maxRobotCount"))
                    if (!$util.isInteger(message.maxRobotCount) && !(message.maxRobotCount && $util.isInteger(message.maxRobotCount.low) && $util.isInteger(message.maxRobotCount.high)))
                        return "maxRobotCount: integer|Long expected";
                if (message.maxAdminCount != null && message.hasOwnProperty("maxAdminCount"))
                    if (!$util.isInteger(message.maxAdminCount) && !(message.maxAdminCount && $util.isInteger(message.maxAdminCount.low) && $util.isInteger(message.maxAdminCount.high)))
                        return "maxAdminCount: integer|Long expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount) && !(message.memberCount && $util.isInteger(message.memberCount.low) && $util.isInteger(message.memberCount.high)))
                        return "memberCount: integer|Long expected";
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (!$util.isInteger(message.ownerId) && !(message.ownerId && $util.isInteger(message.ownerId.low) && $util.isInteger(message.ownerId.high)))
                        return "ownerId: integer|Long expected";
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    if (!$util.isString(message.guildDisplayId))
                        return "guildDisplayId: string expected";
                return null;
            };

            /**
             * Creates a GetGuildMetaByGuestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             */
            GetGuildMetaByGuestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMetaByGuestResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMetaByGuestResponse();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.guildName != null)
                    message.guildName = String(object.guildName);
                if (object.guildProfile != null)
                    message.guildProfile = String(object.guildProfile);
                if (object.createTime != null)
                    if ($util.Long)
                        (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = true;
                    else if (typeof object.createTime === "string")
                        message.createTime = parseInt(object.createTime, 10);
                    else if (typeof object.createTime === "number")
                        message.createTime = object.createTime;
                    else if (typeof object.createTime === "object")
                        message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber(true);
                if (object.maxMemberCount != null)
                    if ($util.Long)
                        (message.maxMemberCount = $util.Long.fromValue(object.maxMemberCount)).unsigned = true;
                    else if (typeof object.maxMemberCount === "string")
                        message.maxMemberCount = parseInt(object.maxMemberCount, 10);
                    else if (typeof object.maxMemberCount === "number")
                        message.maxMemberCount = object.maxMemberCount;
                    else if (typeof object.maxMemberCount === "object")
                        message.maxMemberCount = new $util.LongBits(object.maxMemberCount.low >>> 0, object.maxMemberCount.high >>> 0).toNumber(true);
                if (object.maxRobotCount != null)
                    if ($util.Long)
                        (message.maxRobotCount = $util.Long.fromValue(object.maxRobotCount)).unsigned = true;
                    else if (typeof object.maxRobotCount === "string")
                        message.maxRobotCount = parseInt(object.maxRobotCount, 10);
                    else if (typeof object.maxRobotCount === "number")
                        message.maxRobotCount = object.maxRobotCount;
                    else if (typeof object.maxRobotCount === "object")
                        message.maxRobotCount = new $util.LongBits(object.maxRobotCount.low >>> 0, object.maxRobotCount.high >>> 0).toNumber(true);
                if (object.maxAdminCount != null)
                    if ($util.Long)
                        (message.maxAdminCount = $util.Long.fromValue(object.maxAdminCount)).unsigned = true;
                    else if (typeof object.maxAdminCount === "string")
                        message.maxAdminCount = parseInt(object.maxAdminCount, 10);
                    else if (typeof object.maxAdminCount === "number")
                        message.maxAdminCount = object.maxAdminCount;
                    else if (typeof object.maxAdminCount === "object")
                        message.maxAdminCount = new $util.LongBits(object.maxAdminCount.low >>> 0, object.maxAdminCount.high >>> 0).toNumber(true);
                if (object.memberCount != null)
                    if ($util.Long)
                        (message.memberCount = $util.Long.fromValue(object.memberCount)).unsigned = true;
                    else if (typeof object.memberCount === "string")
                        message.memberCount = parseInt(object.memberCount, 10);
                    else if (typeof object.memberCount === "number")
                        message.memberCount = object.memberCount;
                    else if (typeof object.memberCount === "object")
                        message.memberCount = new $util.LongBits(object.memberCount.low >>> 0, object.memberCount.high >>> 0).toNumber(true);
                if (object.ownerId != null)
                    if ($util.Long)
                        (message.ownerId = $util.Long.fromValue(object.ownerId)).unsigned = true;
                    else if (typeof object.ownerId === "string")
                        message.ownerId = parseInt(object.ownerId, 10);
                    else if (typeof object.ownerId === "number")
                        message.ownerId = object.ownerId;
                    else if (typeof object.ownerId === "object")
                        message.ownerId = new $util.LongBits(object.ownerId.low >>> 0, object.ownerId.high >>> 0).toNumber(true);
                if (object.guildDisplayId != null)
                    message.guildDisplayId = String(object.guildDisplayId);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMetaByGuestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.GetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMetaByGuestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.guildName = "";
                    object.guildProfile = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.createTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxMemberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxMemberCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxRobotCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxRobotCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxAdminCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxAdminCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.memberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memberCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.ownerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ownerId = options.longs === String ? "0" : 0;
                    object.guildDisplayId = "";
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    object.guildName = message.guildName;
                if (message.guildProfile != null && message.hasOwnProperty("guildProfile"))
                    object.guildProfile = message.guildProfile;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (typeof message.createTime === "number")
                        object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                    else
                        object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber(true) : message.createTime;
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (typeof message.maxMemberCount === "number")
                        object.maxMemberCount = options.longs === String ? String(message.maxMemberCount) : message.maxMemberCount;
                    else
                        object.maxMemberCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxMemberCount) : options.longs === Number ? new $util.LongBits(message.maxMemberCount.low >>> 0, message.maxMemberCount.high >>> 0).toNumber(true) : message.maxMemberCount;
                if (message.maxRobotCount != null && message.hasOwnProperty("maxRobotCount"))
                    if (typeof message.maxRobotCount === "number")
                        object.maxRobotCount = options.longs === String ? String(message.maxRobotCount) : message.maxRobotCount;
                    else
                        object.maxRobotCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxRobotCount) : options.longs === Number ? new $util.LongBits(message.maxRobotCount.low >>> 0, message.maxRobotCount.high >>> 0).toNumber(true) : message.maxRobotCount;
                if (message.maxAdminCount != null && message.hasOwnProperty("maxAdminCount"))
                    if (typeof message.maxAdminCount === "number")
                        object.maxAdminCount = options.longs === String ? String(message.maxAdminCount) : message.maxAdminCount;
                    else
                        object.maxAdminCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxAdminCount) : options.longs === Number ? new $util.LongBits(message.maxAdminCount.low >>> 0, message.maxAdminCount.high >>> 0).toNumber(true) : message.maxAdminCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (typeof message.memberCount === "number")
                        object.memberCount = options.longs === String ? String(message.memberCount) : message.memberCount;
                    else
                        object.memberCount = options.longs === String ? $util.Long.prototype.toString.call(message.memberCount) : options.longs === Number ? new $util.LongBits(message.memberCount.low >>> 0, message.memberCount.high >>> 0).toNumber(true) : message.memberCount;
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (typeof message.ownerId === "number")
                        object.ownerId = options.longs === String ? String(message.ownerId) : message.ownerId;
                    else
                        object.ownerId = options.longs === String ? $util.Long.prototype.toString.call(message.ownerId) : options.longs === Number ? new $util.LongBits(message.ownerId.low >>> 0, message.ownerId.high >>> 0).toNumber(true) : message.ownerId;
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    object.guildDisplayId = message.guildDisplayId;
                return object;
            };

            /**
             * Converts this GetGuildMetaByGuestResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMetaByGuestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMetaByGuestResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMetaByGuestResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMetaByGuestResponse";
            };

            return GetGuildMetaByGuestResponse;
        })();

        guild.GetGuildChannelListRequest = (function() {

            /**
             * Properties of a GetGuildChannelListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildChannelListRequest
             * @property {number|Long|null} [guildId] GetGuildChannelListRequest guildId
             * @property {boolean|null} [refresh] GetGuildChannelListRequest refresh
             */

            /**
             * Constructs a new GetGuildChannelListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildChannelListRequest.
             * @implements IGetGuildChannelListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildChannelListRequest=} [properties] Properties to set
             */
            function GetGuildChannelListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildChannelListRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             */
            GetGuildChannelListRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildChannelListRequest refresh.
             * @member {boolean} refresh
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             */
            GetGuildChannelListRequest.prototype.refresh = false;

            /**
             * Creates a new GetGuildChannelListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest instance
             */
            GetGuildChannelListRequest.create = function create(properties) {
                return new GetGuildChannelListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildChannelListRequest message. Does not implicitly {@link kritor.guild.GetGuildChannelListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest} message GetGuildChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGuildChannelListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildChannelListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest} message GetGuildChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildChannelListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildChannelListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildChannelListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildChannelListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildChannelListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildChannelListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             */
            GetGuildChannelListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildChannelListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildChannelListRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildChannelListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.GetGuildChannelListRequest} message GetGuildChannelListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildChannelListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.refresh = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    object.refresh = message.refresh;
                return object;
            };

            /**
             * Converts this GetGuildChannelListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildChannelListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildChannelListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildChannelListRequest";
            };

            return GetGuildChannelListRequest;
        })();

        guild.GetGuildChannelListResponse = (function() {

            /**
             * Properties of a GetGuildChannelListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildChannelListResponse
             * @property {Array.<kritor.guild.IChannelInfo>|null} [getGuildList] GetGuildChannelListResponse getGuildList
             */

            /**
             * Constructs a new GetGuildChannelListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildChannelListResponse.
             * @implements IGetGuildChannelListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildChannelListResponse=} [properties] Properties to set
             */
            function GetGuildChannelListResponse(properties) {
                this.getGuildList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildChannelListResponse getGuildList.
             * @member {Array.<kritor.guild.IChannelInfo>} getGuildList
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @instance
             */
            GetGuildChannelListResponse.prototype.getGuildList = $util.emptyArray;

            /**
             * Creates a new GetGuildChannelListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse instance
             */
            GetGuildChannelListResponse.create = function create(properties) {
                return new GetGuildChannelListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildChannelListResponse message. Does not implicitly {@link kritor.guild.GetGuildChannelListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse} message GetGuildChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.getGuildList != null && message.getGuildList.length)
                    for (let i = 0; i < message.getGuildList.length; ++i)
                        $root.kritor.guild.ChannelInfo.encode(message.getGuildList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildChannelListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildChannelListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse} message GetGuildChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildChannelListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildChannelListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.getGuildList && message.getGuildList.length))
                                message.getGuildList = [];
                            message.getGuildList.push($root.kritor.guild.ChannelInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildChannelListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildChannelListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildChannelListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.getGuildList != null && message.hasOwnProperty("getGuildList")) {
                    if (!Array.isArray(message.getGuildList))
                        return "getGuildList: array expected";
                    for (let i = 0; i < message.getGuildList.length; ++i) {
                        let error = $root.kritor.guild.ChannelInfo.verify(message.getGuildList[i]);
                        if (error)
                            return "getGuildList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGuildChannelListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             */
            GetGuildChannelListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildChannelListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildChannelListResponse();
                if (object.getGuildList) {
                    if (!Array.isArray(object.getGuildList))
                        throw TypeError(".kritor.guild.GetGuildChannelListResponse.getGuildList: array expected");
                    message.getGuildList = [];
                    for (let i = 0; i < object.getGuildList.length; ++i) {
                        if (typeof object.getGuildList[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildChannelListResponse.getGuildList: object expected");
                        message.getGuildList[i] = $root.kritor.guild.ChannelInfo.fromObject(object.getGuildList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildChannelListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.GetGuildChannelListResponse} message GetGuildChannelListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildChannelListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.getGuildList = [];
                if (message.getGuildList && message.getGuildList.length) {
                    object.getGuildList = [];
                    for (let j = 0; j < message.getGuildList.length; ++j)
                        object.getGuildList[j] = $root.kritor.guild.ChannelInfo.toObject(message.getGuildList[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGuildChannelListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildChannelListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildChannelListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildChannelListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildChannelListResponse";
            };

            return GetGuildChannelListResponse;
        })();

        guild.GetGuildMemberListRequest = (function() {

            /**
             * Properties of a GetGuildMemberListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMemberListRequest
             * @property {number|Long|null} [guildId] GetGuildMemberListRequest guildId
             * @property {string|null} [nextToken] GetGuildMemberListRequest nextToken
             * @property {boolean|null} [all] GetGuildMemberListRequest all
             * @property {boolean|null} [refresh] GetGuildMemberListRequest refresh
             */

            /**
             * Constructs a new GetGuildMemberListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberListRequest.
             * @implements IGetGuildMemberListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMemberListRequest=} [properties] Properties to set
             */
            function GetGuildMemberListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberListRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMemberListRequest nextToken.
             * @member {string} nextToken
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.nextToken = "";

            /**
             * GetGuildMemberListRequest all.
             * @member {boolean} all
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.all = false;

            /**
             * GetGuildMemberListRequest refresh.
             * @member {boolean} refresh
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.refresh = false;

            /**
             * Creates a new GetGuildMemberListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest instance
             */
            GetGuildMemberListRequest.create = function create(properties) {
                return new GetGuildMemberListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMemberListRequest message. Does not implicitly {@link kritor.guild.GetGuildMemberListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest} message GetGuildMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextToken);
                if (message.all != null && Object.hasOwnProperty.call(message, "all"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.all);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest} message GetGuildMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.nextToken = reader.string();
                            break;
                        }
                    case 3: {
                            message.all = reader.bool();
                            break;
                        }
                    case 4: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!$util.isString(message.nextToken))
                        return "nextToken: string expected";
                if (message.all != null && message.hasOwnProperty("all"))
                    if (typeof message.all !== "boolean")
                        return "all: boolean expected";
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             */
            GetGuildMemberListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberListRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.nextToken != null)
                    message.nextToken = String(object.nextToken);
                if (object.all != null)
                    message.all = Boolean(object.all);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.GetGuildMemberListRequest} message GetGuildMemberListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.nextToken = "";
                    object.all = false;
                    object.refresh = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = message.nextToken;
                if (message.all != null && message.hasOwnProperty("all"))
                    object.all = message.all;
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    object.refresh = message.refresh;
                return object;
            };

            /**
             * Converts this GetGuildMemberListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberListRequest";
            };

            return GetGuildMemberListRequest;
        })();

        guild.GetGuildMemberListResponse = (function() {

            /**
             * Properties of a GetGuildMemberListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMemberListResponse
             * @property {Array.<kritor.guild.IMemberInfo>|null} [getMemberList] GetGuildMemberListResponse getMemberList
             * @property {string|null} [nextToken] GetGuildMemberListResponse nextToken
             * @property {boolean|null} [finished] GetGuildMemberListResponse finished
             */

            /**
             * Constructs a new GetGuildMemberListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberListResponse.
             * @implements IGetGuildMemberListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMemberListResponse=} [properties] Properties to set
             */
            function GetGuildMemberListResponse(properties) {
                this.getMemberList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberListResponse getMemberList.
             * @member {Array.<kritor.guild.IMemberInfo>} getMemberList
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.getMemberList = $util.emptyArray;

            /**
             * GetGuildMemberListResponse nextToken.
             * @member {string} nextToken
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.nextToken = "";

            /**
             * GetGuildMemberListResponse finished.
             * @member {boolean} finished
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.finished = false;

            /**
             * Creates a new GetGuildMemberListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse instance
             */
            GetGuildMemberListResponse.create = function create(properties) {
                return new GetGuildMemberListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMemberListResponse message. Does not implicitly {@link kritor.guild.GetGuildMemberListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse} message GetGuildMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.getMemberList != null && message.getMemberList.length)
                    for (let i = 0; i < message.getMemberList.length; ++i)
                        $root.kritor.guild.MemberInfo.encode(message.getMemberList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextToken);
                if (message.finished != null && Object.hasOwnProperty.call(message, "finished"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.finished);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse} message GetGuildMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.getMemberList && message.getMemberList.length))
                                message.getMemberList = [];
                            message.getMemberList.push($root.kritor.guild.MemberInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.nextToken = reader.string();
                            break;
                        }
                    case 3: {
                            message.finished = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.getMemberList != null && message.hasOwnProperty("getMemberList")) {
                    if (!Array.isArray(message.getMemberList))
                        return "getMemberList: array expected";
                    for (let i = 0; i < message.getMemberList.length; ++i) {
                        let error = $root.kritor.guild.MemberInfo.verify(message.getMemberList[i]);
                        if (error)
                            return "getMemberList." + error;
                    }
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!$util.isString(message.nextToken))
                        return "nextToken: string expected";
                if (message.finished != null && message.hasOwnProperty("finished"))
                    if (typeof message.finished !== "boolean")
                        return "finished: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             */
            GetGuildMemberListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberListResponse();
                if (object.getMemberList) {
                    if (!Array.isArray(object.getMemberList))
                        throw TypeError(".kritor.guild.GetGuildMemberListResponse.getMemberList: array expected");
                    message.getMemberList = [];
                    for (let i = 0; i < object.getMemberList.length; ++i) {
                        if (typeof object.getMemberList[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildMemberListResponse.getMemberList: object expected");
                        message.getMemberList[i] = $root.kritor.guild.MemberInfo.fromObject(object.getMemberList[i]);
                    }
                }
                if (object.nextToken != null)
                    message.nextToken = String(object.nextToken);
                if (object.finished != null)
                    message.finished = Boolean(object.finished);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.GetGuildMemberListResponse} message GetGuildMemberListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.getMemberList = [];
                if (options.defaults) {
                    object.nextToken = "";
                    object.finished = false;
                }
                if (message.getMemberList && message.getMemberList.length) {
                    object.getMemberList = [];
                    for (let j = 0; j < message.getMemberList.length; ++j)
                        object.getMemberList[j] = $root.kritor.guild.MemberInfo.toObject(message.getMemberList[j], options);
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = message.nextToken;
                if (message.finished != null && message.hasOwnProperty("finished"))
                    object.finished = message.finished;
                return object;
            };

            /**
             * Converts this GetGuildMemberListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberListResponse";
            };

            return GetGuildMemberListResponse;
        })();

        guild.GetGuildMemberRequest = (function() {

            /**
             * Properties of a GetGuildMemberRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMemberRequest
             * @property {number|Long|null} [guildId] GetGuildMemberRequest guildId
             * @property {number|Long|null} [tinyId] GetGuildMemberRequest tinyId
             */

            /**
             * Constructs a new GetGuildMemberRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberRequest.
             * @implements IGetGuildMemberRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMemberRequest=} [properties] Properties to set
             */
            function GetGuildMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             */
            GetGuildMemberRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMemberRequest tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             */
            GetGuildMemberRequest.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest instance
             */
            GetGuildMemberRequest.create = function create(properties) {
                return new GetGuildMemberRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMemberRequest message. Does not implicitly {@link kritor.guild.GetGuildMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest} message GetGuildMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tinyId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest} message GetGuildMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             */
            GetGuildMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.GetGuildMemberRequest} message GetGuildMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                return object;
            };

            /**
             * Converts this GetGuildMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberRequest";
            };

            return GetGuildMemberRequest;
        })();

        guild.GetGuildMemberResponse = (function() {

            /**
             * Properties of a GetGuildMemberResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMemberResponse
             * @property {kritor.guild.IMemberProfile|null} [memberInfo] GetGuildMemberResponse memberInfo
             */

            /**
             * Constructs a new GetGuildMemberResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberResponse.
             * @implements IGetGuildMemberResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMemberResponse=} [properties] Properties to set
             */
            function GetGuildMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberResponse memberInfo.
             * @member {kritor.guild.IMemberProfile|null|undefined} memberInfo
             * @memberof kritor.guild.GetGuildMemberResponse
             * @instance
             */
            GetGuildMemberResponse.prototype.memberInfo = null;

            /**
             * Creates a new GetGuildMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse instance
             */
            GetGuildMemberResponse.create = function create(properties) {
                return new GetGuildMemberResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMemberResponse message. Does not implicitly {@link kritor.guild.GetGuildMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse} message GetGuildMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.memberInfo != null && Object.hasOwnProperty.call(message, "memberInfo"))
                    $root.kritor.guild.MemberProfile.encode(message.memberInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse} message GetGuildMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.memberInfo = $root.kritor.guild.MemberProfile.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.memberInfo != null && message.hasOwnProperty("memberInfo")) {
                    let error = $root.kritor.guild.MemberProfile.verify(message.memberInfo);
                    if (error)
                        return "memberInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetGuildMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             */
            GetGuildMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberResponse();
                if (object.memberInfo != null) {
                    if (typeof object.memberInfo !== "object")
                        throw TypeError(".kritor.guild.GetGuildMemberResponse.memberInfo: object expected");
                    message.memberInfo = $root.kritor.guild.MemberProfile.fromObject(object.memberInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.GetGuildMemberResponse} message GetGuildMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.memberInfo = null;
                if (message.memberInfo != null && message.hasOwnProperty("memberInfo"))
                    object.memberInfo = $root.kritor.guild.MemberProfile.toObject(message.memberInfo, options);
                return object;
            };

            /**
             * Converts this GetGuildMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberResponse";
            };

            return GetGuildMemberResponse;
        })();

        guild.SendChannelMessageRequest = (function() {

            /**
             * Properties of a SendChannelMessageRequest.
             * @memberof kritor.guild
             * @interface ISendChannelMessageRequest
             * @property {number|Long|null} [guildId] SendChannelMessageRequest guildId
             * @property {number|Long|null} [channelId] SendChannelMessageRequest channelId
             * @property {string|null} [message] SendChannelMessageRequest message
             * @property {number|null} [retryCnt] SendChannelMessageRequest retryCnt
             * @property {number|Long|null} [recallDuration] SendChannelMessageRequest recallDuration
             */

            /**
             * Constructs a new SendChannelMessageRequest.
             * @memberof kritor.guild
             * @classdesc Represents a SendChannelMessageRequest.
             * @implements ISendChannelMessageRequest
             * @constructor
             * @param {kritor.guild.ISendChannelMessageRequest=} [properties] Properties to set
             */
            function SendChannelMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChannelMessageRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageRequest channelId.
             * @member {number|Long} channelId
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageRequest message.
             * @member {string} message
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.message = "";

            /**
             * SendChannelMessageRequest retryCnt.
             * @member {number} retryCnt
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.retryCnt = 0;

            /**
             * SendChannelMessageRequest recallDuration.
             * @member {number|Long} recallDuration
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.recallDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SendChannelMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest=} [properties] Properties to set
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest instance
             */
            SendChannelMessageRequest.create = function create(properties) {
                return new SendChannelMessageRequest(properties);
            };

            /**
             * Encodes the specified SendChannelMessageRequest message. Does not implicitly {@link kritor.guild.SendChannelMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest} message SendChannelMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.channelId);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
                if (message.retryCnt != null && Object.hasOwnProperty.call(message, "retryCnt"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.retryCnt);
                if (message.recallDuration != null && Object.hasOwnProperty.call(message, "recallDuration"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.recallDuration);
                return writer;
            };

            /**
             * Encodes the specified SendChannelMessageRequest message, length delimited. Does not implicitly {@link kritor.guild.SendChannelMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest} message SendChannelMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChannelMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SendChannelMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.channelId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.message = reader.string();
                            break;
                        }
                    case 4: {
                            message.retryCnt = reader.int32();
                            break;
                        }
                    case 5: {
                            message.recallDuration = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendChannelMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChannelMessageRequest message.
             * @function verify
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChannelMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                        return "channelId: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.retryCnt != null && message.hasOwnProperty("retryCnt"))
                    if (!$util.isInteger(message.retryCnt))
                        return "retryCnt: integer expected";
                if (message.recallDuration != null && message.hasOwnProperty("recallDuration"))
                    if (!$util.isInteger(message.recallDuration) && !(message.recallDuration && $util.isInteger(message.recallDuration.low) && $util.isInteger(message.recallDuration.high)))
                        return "recallDuration: integer|Long expected";
                return null;
            };

            /**
             * Creates a SendChannelMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             */
            SendChannelMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SendChannelMessageRequest)
                    return object;
                let message = new $root.kritor.guild.SendChannelMessageRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.channelId != null)
                    if ($util.Long)
                        (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                    else if (typeof object.channelId === "string")
                        message.channelId = parseInt(object.channelId, 10);
                    else if (typeof object.channelId === "number")
                        message.channelId = object.channelId;
                    else if (typeof object.channelId === "object")
                        message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
                if (object.message != null)
                    message.message = String(object.message);
                if (object.retryCnt != null)
                    message.retryCnt = object.retryCnt | 0;
                if (object.recallDuration != null)
                    if ($util.Long)
                        (message.recallDuration = $util.Long.fromValue(object.recallDuration)).unsigned = false;
                    else if (typeof object.recallDuration === "string")
                        message.recallDuration = parseInt(object.recallDuration, 10);
                    else if (typeof object.recallDuration === "number")
                        message.recallDuration = object.recallDuration;
                    else if (typeof object.recallDuration === "object")
                        message.recallDuration = new $util.LongBits(object.recallDuration.low >>> 0, object.recallDuration.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SendChannelMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.SendChannelMessageRequest} message SendChannelMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendChannelMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.channelId = options.longs === String ? "0" : 0;
                    object.message = "";
                    object.retryCnt = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.recallDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.recallDuration = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (typeof message.channelId === "number")
                        object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                    else
                        object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.retryCnt != null && message.hasOwnProperty("retryCnt"))
                    object.retryCnt = message.retryCnt;
                if (message.recallDuration != null && message.hasOwnProperty("recallDuration"))
                    if (typeof message.recallDuration === "number")
                        object.recallDuration = options.longs === String ? String(message.recallDuration) : message.recallDuration;
                    else
                        object.recallDuration = options.longs === String ? $util.Long.prototype.toString.call(message.recallDuration) : options.longs === Number ? new $util.LongBits(message.recallDuration.low >>> 0, message.recallDuration.high >>> 0).toNumber() : message.recallDuration;
                return object;
            };

            /**
             * Converts this SendChannelMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendChannelMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendChannelMessageRequest
             * @function getTypeUrl
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendChannelMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SendChannelMessageRequest";
            };

            return SendChannelMessageRequest;
        })();

        guild.SendChannelMessageResponse = (function() {

            /**
             * Properties of a SendChannelMessageResponse.
             * @memberof kritor.guild
             * @interface ISendChannelMessageResponse
             * @property {number|Long|null} [messageId] SendChannelMessageResponse messageId
             * @property {number|Long|null} [time] SendChannelMessageResponse time
             */

            /**
             * Constructs a new SendChannelMessageResponse.
             * @memberof kritor.guild
             * @classdesc Represents a SendChannelMessageResponse.
             * @implements ISendChannelMessageResponse
             * @constructor
             * @param {kritor.guild.ISendChannelMessageResponse=} [properties] Properties to set
             */
            function SendChannelMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChannelMessageResponse messageId.
             * @member {number|Long} messageId
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             */
            SendChannelMessageResponse.prototype.messageId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageResponse time.
             * @member {number|Long} time
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             */
            SendChannelMessageResponse.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SendChannelMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse=} [properties] Properties to set
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse instance
             */
            SendChannelMessageResponse.create = function create(properties) {
                return new SendChannelMessageResponse(properties);
            };

            /**
             * Encodes the specified SendChannelMessageResponse message. Does not implicitly {@link kritor.guild.SendChannelMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse} message SendChannelMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.messageId);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
                return writer;
            };

            /**
             * Encodes the specified SendChannelMessageResponse message, length delimited. Does not implicitly {@link kritor.guild.SendChannelMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse} message SendChannelMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChannelMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SendChannelMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.time = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendChannelMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChannelMessageResponse message.
             * @function verify
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChannelMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isInteger(message.messageId) && !(message.messageId && $util.isInteger(message.messageId.low) && $util.isInteger(message.messageId.high)))
                        return "messageId: integer|Long expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                        return "time: integer|Long expected";
                return null;
            };

            /**
             * Creates a SendChannelMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             */
            SendChannelMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SendChannelMessageResponse)
                    return object;
                let message = new $root.kritor.guild.SendChannelMessageResponse();
                if (object.messageId != null)
                    if ($util.Long)
                        (message.messageId = $util.Long.fromValue(object.messageId)).unsigned = true;
                    else if (typeof object.messageId === "string")
                        message.messageId = parseInt(object.messageId, 10);
                    else if (typeof object.messageId === "number")
                        message.messageId = object.messageId;
                    else if (typeof object.messageId === "object")
                        message.messageId = new $util.LongBits(object.messageId.low >>> 0, object.messageId.high >>> 0).toNumber(true);
                if (object.time != null)
                    if ($util.Long)
                        (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                    else if (typeof object.time === "string")
                        message.time = parseInt(object.time, 10);
                    else if (typeof object.time === "number")
                        message.time = object.time;
                    else if (typeof object.time === "object")
                        message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SendChannelMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.SendChannelMessageResponse} message SendChannelMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendChannelMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.time = options.longs === String ? "0" : 0;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (typeof message.messageId === "number")
                        object.messageId = options.longs === String ? String(message.messageId) : message.messageId;
                    else
                        object.messageId = options.longs === String ? $util.Long.prototype.toString.call(message.messageId) : options.longs === Number ? new $util.LongBits(message.messageId.low >>> 0, message.messageId.high >>> 0).toNumber(true) : message.messageId;
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time === "number")
                        object.time = options.longs === String ? String(message.time) : message.time;
                    else
                        object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                return object;
            };

            /**
             * Converts this SendChannelMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendChannelMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendChannelMessageResponse
             * @function getTypeUrl
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendChannelMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SendChannelMessageResponse";
            };

            return SendChannelMessageResponse;
        })();

        guild.GetGuildFeedsRequest = (function() {

            /**
             * Properties of a GetGuildFeedsRequest.
             * @memberof kritor.guild
             * @interface IGetGuildFeedsRequest
             * @property {number|Long|null} [guildId] GetGuildFeedsRequest guildId
             * @property {number|null} [from] GetGuildFeedsRequest from
             */

            /**
             * Constructs a new GetGuildFeedsRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildFeedsRequest.
             * @implements IGetGuildFeedsRequest
             * @constructor
             * @param {kritor.guild.IGetGuildFeedsRequest=} [properties] Properties to set
             */
            function GetGuildFeedsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildFeedsRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @instance
             */
            GetGuildFeedsRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildFeedsRequest from.
             * @member {number} from
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @instance
             */
            GetGuildFeedsRequest.prototype.from = 0;

            /**
             * Creates a new GetGuildFeedsRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedsRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildFeedsRequest} GetGuildFeedsRequest instance
             */
            GetGuildFeedsRequest.create = function create(properties) {
                return new GetGuildFeedsRequest(properties);
            };

            /**
             * Encodes the specified GetGuildFeedsRequest message. Does not implicitly {@link kritor.guild.GetGuildFeedsRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedsRequest} message GetGuildFeedsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.from);
                return writer;
            };

            /**
             * Encodes the specified GetGuildFeedsRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildFeedsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedsRequest} message GetGuildFeedsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildFeedsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildFeedsRequest} GetGuildFeedsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildFeedsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.from = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildFeedsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildFeedsRequest} GetGuildFeedsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildFeedsRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildFeedsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (!$util.isInteger(message.from))
                        return "from: integer expected";
                return null;
            };

            /**
             * Creates a GetGuildFeedsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildFeedsRequest} GetGuildFeedsRequest
             */
            GetGuildFeedsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildFeedsRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildFeedsRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.from != null)
                    message.from = object.from >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetGuildFeedsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {kritor.guild.GetGuildFeedsRequest} message GetGuildFeedsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildFeedsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.from = 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = message.from;
                return object;
            };

            /**
             * Converts this GetGuildFeedsRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildFeedsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildFeedsRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildFeedsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildFeedsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildFeedsRequest";
            };

            return GetGuildFeedsRequest;
        })();

        guild.GetGuildFeedsResponse = (function() {

            /**
             * Properties of a GetGuildFeedsResponse.
             * @memberof kritor.guild
             * @interface IGetGuildFeedsResponse
             * @property {Uint8Array|null} [data] GetGuildFeedsResponse data
             */

            /**
             * Constructs a new GetGuildFeedsResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildFeedsResponse.
             * @implements IGetGuildFeedsResponse
             * @constructor
             * @param {kritor.guild.IGetGuildFeedsResponse=} [properties] Properties to set
             */
            function GetGuildFeedsResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildFeedsResponse data.
             * @member {Uint8Array} data
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @instance
             */
            GetGuildFeedsResponse.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new GetGuildFeedsResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedsResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildFeedsResponse} GetGuildFeedsResponse instance
             */
            GetGuildFeedsResponse.create = function create(properties) {
                return new GetGuildFeedsResponse(properties);
            };

            /**
             * Encodes the specified GetGuildFeedsResponse message. Does not implicitly {@link kritor.guild.GetGuildFeedsResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedsResponse} message GetGuildFeedsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified GetGuildFeedsResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildFeedsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedsResponse} message GetGuildFeedsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildFeedsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildFeedsResponse} GetGuildFeedsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildFeedsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.data = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildFeedsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildFeedsResponse} GetGuildFeedsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildFeedsResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildFeedsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a GetGuildFeedsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildFeedsResponse} GetGuildFeedsResponse
             */
            GetGuildFeedsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildFeedsResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildFeedsResponse();
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length >= 0)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a GetGuildFeedsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {kritor.guild.GetGuildFeedsResponse} message GetGuildFeedsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildFeedsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this GetGuildFeedsResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildFeedsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildFeedsResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildFeedsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildFeedsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildFeedsResponse";
            };

            return GetGuildFeedsResponse;
        })();

        guild.GetGuildRolesRequest = (function() {

            /**
             * Properties of a GetGuildRolesRequest.
             * @memberof kritor.guild
             * @interface IGetGuildRolesRequest
             * @property {number|Long|null} [guildId] GetGuildRolesRequest guildId
             */

            /**
             * Constructs a new GetGuildRolesRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildRolesRequest.
             * @implements IGetGuildRolesRequest
             * @constructor
             * @param {kritor.guild.IGetGuildRolesRequest=} [properties] Properties to set
             */
            function GetGuildRolesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildRolesRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildRolesRequest
             * @instance
             */
            GetGuildRolesRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildRolesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {kritor.guild.IGetGuildRolesRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildRolesRequest} GetGuildRolesRequest instance
             */
            GetGuildRolesRequest.create = function create(properties) {
                return new GetGuildRolesRequest(properties);
            };

            /**
             * Encodes the specified GetGuildRolesRequest message. Does not implicitly {@link kritor.guild.GetGuildRolesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {kritor.guild.IGetGuildRolesRequest} message GetGuildRolesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRolesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildRolesRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildRolesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {kritor.guild.IGetGuildRolesRequest} message GetGuildRolesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRolesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildRolesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildRolesRequest} GetGuildRolesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRolesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildRolesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildRolesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildRolesRequest} GetGuildRolesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRolesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildRolesRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildRolesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildRolesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildRolesRequest} GetGuildRolesRequest
             */
            GetGuildRolesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildRolesRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildRolesRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildRolesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {kritor.guild.GetGuildRolesRequest} message GetGuildRolesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildRolesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                return object;
            };

            /**
             * Converts this GetGuildRolesRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildRolesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildRolesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildRolesRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildRolesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildRolesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildRolesRequest";
            };

            return GetGuildRolesRequest;
        })();

        guild.GetGuildRolesResponse = (function() {

            /**
             * Properties of a GetGuildRolesResponse.
             * @memberof kritor.guild
             * @interface IGetGuildRolesResponse
             * @property {Array.<kritor.guild.IRolesInfo>|null} [getRoleList] GetGuildRolesResponse getRoleList
             */

            /**
             * Constructs a new GetGuildRolesResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildRolesResponse.
             * @implements IGetGuildRolesResponse
             * @constructor
             * @param {kritor.guild.IGetGuildRolesResponse=} [properties] Properties to set
             */
            function GetGuildRolesResponse(properties) {
                this.getRoleList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildRolesResponse getRoleList.
             * @member {Array.<kritor.guild.IRolesInfo>} getRoleList
             * @memberof kritor.guild.GetGuildRolesResponse
             * @instance
             */
            GetGuildRolesResponse.prototype.getRoleList = $util.emptyArray;

            /**
             * Creates a new GetGuildRolesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {kritor.guild.IGetGuildRolesResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildRolesResponse} GetGuildRolesResponse instance
             */
            GetGuildRolesResponse.create = function create(properties) {
                return new GetGuildRolesResponse(properties);
            };

            /**
             * Encodes the specified GetGuildRolesResponse message. Does not implicitly {@link kritor.guild.GetGuildRolesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {kritor.guild.IGetGuildRolesResponse} message GetGuildRolesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRolesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.getRoleList != null && message.getRoleList.length)
                    for (let i = 0; i < message.getRoleList.length; ++i)
                        $root.kritor.guild.RolesInfo.encode(message.getRoleList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildRolesResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildRolesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {kritor.guild.IGetGuildRolesResponse} message GetGuildRolesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRolesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildRolesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildRolesResponse} GetGuildRolesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRolesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildRolesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.getRoleList && message.getRoleList.length))
                                message.getRoleList = [];
                            message.getRoleList.push($root.kritor.guild.RolesInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildRolesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildRolesResponse} GetGuildRolesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRolesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildRolesResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildRolesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.getRoleList != null && message.hasOwnProperty("getRoleList")) {
                    if (!Array.isArray(message.getRoleList))
                        return "getRoleList: array expected";
                    for (let i = 0; i < message.getRoleList.length; ++i) {
                        let error = $root.kritor.guild.RolesInfo.verify(message.getRoleList[i]);
                        if (error)
                            return "getRoleList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGuildRolesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildRolesResponse} GetGuildRolesResponse
             */
            GetGuildRolesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildRolesResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildRolesResponse();
                if (object.getRoleList) {
                    if (!Array.isArray(object.getRoleList))
                        throw TypeError(".kritor.guild.GetGuildRolesResponse.getRoleList: array expected");
                    message.getRoleList = [];
                    for (let i = 0; i < object.getRoleList.length; ++i) {
                        if (typeof object.getRoleList[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildRolesResponse.getRoleList: object expected");
                        message.getRoleList[i] = $root.kritor.guild.RolesInfo.fromObject(object.getRoleList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildRolesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {kritor.guild.GetGuildRolesResponse} message GetGuildRolesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildRolesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.getRoleList = [];
                if (message.getRoleList && message.getRoleList.length) {
                    object.getRoleList = [];
                    for (let j = 0; j < message.getRoleList.length; ++j)
                        object.getRoleList[j] = $root.kritor.guild.RolesInfo.toObject(message.getRoleList[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGuildRolesResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildRolesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildRolesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildRolesResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildRolesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildRolesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildRolesResponse";
            };

            return GetGuildRolesResponse;
        })();

        guild.DeleteGuildRoleRequest = (function() {

            /**
             * Properties of a DeleteGuildRoleRequest.
             * @memberof kritor.guild
             * @interface IDeleteGuildRoleRequest
             * @property {number|Long|null} [guildId] DeleteGuildRoleRequest guildId
             * @property {number|Long|null} [roleId] DeleteGuildRoleRequest roleId
             */

            /**
             * Constructs a new DeleteGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a DeleteGuildRoleRequest.
             * @implements IDeleteGuildRoleRequest
             * @constructor
             * @param {kritor.guild.IDeleteGuildRoleRequest=} [properties] Properties to set
             */
            function DeleteGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteGuildRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             */
            DeleteGuildRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteGuildRoleRequest roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             */
            DeleteGuildRoleRequest.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new DeleteGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest instance
             */
            DeleteGuildRoleRequest.create = function create(properties) {
                return new DeleteGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified DeleteGuildRoleRequest message. Does not implicitly {@link kritor.guild.DeleteGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest} message DeleteGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified DeleteGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.DeleteGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest} message DeleteGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.DeleteGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                return null;
            };

            /**
             * Creates a DeleteGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             */
            DeleteGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.DeleteGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.DeleteGuildRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a DeleteGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.DeleteGuildRoleRequest} message DeleteGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                return object;
            };

            /**
             * Converts this DeleteGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.DeleteGuildRoleRequest";
            };

            return DeleteGuildRoleRequest;
        })();

        guild.DeleteGuildRoleResponse = (function() {

            /**
             * Properties of a DeleteGuildRoleResponse.
             * @memberof kritor.guild
             * @interface IDeleteGuildRoleResponse
             */

            /**
             * Constructs a new DeleteGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a DeleteGuildRoleResponse.
             * @implements IDeleteGuildRoleResponse
             * @constructor
             * @param {kritor.guild.IDeleteGuildRoleResponse=} [properties] Properties to set
             */
            function DeleteGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse instance
             */
            DeleteGuildRoleResponse.create = function create(properties) {
                return new DeleteGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified DeleteGuildRoleResponse message. Does not implicitly {@link kritor.guild.DeleteGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse} message DeleteGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.DeleteGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse} message DeleteGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.DeleteGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             */
            DeleteGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.DeleteGuildRoleResponse)
                    return object;
                return new $root.kritor.guild.DeleteGuildRoleResponse();
            };

            /**
             * Creates a plain object from a DeleteGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.DeleteGuildRoleResponse} message DeleteGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteGuildRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.DeleteGuildRoleResponse";
            };

            return DeleteGuildRoleResponse;
        })();

        guild.SetGuildMemberRoleRequest = (function() {

            /**
             * Properties of a SetGuildMemberRoleRequest.
             * @memberof kritor.guild
             * @interface ISetGuildMemberRoleRequest
             * @property {number|Long|null} [guildId] SetGuildMemberRoleRequest guildId
             * @property {number|Long|null} [roleId] SetGuildMemberRoleRequest roleId
             * @property {boolean|null} [set] SetGuildMemberRoleRequest set
             * @property {Array.<string>|null} [users] SetGuildMemberRoleRequest users
             * @property {number|Long|null} [tinyId] SetGuildMemberRoleRequest tinyId
             */

            /**
             * Constructs a new SetGuildMemberRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a SetGuildMemberRoleRequest.
             * @implements ISetGuildMemberRoleRequest
             * @constructor
             * @param {kritor.guild.ISetGuildMemberRoleRequest=} [properties] Properties to set
             */
            function SetGuildMemberRoleRequest(properties) {
                this.users = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGuildMemberRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGuildMemberRoleRequest roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGuildMemberRoleRequest set.
             * @member {boolean} set
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.set = false;

            /**
             * SetGuildMemberRoleRequest users.
             * @member {Array.<string>} users
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.users = $util.emptyArray;

            /**
             * SetGuildMemberRoleRequest tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SetGuildMemberRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest instance
             */
            SetGuildMemberRoleRequest.create = function create(properties) {
                return new SetGuildMemberRoleRequest(properties);
            };

            /**
             * Encodes the specified SetGuildMemberRoleRequest message. Does not implicitly {@link kritor.guild.SetGuildMemberRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest} message SetGuildMemberRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roleId);
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.set);
                if (message.users != null && message.users.length)
                    for (let i = 0; i < message.users.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.users[i]);
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.tinyId);
                return writer;
            };

            /**
             * Encodes the specified SetGuildMemberRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.SetGuildMemberRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest} message SetGuildMemberRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGuildMemberRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SetGuildMemberRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.set = reader.bool();
                            break;
                        }
                    case 4: {
                            if (!(message.users && message.users.length))
                                message.users = [];
                            message.users.push(reader.string());
                            break;
                        }
                    case 5: {
                            message.tinyId = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGuildMemberRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGuildMemberRoleRequest message.
             * @function verify
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGuildMemberRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.set != null && message.hasOwnProperty("set"))
                    if (typeof message.set !== "boolean")
                        return "set: boolean expected";
                if (message.users != null && message.hasOwnProperty("users")) {
                    if (!Array.isArray(message.users))
                        return "users: array expected";
                    for (let i = 0; i < message.users.length; ++i)
                        if (!$util.isString(message.users[i]))
                            return "users: string[] expected";
                }
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                return null;
            };

            /**
             * Creates a SetGuildMemberRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             */
            SetGuildMemberRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SetGuildMemberRoleRequest)
                    return object;
                let message = new $root.kritor.guild.SetGuildMemberRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.set != null)
                    message.set = Boolean(object.set);
                if (object.users) {
                    if (!Array.isArray(object.users))
                        throw TypeError(".kritor.guild.SetGuildMemberRoleRequest.users: array expected");
                    message.users = [];
                    for (let i = 0; i < object.users.length; ++i)
                        message.users[i] = String(object.users[i]);
                }
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = false;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SetGuildMemberRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.SetGuildMemberRoleRequest} message SetGuildMemberRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGuildMemberRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.users = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.set = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.set != null && message.hasOwnProperty("set"))
                    object.set = message.set;
                if (message.users && message.users.length) {
                    object.users = [];
                    for (let j = 0; j < message.users.length; ++j)
                        object.users[j] = message.users[j];
                }
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber() : message.tinyId;
                return object;
            };

            /**
             * Converts this SetGuildMemberRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGuildMemberRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGuildMemberRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGuildMemberRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SetGuildMemberRoleRequest";
            };

            return SetGuildMemberRoleRequest;
        })();

        guild.SetGuildMemberRoleResponse = (function() {

            /**
             * Properties of a SetGuildMemberRoleResponse.
             * @memberof kritor.guild
             * @interface ISetGuildMemberRoleResponse
             */

            /**
             * Constructs a new SetGuildMemberRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a SetGuildMemberRoleResponse.
             * @implements ISetGuildMemberRoleResponse
             * @constructor
             * @param {kritor.guild.ISetGuildMemberRoleResponse=} [properties] Properties to set
             */
            function SetGuildMemberRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGuildMemberRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse instance
             */
            SetGuildMemberRoleResponse.create = function create(properties) {
                return new SetGuildMemberRoleResponse(properties);
            };

            /**
             * Encodes the specified SetGuildMemberRoleResponse message. Does not implicitly {@link kritor.guild.SetGuildMemberRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse} message SetGuildMemberRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGuildMemberRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.SetGuildMemberRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse} message SetGuildMemberRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGuildMemberRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SetGuildMemberRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGuildMemberRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGuildMemberRoleResponse message.
             * @function verify
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGuildMemberRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGuildMemberRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             */
            SetGuildMemberRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SetGuildMemberRoleResponse)
                    return object;
                return new $root.kritor.guild.SetGuildMemberRoleResponse();
            };

            /**
             * Creates a plain object from a SetGuildMemberRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.SetGuildMemberRoleResponse} message SetGuildMemberRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGuildMemberRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGuildMemberRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGuildMemberRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGuildMemberRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGuildMemberRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SetGuildMemberRoleResponse";
            };

            return SetGuildMemberRoleResponse;
        })();

        guild.UpdateGuildRoleRequest = (function() {

            /**
             * Properties of an UpdateGuildRoleRequest.
             * @memberof kritor.guild
             * @interface IUpdateGuildRoleRequest
             * @property {number|Long|null} [guildId] UpdateGuildRoleRequest guildId
             * @property {number|Long|null} [roleId] UpdateGuildRoleRequest roleId
             * @property {string|null} [name] UpdateGuildRoleRequest name
             * @property {number|Long|null} [color] UpdateGuildRoleRequest color
             */

            /**
             * Constructs a new UpdateGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents an UpdateGuildRoleRequest.
             * @implements IUpdateGuildRoleRequest
             * @constructor
             * @param {kritor.guild.IUpdateGuildRoleRequest=} [properties] Properties to set
             */
            function UpdateGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateGuildRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UpdateGuildRoleRequest roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UpdateGuildRoleRequest name.
             * @member {string} name
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.name = "";

            /**
             * UpdateGuildRoleRequest color.
             * @member {number|Long} color
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.color = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new UpdateGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest instance
             */
            UpdateGuildRoleRequest.create = function create(properties) {
                return new UpdateGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified UpdateGuildRoleRequest message. Does not implicitly {@link kritor.guild.UpdateGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest} message UpdateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roleId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.color);
                return writer;
            };

            /**
             * Encodes the specified UpdateGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.UpdateGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest} message UpdateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.UpdateGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.color = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                return null;
            };

            /**
             * Creates an UpdateGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             */
            UpdateGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.UpdateGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.UpdateGuildRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = false;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an UpdateGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.UpdateGuildRoleRequest} message UpdateGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber() : message.color;
                return object;
            };

            /**
             * Converts this UpdateGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.UpdateGuildRoleRequest";
            };

            return UpdateGuildRoleRequest;
        })();

        guild.UpdateGuildRoleResponse = (function() {

            /**
             * Properties of an UpdateGuildRoleResponse.
             * @memberof kritor.guild
             * @interface IUpdateGuildRoleResponse
             */

            /**
             * Constructs a new UpdateGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents an UpdateGuildRoleResponse.
             * @implements IUpdateGuildRoleResponse
             * @constructor
             * @param {kritor.guild.IUpdateGuildRoleResponse=} [properties] Properties to set
             */
            function UpdateGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UpdateGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse instance
             */
            UpdateGuildRoleResponse.create = function create(properties) {
                return new UpdateGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified UpdateGuildRoleResponse message. Does not implicitly {@link kritor.guild.UpdateGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse} message UpdateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UpdateGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.UpdateGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse} message UpdateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.UpdateGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UpdateGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             */
            UpdateGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.UpdateGuildRoleResponse)
                    return object;
                return new $root.kritor.guild.UpdateGuildRoleResponse();
            };

            /**
             * Creates a plain object from an UpdateGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.UpdateGuildRoleResponse} message UpdateGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateGuildRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UpdateGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.UpdateGuildRoleResponse";
            };

            return UpdateGuildRoleResponse;
        })();

        guild.CreateGuildRoleRequest = (function() {

            /**
             * Properties of a CreateGuildRoleRequest.
             * @memberof kritor.guild
             * @interface ICreateGuildRoleRequest
             * @property {number|Long|null} [guildId] CreateGuildRoleRequest guildId
             * @property {string|null} [name] CreateGuildRoleRequest name
             * @property {number|Long|null} [color] CreateGuildRoleRequest color
             * @property {Array.<number|Long>|null} [initialUsers] CreateGuildRoleRequest initialUsers
             */

            /**
             * Constructs a new CreateGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a CreateGuildRoleRequest.
             * @implements ICreateGuildRoleRequest
             * @constructor
             * @param {kritor.guild.ICreateGuildRoleRequest=} [properties] Properties to set
             */
            function CreateGuildRoleRequest(properties) {
                this.initialUsers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGuildRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CreateGuildRoleRequest name.
             * @member {string} name
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.name = "";

            /**
             * CreateGuildRoleRequest color.
             * @member {number|Long} color
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.color = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * CreateGuildRoleRequest initialUsers.
             * @member {Array.<number|Long>} initialUsers
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.initialUsers = $util.emptyArray;

            /**
             * Creates a new CreateGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest instance
             */
            CreateGuildRoleRequest.create = function create(properties) {
                return new CreateGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified CreateGuildRoleRequest message. Does not implicitly {@link kritor.guild.CreateGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest} message CreateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.color);
                if (message.initialUsers != null && message.initialUsers.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (let i = 0; i < message.initialUsers.length; ++i)
                        writer.int64(message.initialUsers[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified CreateGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.CreateGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest} message CreateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.CreateGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.int64();
                            break;
                        }
                    case 4: {
                            if (!(message.initialUsers && message.initialUsers.length))
                                message.initialUsers = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.initialUsers.push(reader.int64());
                            } else
                                message.initialUsers.push(reader.int64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                if (message.initialUsers != null && message.hasOwnProperty("initialUsers")) {
                    if (!Array.isArray(message.initialUsers))
                        return "initialUsers: array expected";
                    for (let i = 0; i < message.initialUsers.length; ++i)
                        if (!$util.isInteger(message.initialUsers[i]) && !(message.initialUsers[i] && $util.isInteger(message.initialUsers[i].low) && $util.isInteger(message.initialUsers[i].high)))
                            return "initialUsers: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a CreateGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             */
            CreateGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.CreateGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.CreateGuildRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = false;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber();
                if (object.initialUsers) {
                    if (!Array.isArray(object.initialUsers))
                        throw TypeError(".kritor.guild.CreateGuildRoleRequest.initialUsers: array expected");
                    message.initialUsers = [];
                    for (let i = 0; i < object.initialUsers.length; ++i)
                        if ($util.Long)
                            (message.initialUsers[i] = $util.Long.fromValue(object.initialUsers[i])).unsigned = false;
                        else if (typeof object.initialUsers[i] === "string")
                            message.initialUsers[i] = parseInt(object.initialUsers[i], 10);
                        else if (typeof object.initialUsers[i] === "number")
                            message.initialUsers[i] = object.initialUsers[i];
                        else if (typeof object.initialUsers[i] === "object")
                            message.initialUsers[i] = new $util.LongBits(object.initialUsers[i].low >>> 0, object.initialUsers[i].high >>> 0).toNumber();
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.CreateGuildRoleRequest} message CreateGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.initialUsers = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber() : message.color;
                if (message.initialUsers && message.initialUsers.length) {
                    object.initialUsers = [];
                    for (let j = 0; j < message.initialUsers.length; ++j)
                        if (typeof message.initialUsers[j] === "number")
                            object.initialUsers[j] = options.longs === String ? String(message.initialUsers[j]) : message.initialUsers[j];
                        else
                            object.initialUsers[j] = options.longs === String ? $util.Long.prototype.toString.call(message.initialUsers[j]) : options.longs === Number ? new $util.LongBits(message.initialUsers[j].low >>> 0, message.initialUsers[j].high >>> 0).toNumber() : message.initialUsers[j];
                }
                return object;
            };

            /**
             * Converts this CreateGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.CreateGuildRoleRequest";
            };

            return CreateGuildRoleRequest;
        })();

        guild.CreateGuildRoleResponse = (function() {

            /**
             * Properties of a CreateGuildRoleResponse.
             * @memberof kritor.guild
             * @interface ICreateGuildRoleResponse
             * @property {number|Long|null} [roleId] CreateGuildRoleResponse roleId
             */

            /**
             * Constructs a new CreateGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a CreateGuildRoleResponse.
             * @implements ICreateGuildRoleResponse
             * @constructor
             * @param {kritor.guild.ICreateGuildRoleResponse=} [properties] Properties to set
             */
            function CreateGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGuildRoleResponse roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @instance
             */
            CreateGuildRoleResponse.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CreateGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse instance
             */
            CreateGuildRoleResponse.create = function create(properties) {
                return new CreateGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified CreateGuildRoleResponse message. Does not implicitly {@link kritor.guild.CreateGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse} message CreateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified CreateGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.CreateGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse} message CreateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.CreateGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             */
            CreateGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.CreateGuildRoleResponse)
                    return object;
                let message = new $root.kritor.guild.CreateGuildRoleResponse();
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CreateGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.CreateGuildRoleResponse} message CreateGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateGuildRoleResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                return object;
            };

            /**
             * Converts this CreateGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.CreateGuildRoleResponse";
            };

            return CreateGuildRoleResponse;
        })();

        return guild;
    })();

    kritor.web = (function() {

        /**
         * Namespace web.
         * @memberof kritor
         * @namespace
         */
        const web = {};

        web.WebService = (function() {

            /**
             * Constructs a new WebService service.
             * @memberof kritor.web
             * @classdesc Represents a WebService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function WebService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (WebService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = WebService;

            /**
             * Creates new WebService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.web.WebService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {WebService} RPC service. Useful where requests and/or responses are streamed.
             */
            WebService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.web.WebService#getCookies}.
             * @memberof kritor.web.WebService
             * @typedef GetCookiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCookiesResponse} [response] GetCookiesResponse
             */

            /**
             * Calls GetCookies.
             * @function getCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCookiesRequest} request GetCookiesRequest message or plain object
             * @param {kritor.web.WebService.GetCookiesCallback} callback Node-style callback called with the error, if any, and GetCookiesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCookies = function getCookies(request, callback) {
                return this.rpcCall(getCookies, $root.kritor.web.GetCookiesRequest, $root.kritor.web.GetCookiesResponse, request, callback);
            }, "name", { value: "GetCookies" });

            /**
             * Calls GetCookies.
             * @function getCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCookiesRequest} request GetCookiesRequest message or plain object
             * @returns {Promise<kritor.web.GetCookiesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getCredentials}.
             * @memberof kritor.web.WebService
             * @typedef GetCredentialsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCredentialsResponse} [response] GetCredentialsResponse
             */

            /**
             * Calls GetCredentials.
             * @function getCredentials
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCredentialsRequest} request GetCredentialsRequest message or plain object
             * @param {kritor.web.WebService.GetCredentialsCallback} callback Node-style callback called with the error, if any, and GetCredentialsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCredentials = function getCredentials(request, callback) {
                return this.rpcCall(getCredentials, $root.kritor.web.GetCredentialsRequest, $root.kritor.web.GetCredentialsResponse, request, callback);
            }, "name", { value: "GetCredentials" });

            /**
             * Calls GetCredentials.
             * @function getCredentials
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCredentialsRequest} request GetCredentialsRequest message or plain object
             * @returns {Promise<kritor.web.GetCredentialsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getCSRFToken}.
             * @memberof kritor.web.WebService
             * @typedef GetCSRFTokenCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCSRFTokenResponse} [response] GetCSRFTokenResponse
             */

            /**
             * Calls GetCSRFToken.
             * @function getCSRFToken
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCSRFTokenRequest} request GetCSRFTokenRequest message or plain object
             * @param {kritor.web.WebService.GetCSRFTokenCallback} callback Node-style callback called with the error, if any, and GetCSRFTokenResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCSRFToken = function getCSRFToken(request, callback) {
                return this.rpcCall(getCSRFToken, $root.kritor.web.GetCSRFTokenRequest, $root.kritor.web.GetCSRFTokenResponse, request, callback);
            }, "name", { value: "GetCSRFToken" });

            /**
             * Calls GetCSRFToken.
             * @function getCSRFToken
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCSRFTokenRequest} request GetCSRFTokenRequest message or plain object
             * @returns {Promise<kritor.web.GetCSRFTokenResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getHttpCookies}.
             * @memberof kritor.web.WebService
             * @typedef GetHttpCookiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetHttpCookiesResponse} [response] GetHttpCookiesResponse
             */

            /**
             * Calls GetHttpCookies.
             * @function getHttpCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetHttpCookiesRequest} request GetHttpCookiesRequest message or plain object
             * @param {kritor.web.WebService.GetHttpCookiesCallback} callback Node-style callback called with the error, if any, and GetHttpCookiesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getHttpCookies = function getHttpCookies(request, callback) {
                return this.rpcCall(getHttpCookies, $root.kritor.web.GetHttpCookiesRequest, $root.kritor.web.GetHttpCookiesResponse, request, callback);
            }, "name", { value: "GetHttpCookies" });

            /**
             * Calls GetHttpCookies.
             * @function getHttpCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetHttpCookiesRequest} request GetHttpCookiesRequest message or plain object
             * @returns {Promise<kritor.web.GetHttpCookiesResponse>} Promise
             * @variation 2
             */

            return WebService;
        })();

        web.GetCookiesRequest = (function() {

            /**
             * Properties of a GetCookiesRequest.
             * @memberof kritor.web
             * @interface IGetCookiesRequest
             * @property {string|null} [domain] GetCookiesRequest domain
             */

            /**
             * Constructs a new GetCookiesRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCookiesRequest.
             * @implements IGetCookiesRequest
             * @constructor
             * @param {kritor.web.IGetCookiesRequest=} [properties] Properties to set
             */
            function GetCookiesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCookiesRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             */
            GetCookiesRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCookiesRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             */
            Object.defineProperty(GetCookiesRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCookiesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest instance
             */
            GetCookiesRequest.create = function create(properties) {
                return new GetCookiesRequest(properties);
            };

            /**
             * Encodes the specified GetCookiesRequest message. Does not implicitly {@link kritor.web.GetCookiesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest} message GetCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCookiesRequest message, length delimited. Does not implicitly {@link kritor.web.GetCookiesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest} message GetCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCookiesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCookiesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCookiesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCookiesRequest message.
             * @function verify
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCookiesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCookiesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             */
            GetCookiesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCookiesRequest)
                    return object;
                let message = new $root.kritor.web.GetCookiesRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCookiesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.GetCookiesRequest} message GetCookiesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCookiesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCookiesRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCookiesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCookiesRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCookiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCookiesRequest";
            };

            return GetCookiesRequest;
        })();

        web.GetCookiesResponse = (function() {

            /**
             * Properties of a GetCookiesResponse.
             * @memberof kritor.web
             * @interface IGetCookiesResponse
             * @property {string|null} [cookie] GetCookiesResponse cookie
             */

            /**
             * Constructs a new GetCookiesResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCookiesResponse.
             * @implements IGetCookiesResponse
             * @constructor
             * @param {kritor.web.IGetCookiesResponse=} [properties] Properties to set
             */
            function GetCookiesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCookiesResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetCookiesResponse
             * @instance
             */
            GetCookiesResponse.prototype.cookie = "";

            /**
             * Creates a new GetCookiesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse instance
             */
            GetCookiesResponse.create = function create(properties) {
                return new GetCookiesResponse(properties);
            };

            /**
             * Encodes the specified GetCookiesResponse message. Does not implicitly {@link kritor.web.GetCookiesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse} message GetCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetCookiesResponse message, length delimited. Does not implicitly {@link kritor.web.GetCookiesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse} message GetCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCookiesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCookiesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCookiesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCookiesResponse message.
             * @function verify
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCookiesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetCookiesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             */
            GetCookiesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCookiesResponse)
                    return object;
                let message = new $root.kritor.web.GetCookiesResponse();
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetCookiesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.GetCookiesResponse} message GetCookiesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCookiesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.cookie = "";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetCookiesResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCookiesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCookiesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCookiesResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCookiesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCookiesResponse";
            };

            return GetCookiesResponse;
        })();

        web.GetCredentialsRequest = (function() {

            /**
             * Properties of a GetCredentialsRequest.
             * @memberof kritor.web
             * @interface IGetCredentialsRequest
             * @property {string|null} [domain] GetCredentialsRequest domain
             */

            /**
             * Constructs a new GetCredentialsRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCredentialsRequest.
             * @implements IGetCredentialsRequest
             * @constructor
             * @param {kritor.web.IGetCredentialsRequest=} [properties] Properties to set
             */
            function GetCredentialsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCredentialsRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             */
            GetCredentialsRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCredentialsRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             */
            Object.defineProperty(GetCredentialsRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCredentialsRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest instance
             */
            GetCredentialsRequest.create = function create(properties) {
                return new GetCredentialsRequest(properties);
            };

            /**
             * Encodes the specified GetCredentialsRequest message. Does not implicitly {@link kritor.web.GetCredentialsRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest} message GetCredentialsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCredentialsRequest message, length delimited. Does not implicitly {@link kritor.web.GetCredentialsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest} message GetCredentialsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCredentialsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCredentialsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCredentialsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCredentialsRequest message.
             * @function verify
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCredentialsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCredentialsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             */
            GetCredentialsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCredentialsRequest)
                    return object;
                let message = new $root.kritor.web.GetCredentialsRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCredentialsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.GetCredentialsRequest} message GetCredentialsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCredentialsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCredentialsRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCredentialsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCredentialsRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCredentialsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCredentialsRequest";
            };

            return GetCredentialsRequest;
        })();

        web.GetCredentialsResponse = (function() {

            /**
             * Properties of a GetCredentialsResponse.
             * @memberof kritor.web
             * @interface IGetCredentialsResponse
             * @property {string|null} [bkn] GetCredentialsResponse bkn
             * @property {string|null} [cookie] GetCredentialsResponse cookie
             */

            /**
             * Constructs a new GetCredentialsResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCredentialsResponse.
             * @implements IGetCredentialsResponse
             * @constructor
             * @param {kritor.web.IGetCredentialsResponse=} [properties] Properties to set
             */
            function GetCredentialsResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCredentialsResponse bkn.
             * @member {string} bkn
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             */
            GetCredentialsResponse.prototype.bkn = "";

            /**
             * GetCredentialsResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             */
            GetCredentialsResponse.prototype.cookie = "";

            /**
             * Creates a new GetCredentialsResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse instance
             */
            GetCredentialsResponse.create = function create(properties) {
                return new GetCredentialsResponse(properties);
            };

            /**
             * Encodes the specified GetCredentialsResponse message. Does not implicitly {@link kritor.web.GetCredentialsResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse} message GetCredentialsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bkn != null && Object.hasOwnProperty.call(message, "bkn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.bkn);
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetCredentialsResponse message, length delimited. Does not implicitly {@link kritor.web.GetCredentialsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse} message GetCredentialsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCredentialsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCredentialsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bkn = reader.string();
                            break;
                        }
                    case 2: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCredentialsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCredentialsResponse message.
             * @function verify
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCredentialsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    if (!$util.isString(message.bkn))
                        return "bkn: string expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetCredentialsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             */
            GetCredentialsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCredentialsResponse)
                    return object;
                let message = new $root.kritor.web.GetCredentialsResponse();
                if (object.bkn != null)
                    message.bkn = String(object.bkn);
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetCredentialsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.GetCredentialsResponse} message GetCredentialsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCredentialsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.bkn = "";
                    object.cookie = "";
                }
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    object.bkn = message.bkn;
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetCredentialsResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCredentialsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCredentialsResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCredentialsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCredentialsResponse";
            };

            return GetCredentialsResponse;
        })();

        web.GetCSRFTokenRequest = (function() {

            /**
             * Properties of a GetCSRFTokenRequest.
             * @memberof kritor.web
             * @interface IGetCSRFTokenRequest
             * @property {string|null} [domain] GetCSRFTokenRequest domain
             */

            /**
             * Constructs a new GetCSRFTokenRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCSRFTokenRequest.
             * @implements IGetCSRFTokenRequest
             * @constructor
             * @param {kritor.web.IGetCSRFTokenRequest=} [properties] Properties to set
             */
            function GetCSRFTokenRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCSRFTokenRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             */
            GetCSRFTokenRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCSRFTokenRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             */
            Object.defineProperty(GetCSRFTokenRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCSRFTokenRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest instance
             */
            GetCSRFTokenRequest.create = function create(properties) {
                return new GetCSRFTokenRequest(properties);
            };

            /**
             * Encodes the specified GetCSRFTokenRequest message. Does not implicitly {@link kritor.web.GetCSRFTokenRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest} message GetCSRFTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCSRFTokenRequest message, length delimited. Does not implicitly {@link kritor.web.GetCSRFTokenRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest} message GetCSRFTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCSRFTokenRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCSRFTokenRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCSRFTokenRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCSRFTokenRequest message.
             * @function verify
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCSRFTokenRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCSRFTokenRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             */
            GetCSRFTokenRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCSRFTokenRequest)
                    return object;
                let message = new $root.kritor.web.GetCSRFTokenRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCSRFTokenRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.GetCSRFTokenRequest} message GetCSRFTokenRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCSRFTokenRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCSRFTokenRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCSRFTokenRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCSRFTokenRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCSRFTokenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCSRFTokenRequest";
            };

            return GetCSRFTokenRequest;
        })();

        web.GetCSRFTokenResponse = (function() {

            /**
             * Properties of a GetCSRFTokenResponse.
             * @memberof kritor.web
             * @interface IGetCSRFTokenResponse
             * @property {string|null} [bkn] GetCSRFTokenResponse bkn
             */

            /**
             * Constructs a new GetCSRFTokenResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCSRFTokenResponse.
             * @implements IGetCSRFTokenResponse
             * @constructor
             * @param {kritor.web.IGetCSRFTokenResponse=} [properties] Properties to set
             */
            function GetCSRFTokenResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCSRFTokenResponse bkn.
             * @member {string} bkn
             * @memberof kritor.web.GetCSRFTokenResponse
             * @instance
             */
            GetCSRFTokenResponse.prototype.bkn = "";

            /**
             * Creates a new GetCSRFTokenResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse instance
             */
            GetCSRFTokenResponse.create = function create(properties) {
                return new GetCSRFTokenResponse(properties);
            };

            /**
             * Encodes the specified GetCSRFTokenResponse message. Does not implicitly {@link kritor.web.GetCSRFTokenResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse} message GetCSRFTokenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bkn != null && Object.hasOwnProperty.call(message, "bkn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.bkn);
                return writer;
            };

            /**
             * Encodes the specified GetCSRFTokenResponse message, length delimited. Does not implicitly {@link kritor.web.GetCSRFTokenResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse} message GetCSRFTokenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCSRFTokenResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCSRFTokenResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bkn = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCSRFTokenResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCSRFTokenResponse message.
             * @function verify
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCSRFTokenResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    if (!$util.isString(message.bkn))
                        return "bkn: string expected";
                return null;
            };

            /**
             * Creates a GetCSRFTokenResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             */
            GetCSRFTokenResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCSRFTokenResponse)
                    return object;
                let message = new $root.kritor.web.GetCSRFTokenResponse();
                if (object.bkn != null)
                    message.bkn = String(object.bkn);
                return message;
            };

            /**
             * Creates a plain object from a GetCSRFTokenResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.GetCSRFTokenResponse} message GetCSRFTokenResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCSRFTokenResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.bkn = "";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    object.bkn = message.bkn;
                return object;
            };

            /**
             * Converts this GetCSRFTokenResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCSRFTokenResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCSRFTokenResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCSRFTokenResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCSRFTokenResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCSRFTokenResponse";
            };

            return GetCSRFTokenResponse;
        })();

        web.GetHttpCookiesRequest = (function() {

            /**
             * Properties of a GetHttpCookiesRequest.
             * @memberof kritor.web
             * @interface IGetHttpCookiesRequest
             * @property {string|null} [appid] GetHttpCookiesRequest appid
             * @property {string|null} [daid] GetHttpCookiesRequest daid
             * @property {string|null} [jumpUrl] GetHttpCookiesRequest jumpUrl
             */

            /**
             * Constructs a new GetHttpCookiesRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetHttpCookiesRequest.
             * @implements IGetHttpCookiesRequest
             * @constructor
             * @param {kritor.web.IGetHttpCookiesRequest=} [properties] Properties to set
             */
            function GetHttpCookiesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHttpCookiesRequest appid.
             * @member {string} appid
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.appid = "";

            /**
             * GetHttpCookiesRequest daid.
             * @member {string} daid
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.daid = "";

            /**
             * GetHttpCookiesRequest jumpUrl.
             * @member {string} jumpUrl
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.jumpUrl = "";

            /**
             * Creates a new GetHttpCookiesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest=} [properties] Properties to set
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest instance
             */
            GetHttpCookiesRequest.create = function create(properties) {
                return new GetHttpCookiesRequest(properties);
            };

            /**
             * Encodes the specified GetHttpCookiesRequest message. Does not implicitly {@link kritor.web.GetHttpCookiesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest} message GetHttpCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.appid);
                if (message.daid != null && Object.hasOwnProperty.call(message, "daid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.daid);
                if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.jumpUrl);
                return writer;
            };

            /**
             * Encodes the specified GetHttpCookiesRequest message, length delimited. Does not implicitly {@link kritor.web.GetHttpCookiesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest} message GetHttpCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHttpCookiesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetHttpCookiesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appid = reader.string();
                            break;
                        }
                    case 2: {
                            message.daid = reader.string();
                            break;
                        }
                    case 3: {
                            message.jumpUrl = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHttpCookiesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHttpCookiesRequest message.
             * @function verify
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHttpCookiesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appid != null && message.hasOwnProperty("appid"))
                    if (!$util.isString(message.appid))
                        return "appid: string expected";
                if (message.daid != null && message.hasOwnProperty("daid"))
                    if (!$util.isString(message.daid))
                        return "daid: string expected";
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    if (!$util.isString(message.jumpUrl))
                        return "jumpUrl: string expected";
                return null;
            };

            /**
             * Creates a GetHttpCookiesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             */
            GetHttpCookiesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetHttpCookiesRequest)
                    return object;
                let message = new $root.kritor.web.GetHttpCookiesRequest();
                if (object.appid != null)
                    message.appid = String(object.appid);
                if (object.daid != null)
                    message.daid = String(object.daid);
                if (object.jumpUrl != null)
                    message.jumpUrl = String(object.jumpUrl);
                return message;
            };

            /**
             * Creates a plain object from a GetHttpCookiesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.GetHttpCookiesRequest} message GetHttpCookiesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHttpCookiesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.appid = "";
                    object.daid = "";
                    object.jumpUrl = "";
                }
                if (message.appid != null && message.hasOwnProperty("appid"))
                    object.appid = message.appid;
                if (message.daid != null && message.hasOwnProperty("daid"))
                    object.daid = message.daid;
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    object.jumpUrl = message.jumpUrl;
                return object;
            };

            /**
             * Converts this GetHttpCookiesRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHttpCookiesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHttpCookiesRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHttpCookiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetHttpCookiesRequest";
            };

            return GetHttpCookiesRequest;
        })();

        web.GetHttpCookiesResponse = (function() {

            /**
             * Properties of a GetHttpCookiesResponse.
             * @memberof kritor.web
             * @interface IGetHttpCookiesResponse
             * @property {string|null} [cookie] GetHttpCookiesResponse cookie
             */

            /**
             * Constructs a new GetHttpCookiesResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetHttpCookiesResponse.
             * @implements IGetHttpCookiesResponse
             * @constructor
             * @param {kritor.web.IGetHttpCookiesResponse=} [properties] Properties to set
             */
            function GetHttpCookiesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHttpCookiesResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetHttpCookiesResponse
             * @instance
             */
            GetHttpCookiesResponse.prototype.cookie = "";

            /**
             * Creates a new GetHttpCookiesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse=} [properties] Properties to set
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse instance
             */
            GetHttpCookiesResponse.create = function create(properties) {
                return new GetHttpCookiesResponse(properties);
            };

            /**
             * Encodes the specified GetHttpCookiesResponse message. Does not implicitly {@link kritor.web.GetHttpCookiesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse} message GetHttpCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetHttpCookiesResponse message, length delimited. Does not implicitly {@link kritor.web.GetHttpCookiesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse} message GetHttpCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHttpCookiesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetHttpCookiesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHttpCookiesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHttpCookiesResponse message.
             * @function verify
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHttpCookiesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetHttpCookiesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             */
            GetHttpCookiesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetHttpCookiesResponse)
                    return object;
                let message = new $root.kritor.web.GetHttpCookiesResponse();
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetHttpCookiesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.GetHttpCookiesResponse} message GetHttpCookiesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHttpCookiesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.cookie = "";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetHttpCookiesResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetHttpCookiesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHttpCookiesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHttpCookiesResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHttpCookiesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetHttpCookiesResponse";
            };

            return GetHttpCookiesResponse;
        })();

        return web;
    })();

    return kritor;
})();

export { $root as default };
